<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Cap&iacute;tulo 5. Heran&ccedil;a</title><link rel="stylesheet" type="text/css" href="estilo.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Programa&ccedil;&atilde;o Orientada a Objetos em C++"><link rel="up" href="index.html" title="Programa&ccedil;&atilde;o Orientada a Objetos em C++"><link rel="prev" href="cha.construtores.destrutores.html" title="Cap&iacute;tulo 4. Construtores e destrutores"><link rel="next" href="cha.sobrecarga.html" title="Cap&iacute;tulo 6. Sobrecarga de operadores"><meta xmlns:fo="http://www.w3.org/1999/XSL/Format" http-equiv="Content-Type" content="text/html; charset=utf-8"><script xmlns:fo="http://www.w3.org/1999/XSL/Format" type="text/x-mathjax-config">
    MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
    tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]}
    });
  </script><script xmlns:fo="http://www.w3.org/1999/XSL/Format" type="text/javascript" src="/mathjax/MathJax.js"></script></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" class="navheader" href="cha.construtores.destrutores.html">&laquo;</a></td><th colspan="3" align="center" class="navheader">Cap&iacute;tulo 5. Heran&ccedil;a</th><td width="20%" align="right">&nbsp;<a accesskey="n" class="navheader" href="cha.sobrecarga.html">&raquo;</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="cha.heranca"></a>Cap&iacute;tulo 5. Heran&ccedil;a</h1></div></div></div><div class="toc"><p><b>&Iacute;ndice</b></p><dl class="toc"><dt><span class="section"><a href="cha.heranca.html#sec.heranca.efeitos">5.1. Efeitos do processo de heran&ccedil;a</a></span></dt><dt><span class="section"><a href="cha.heranca.html#sec.heranca.construtores.destrutores">5.2. Heran&ccedil;a nos construtores e destrutores</a></span></dt><dt><span class="section"><a href="cha.heranca.html#sec.heranca.atribuicoes">5.3. Atribui&ccedil;&otilde;es de valores entre classes</a></span></dt><dt><span class="section"><a href="cha.heranca.html#sec.heranca.exercicios">5.4. Exerc&iacute;cios de fixa&ccedil;&atilde;o</a></span></dt></dl></div>
    
    <p>Entre os seres vivos, o mecanismo de heran&ccedil;a permite que um filho receba caracter&iacute;sticas de seus pais, tornando-se semelhante as estes em praticamente todas as suas funcionalidades. Entretanto, os geralmente filhos apresentam apar&ecirc;ncia e comportamento diferentes dos pais, sinal de que sofreram algum tipo de especializa&ccedil;&atilde;o.</p>
    <p>Para seres n&atilde;o vivos, a ideia da heran&ccedil;a tamb&eacute;m pode ser adotada.</p>
    <p>Considere, por exemplo, a classe dos equipamentos, assumindo que todos eles possuem pelo menos tr&ecirc;s informa&ccedil;&otilde;es em comum: <span class="emphasis"><em>nome, fabricante e pre&ccedil;o</em></span>. De posse dessas informa&ccedil;&otilde;es, poder&iacute;amos implementar uma estrutura em C++ que representasse esta classe, com ilustra o <a class="xref" href="cha.heranca.html#exe.equipamento" title="Exemplo 5.1. Classe em C++ para representar equipamentos gen&eacute;ricos.">Exemplo&nbsp;5.1</a>. Junto com as vari&aacute;veis que armazenam tais informa&ccedil;&otilde;es, s&atilde;o definidas tamb&eacute;m algumas fun&ccedil;&otilde;es para atribuir e recuperar os valores dessas vari&aacute;veis.</p>
    <div class="example"><a name="exe.equipamento"></a><p class="title"><b>Exemplo 5.1. Classe em C++ para representar equipamentos gen&eacute;ricos.</b></p><div class="example-contents">
      
      <pre class="programlisting"><strong class="hl-keyword">class</strong> Equipamento{
  <strong class="hl-keyword">char</strong> nome[<span class="hl-number">100</span>];
  <strong class="hl-keyword">char</strong> fabricante[<span class="hl-number">100</span>];
  <strong class="hl-keyword">float</strong> preco;
<strong class="hl-keyword">public</strong>:
  <strong class="hl-keyword">void</strong> setNome(<strong class="hl-keyword">const</strong> <strong class="hl-keyword">char</strong> *_nome);
  <strong class="hl-keyword">void</strong> setFabricante(<strong class="hl-keyword">const</strong> <strong class="hl-keyword">char</strong> *_fabricante);
  <strong class="hl-keyword">void</strong> setPreco(<strong class="hl-keyword">float</strong> _preco);
  <strong class="hl-keyword">char</strong>* getNome(<strong class="hl-keyword">void</strong>);
  <strong class="hl-keyword">char</strong>* getFabricante(<strong class="hl-keyword">void</strong>);
  <strong class="hl-keyword">float</strong> getPreco(<strong class="hl-keyword">void</strong>);
};</pre>
    </div></div><br class="example-break">
    <p>Um procedimento semelhante pode ser realizado para uma classe representativa dos motores. A todo motor podem ser associados tamb&eacute;m um nome pr&oacute;prio, um fabricante, pre&ccedil;o, pot&ecirc;ncia e velocidade. Seguindo a ideia usada para definir a classe <code class="classname">Equipamento</code>, poder&iacute;amos criar uma implementa&ccedil;&atilde;o para esta classe como mostra o <a class="xref" href="cha.heranca.html#exe.motor-sem-heranca" title="Exemplo 5.2. Defini&ccedil;&atilde;o em C++ da classe Motor.">Exemplo&nbsp;5.2</a>.</p>
    <div class="example"><a name="exe.motor-sem-heranca"></a><p class="title"><b>Exemplo 5.2. Defini&ccedil;&atilde;o em C++ da classe Motor.</b></p><div class="example-contents">
      
      <pre class="programlisting"><strong class="hl-keyword">class</strong> Motor{
  <strong class="hl-keyword">char</strong> nome[<span class="hl-number">100</span>];
  <strong class="hl-keyword">char</strong> fabricante[<span class="hl-number">100</span>];
  <strong class="hl-keyword">float</strong> preco;
  <strong class="hl-keyword">float</strong> potencia;
  <strong class="hl-keyword">float</strong> velocidade;
<strong class="hl-keyword">public</strong>: 
  <strong class="hl-keyword">void</strong> setNome(<strong class="hl-keyword">const</strong> <strong class="hl-keyword">char</strong> *_nome);
  <strong class="hl-keyword">void</strong> setFabricante(<strong class="hl-keyword">const</strong> <strong class="hl-keyword">char</strong> *_fabricante);
  <strong class="hl-keyword">void</strong> setPreco(<strong class="hl-keyword">float</strong> _preco);
  <strong class="hl-keyword">void</strong> setPotencia(<strong class="hl-keyword">float</strong> _potencia);
  <strong class="hl-keyword">void</strong> setVelocidade(<strong class="hl-keyword">float</strong> _velocidade);
  <strong class="hl-keyword">char</strong>* getNome(<strong class="hl-keyword">void</strong>);
  <strong class="hl-keyword">char</strong>* getFabricante(<strong class="hl-keyword">void</strong>);
  <strong class="hl-keyword">float</strong> getPreco(<strong class="hl-keyword">void</strong>);
  <strong class="hl-keyword">float</strong> getPotencia(<strong class="hl-keyword">void</strong>);
  <strong class="hl-keyword">float</strong> getVelocidade(<strong class="hl-keyword">void</strong>);
};</pre>
    </div></div><br class="example-break">
    <p>N&atilde;o &eacute; muito dif&iacute;cil averiguar que ambas as classes compartilham diversas estruturas em comum. Al&eacute;m das vari&aacute;veis, fun&ccedil;&otilde;es semelhantes tamb&eacute;m est&atilde;o presente, com uma flagrante repeti&ccedil;&atilde;o de c&oacute;digo.</p>
    <p>Ora, as classes motor e equipamento est&atilde;o intimamente relacionadas uma com a outra. Em verdade, todo motor <span class="emphasis"><em>&eacute; um</em></span> equipamento, diferindo no fato de que a classe motor especializa a classe equipamento. Em outras palavras, a classe motor <span class="emphasis"><em>herda</em></span> da classe equipamento. O uso de mecanismos de programa&ccedil;&atilde;o adequados pode permitir que sejam estabelecidas rela&ccedil;&otilde;es entre classes, reduzindo esfor&ccedil;os e organizando melhor o c&oacute;digo desenvolvido.</p>
    <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Quando usar heran&ccedil;a..."><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Nota]" src="images/note.png"></td><th align="left">Quando usar heran&ccedil;a...</th></tr><tr><td align="left" valign="top">
    <p>Quando se diz que um objeto da classe <code class="classname">A</code> possui rela&ccedil;&atilde;o do tipo <span class="emphasis"><em>&Eacute; UM</em></span> com um objeto da classe <code class="classname">B</code>, evidencia-se uma rela&ccedil;&atilde;o de heran&ccedil;a entre estas classes. Por exemplo, se um motor <span class="emphasis"><em>&Eacute; UM</em></span> equipamento, &eacute; razo&aacute;vel assumir que a classe dos motores <span class="emphasis"><em>&eacute; herdeira da classe</em></span> equipamento.</p>
    </td></tr></table></div>
    <p>Felizmente, recursos para estabelecer rela&ccedil;&otilde;es de heran&ccedil;a tamb&eacute;m set&atilde;o dispon&iacute;veis nas linguagens orientadas a objeto. Por heran&ccedil;a, &eacute; poss&iacute;vel definir classes herdeiras a partir de outras classes, reaproveitando funcionalidades previamente definidas.</p>
    <p>Em C++, as duas classes previamente descritas podem ser relacionadas, por heran&ccedil;a, como mostra o <a class="xref" href="cha.heranca.html#exe.heranca-motor" title="Exemplo 5.3. Exemplo de heran&ccedil;a simples: a classe motor herda da classe equipamento.">Exemplo&nbsp;5.3</a>.</p>
    <div class="example"><a name="exe.heranca-motor"></a><p class="title"><b>Exemplo 5.3. Exemplo de heran&ccedil;a simples: a classe motor herda da classe equipamento. </b></p><div class="example-contents">
      
      
      <pre class="programlisting"><strong class="hl-keyword">class</strong> Equipamento{
  <strong class="hl-keyword">char</strong> nome[<span class="hl-number">100</span>];
  <strong class="hl-keyword">char</strong> fabricante[<span class="hl-number">100</span>];
  <strong class="hl-keyword">float</strong> preco;
<strong class="hl-keyword">public</strong>:
  <strong class="hl-keyword">void</strong> setNome(<strong class="hl-keyword">const</strong> <strong class="hl-keyword">char</strong> *_nome);
  <strong class="hl-keyword">void</strong> setFabricante(<strong class="hl-keyword">const</strong> <strong class="hl-keyword">char</strong> *_fabricante);
  <strong class="hl-keyword">void</strong> setPreco(<strong class="hl-keyword">float</strong> _preco);
  <strong class="hl-keyword">char</strong>* getNome(<strong class="hl-keyword">void</strong>);
  <strong class="hl-keyword">char</strong>* getFabricante(<strong class="hl-keyword">void</strong>);
  <strong class="hl-keyword">float</strong> getPreco(<strong class="hl-keyword">void</strong>);
};

<strong class="hl-keyword">class</strong> Motor : <strong class="hl-keyword">public</strong> Equipamento{ <a name="co.heranca-equipamento"></a><span><img src="images/callouts/1.svg" alt="1" border="0"></span>
  <strong class="hl-keyword">float</strong> potencia;
  <strong class="hl-keyword">float</strong> velocidade;
<strong class="hl-keyword">public</strong>:
  <strong class="hl-keyword">void</strong> setPotencia(<strong class="hl-keyword">float</strong> _potencia);
  <strong class="hl-keyword">void</strong> setVelocidade(<strong class="hl-keyword">float</strong> _velocidade);
  <strong class="hl-keyword">float</strong> getPotencia(<strong class="hl-keyword">void</strong>);
  <strong class="hl-keyword">float</strong> getVelocidade(<strong class="hl-keyword">void</strong>);
};</pre>
    </div></div><br class="example-break">
    <p>O processo de heran&ccedil;a ocorre logo no in&iacute;cio da defini&ccedil;&atilde;o da classe <code class="classname">Motor</code> <a class="xref" href="cha.heranca.html#co.heranca-equipamento"><span><img src="images/callouts/1.svg" alt="1" border="0"></span></a>. Veja que agora a nova especifica&ccedil;&atilde;o da classe <code class="classname">Motor</code> foi bastante enxugada, contendo apenas novas funcionalidades que n&atilde;o estavam presentes na classe <code class="classname">Equipamento</code>. S&atilde;o definidas apenas duas vari&aacute;veis e quatro fun&ccedil;&otilde;es adicionais &agrave;s que j&aacute; existiam nessa &uacute;ltima. Experimente agora o c&oacute;digo do <a class="xref" href="cha.heranca.html#exe.heranca-equipamento-motor" title="Exemplo 5.4. Programa equip-motor.cpp para ilustrar o uso de heran&ccedil;a.">Exemplo&nbsp;5.4</a> e poder&aacute; verificar que o programa produz os mesmos resultados.</p>
    <div class="example"><a name="exe.heranca-equipamento-motor"></a><p class="title"><b>Exemplo 5.4. Programa <a class="ulink" href="exemplos/equip-motor.cpp" target="_top"><code class="filename">equip-motor.cpp</code></a> para ilustrar o uso de heran&ccedil;a.</b></p><div class="example-contents">
      
      <pre class="programlisting">#include &lt;iostream&gt;
<span class="hl-directive" style="color: maroon">#include &lt;cstring&gt;</span>

<strong class="hl-keyword">using</strong> <strong class="hl-keyword">namespace</strong> std;

<strong class="hl-keyword">class</strong> Equipamento{
  <strong class="hl-keyword">char</strong> nome[<span class="hl-number">100</span>];
  <strong class="hl-keyword">char</strong> fabricante[<span class="hl-number">100</span>];
  <strong class="hl-keyword">float</strong> preco;
<strong class="hl-keyword">public</strong>:
  <strong class="hl-keyword">void</strong> setNome(<strong class="hl-keyword">const</strong> <strong class="hl-keyword">char</strong> *_nome);
  <strong class="hl-keyword">void</strong> setFabricante(<strong class="hl-keyword">const</strong> <strong class="hl-keyword">char</strong> *_fabricante);
  <strong class="hl-keyword">void</strong> setPreco(<strong class="hl-keyword">float</strong> _preco);
  <strong class="hl-keyword">char</strong>* getNome(<strong class="hl-keyword">void</strong>);
  <strong class="hl-keyword">char</strong>* getFabricante(<strong class="hl-keyword">void</strong>);
  <strong class="hl-keyword">float</strong> getPreco(<strong class="hl-keyword">void</strong>);
};

<strong class="hl-keyword">class</strong> Motor : <strong class="hl-keyword">public</strong> Equipamento{
  <strong class="hl-keyword">float</strong> potencia;
  <strong class="hl-keyword">float</strong> velocidade;
<strong class="hl-keyword">public</strong>:
  <strong class="hl-keyword">void</strong> setPotencia(<strong class="hl-keyword">float</strong> _potencia);
  <strong class="hl-keyword">void</strong> setVelocidade(<strong class="hl-keyword">float</strong> _velocidade);
  <strong class="hl-keyword">float</strong> getPotencia(<strong class="hl-keyword">void</strong>);
  <strong class="hl-keyword">float</strong> getVelocidade(<strong class="hl-keyword">void</strong>);
};

<strong class="hl-keyword">void</strong> Equipamento::setNome(<strong class="hl-keyword">const</strong> <strong class="hl-keyword">char</strong> *_nome){
  strcpy(nome,_nome);
}

<strong class="hl-keyword">void</strong> Equipamento::setFabricante(<strong class="hl-keyword">const</strong> <strong class="hl-keyword">char</strong> *_fabricante){
  strcpy(fabricante,_fabricante);
}

<strong class="hl-keyword">void</strong> Equipamento::setPreco(<strong class="hl-keyword">float</strong> _preco){
  preco=_preco;
}

<strong class="hl-keyword">char</strong>* Equipamento::getNome(<strong class="hl-keyword">void</strong>){
  <strong class="hl-keyword">return</strong> nome;
}

<strong class="hl-keyword">char</strong>* Equipamento::getFabricante(<strong class="hl-keyword">void</strong>){
  <strong class="hl-keyword">return</strong> fabricante;
}

<strong class="hl-keyword">float</strong> Equipamento::getPreco(<strong class="hl-keyword">void</strong>){
  <strong class="hl-keyword">return</strong> preco;
}

<strong class="hl-keyword">void</strong> Motor::setPotencia(<strong class="hl-keyword">float</strong> _potencia){
  potencia=_potencia;
}

<strong class="hl-keyword">void</strong> Motor::setVelocidade(<strong class="hl-keyword">float</strong> _velocidade){
  velocidade=_velocidade;
}

<strong class="hl-keyword">float</strong> Motor::getPotencia(<strong class="hl-keyword">void</strong>){
  <strong class="hl-keyword">return</strong> potencia;
}

<strong class="hl-keyword">float</strong> Motor::getVelocidade(<strong class="hl-keyword">void</strong>){
  <strong class="hl-keyword">return</strong> velocidade;
}

<strong class="hl-keyword">int</strong> main(<strong class="hl-keyword">void</strong>){
  Motor m;
  m.setFabricante(<strong class="hl-string"><em style="color:red">"ACME"</em></strong>);
  m.setPreco(<span class="hl-number">23.45</span>);
  m.setNome(<strong class="hl-string"><em style="color:red">"Speedatron"</em></strong>);
  m.setPotencia(<span class="hl-number">130</span>);
  m.setVelocidade(<span class="hl-number">280</span>);
  cout &lt;&lt; m.getFabricante() &lt;&lt; <strong class="hl-string"><em style="color:red">"\n"</em></strong> 
       &lt;&lt; m.getPreco() &lt;&lt; <strong class="hl-string"><em style="color:red">"\n"</em></strong> 
       &lt;&lt; m.getNome() &lt;&lt; <strong class="hl-string"><em style="color:red">"\n"</em></strong> 
       &lt;&lt; m.getPotencia() &lt;&lt; <strong class="hl-string"><em style="color:red">"\n"</em></strong> 
       &lt;&lt; m.getVelocidade() &lt;&lt; <strong class="hl-string"><em style="color:red">"\n"</em></strong>;
}

	</pre>
    </div></div><br class="example-break">
    <p>O programa do <a class="xref" href="cha.heranca.html#exe.heranca-equipamento-motor" title="Exemplo 5.4. Programa equip-motor.cpp para ilustrar o uso de heran&ccedil;a.">Exemplo&nbsp;5.4</a> pode ser compilado e executado em um terminal Linux a partir das seguintes linhas de comando:</p>
    <pre class="screen">
      <code class="prompt">$</code> <span class="command"><strong>g++</strong></span> equip-motor.cpp <code class="option">-o</code> equip-motor
      <code class="prompt">$</code> <span class="command"><strong>./equip-motor</strong></span>
      <code class="computeroutput">ACME
23.45
Speedatron
130
280
      </code>
    </pre>
    <p>No processo de heran&ccedil;a &eacute; estabelecido uma rela&ccedil;&atilde;o hier&aacute;rquica entre as classes. A classe que possui as funcionalidades mais gen&eacute;ricas &eacute; geralmente chamada de <span class="emphasis"><em>classe base</em></span>, ou classe herdada, enquanto que a classe que especializa o comportamento da classe base &eacute; chamada de <span class="emphasis"><em>classe derivada</em></span>, ou classe herdeira.</p>
    <p>Compreender adequadamente a rela&ccedil;&atilde;o estabelecida entre duas classes, base e herdeira, &eacute; importante para que se possa entender como as funcionalidades de uma classe s&atilde;o absorvidas, extendidas ou redefinidas por outra.</p>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.heranca.efeitos"></a>5.1. Efeitos do processo de heran&ccedil;a</h2></div></div></div>
      
      <p>Todas as vari&aacute;veis e fun&ccedil;&otilde;es presentes na classe base s&atilde;o recebidas e podem ser usadas pelas fun&ccedil;&otilde;es de uma classe herdeira, desde que observadas algumas restri&ccedil;&otilde;es.</p>
      <p>A principal delas diz respeito aos construtores e destrutores. Esses n&atilde;o s&atilde;o herdados da classe base, de sorte que o programador precisa desenvolver seus pr&oacute;prios m&eacute;todos para a classe derivada.</p>
      <p>Outra restri&ccedil;&atilde;o &agrave; forma como &eacute; estabelecido o processo de heran&ccedil;a. Observe no exemplo <a class="xref" href="cha.heranca.html#exe.heranca-motor" title="Exemplo 5.3. Exemplo de heran&ccedil;a simples: a classe motor herda da classe equipamento.">Exemplo&nbsp;5.3</a> a palavra reservada <span class="token">public</span> que aparece na linha que cria a rela&ccedil;&atilde;o de heran&ccedil;a entre as classes <code class="classname"> Equipamento</code> e <code class="classname">Motor</code> <a class="xref" href="cha.heranca.html#co.heranca-equipamento"><span><img src="images/callouts/1.svg" alt="1" border="0"></span></a>. Este especificador de heran&ccedil;a determina que se uma fun&ccedil;&atilde;o ou vari&aacute;vel com visibilidade p&uacute;blica (declarada ap&oacute;s <span class="token">public:</span>) na classe base esta ser&aacute; vista tamb&eacute;m como p&uacute;blica na classe herdeira. Da mesma forma, uma fun&ccedil;&atilde;o ou vari&aacute;vel com visibilidade protegida (declarada ap&oacute;s o especificador <span class="token">protected:</span>) tamb&eacute;m ser&aacute; protegida na classe derivada. Em outras palavras, a heran&ccedil;a tipo <span class="emphasis"><em>public</em></span> mant&eacute;m as mesmas visibilidades para os membros p&uacute;blicos e protegidos da classe derivada.</p>
      <p>Heran&ccedil;as do tipo <span class="emphasis"><em>private</em></span> e <span class="emphasis"><em>protected</em></span> tamb&eacute;m s&atilde;o permitidas, mas elas alteram o tipo de visibilidade dos membros p&uacute;blicos e protegidos da classe base. Na heran&ccedil;a tipo <span class="emphasis"><em>private</em></span>, todos os membros <span class="emphasis"><em>public</em></span> e <span class="emphasis"><em>protected</em></span> da classe base tornam-se <span class="emphasis"><em>private</em></span> na classe derivada. Na heran&ccedil;a tipo <span class="emphasis"><em>protected</em></span>, todos os membros <span class="emphasis"><em>public</em></span> e <span class="emphasis"><em>protected</em></span> da classe base tornam-se <span class="emphasis"><em>protected</em></span> na classe derivada.</p>
      <p>As modifica&ccedil;&otilde;es sofridas pelos v&aacute;rios tipos de membros s&atilde;o sintetizadas na <a class="xref" href="cha.heranca.html#tab.heranca-especificador" title="Tabela 5.1. Efeitos do especificador de acesso no processo de heran&ccedil;a">Tabela&nbsp;5.1</a>. A primeira coluna da tabela diz respeito ao tipo de heran&ccedil;a especificada para a classe derivada a partir de sua classe base. As colunas seguintes mostram como ficar&atilde;o as visibilidades dos membros da classe derivada para os v&aacute;rios tipos de interfaces poss&iacute;veis na classe base.</p>
      <div class="table"><a name="tab.heranca-especificador"></a><p class="title"><b>Tabela 5.1. Efeitos do especificador de acesso no processo de heran&ccedil;a</b></p><div class="table-contents">
	
	<table summary="Efeitos do especificador de acesso no processo de heran&ccedil;a" width="100%" border="1"><colgroup><col align="center" class="col1" width="25%"><col align="center" class="col2" width="25%"><col align="center" class="col3" width="25%"><col align="center" class="col4" width="25%"></colgroup><thead><tr><th rowspan="2" align="center">Especificador de heran&ccedil;a</th><th colspan="3" align="center">Tipo de interface</th></tr><tr><th align="center">public</th><th align="center">private</th><th align="center">protected</th></tr></thead><tbody><tr><td align="center">public</td><td align="center">public</td><td align="center">private</td><td align="center">protected</td></tr><tr><td align="center">private</td><td align="center">private</td><td align="center">private</td><td align="center">private</td></tr><tr><td align="center">protected</td><td align="center">protected</td><td align="center">private</td><td align="center">protected</td></tr></tbody></table>
      </div></div><br class="table-break">
      <p>Embora todas essas combina&ccedil;&otilde;es sejam poss&iacute;veis, a heran&ccedil;a tipo <span class="emphasis"><em>public</em></span> &eacute; a mais comum e normalmente &eacute; a preferida nos processos de heran&ccedil;a, pois n&atilde;o modifica na classe derivada o comportamento conhecido para os membros da classe base.</p>
    </div>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.heranca.construtores.destrutores"></a>5.2. Heran&ccedil;a nos construtores e destrutores</h2></div></div></div>
      
      <p>O processo de invoca&ccedil;&atilde;o dos construtores e destrutores quando se usa heran&ccedil;a &eacute; feito de forma cuidadosa de modo que os recursos necess&aacute;rios sejam alocados e desalocados na ordem correta.</p>
      <p>A constru&ccedil;&atilde;o do objeto tem in&iacute;cio na classe base e s&oacute; ent&atilde;o segue para a classe derivada, sendo regida pelas regras:</p>
      <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
	  <p>O construtor da classe base <span class="emphasis"><em>SEMPRE</em></span> &eacute; chamado antes do construtor da classe derivada.</p>
	</li><li class="listitem">
	  <p>O construtor <span class="foreignphrase"><em class="foreignphrase">default</em></span> &eacute; chamado automaticamente na classe base</p>
	</li><li class="listitem">
	  <p>
	  Caso o construtor <span class="foreignphrase"><em class="foreignphrase">default</em></span> n&atilde;o exista ou n&atilde;o fa&ccedil;a sentido sua exist&ecirc;ncia, dever&aacute; ser especificado explicitamente o construtor da classe base que dever&aacute; ser invocado. Se o usu&aacute;rio n&atilde;o informar o construtor adequado para ser chamado e o construtor <span class="foreignphrase"><em class="foreignphrase">default</em></span> n&atilde;o existir na classe base, erros de compila&ccedil;&atilde;o dever&atilde;o surgir.</p>
	</li></ol></div>
      <p>Observe o <a class="xref" href="cha.heranca.html#exe.heranca-construtor" title="Exemplo 5.5. Construtores no processo de heran&ccedil;a">Exemplo&nbsp;5.5</a>. Ele mostra o efeito da heran&ccedil;a na chamada dos construtores durante a cria&ccedil;&atilde;o de objetos.</p>
      <div class="example"><a name="exe.heranca-construtor"></a><p class="title"><b>Exemplo 5.5. Construtores no processo de heran&ccedil;a</b></p><div class="example-contents">
	
	<pre class="programlisting">#include &lt;iostream&gt;

<strong class="hl-keyword">using</strong> <strong class="hl-keyword">namespace</strong> std;

<strong class="hl-keyword">class</strong> Base{
<strong class="hl-keyword">public</strong>:
  Base(){
    cout &lt;&lt; <strong class="hl-string"><em style="color:red">"Construtor da classe Base\n"</em></strong>;
  }
};

<strong class="hl-keyword">class</strong> Intermediaria : <strong class="hl-keyword">public</strong> Base{
<strong class="hl-keyword">public</strong>:
  Intermediaria(){
    cout &lt;&lt; <strong class="hl-string"><em style="color:red">"Construtor da classe Intermediaria\n"</em></strong>;
  }
};

<strong class="hl-keyword">class</strong> Derivada : <strong class="hl-keyword">public</strong> Intermediaria{
<strong class="hl-keyword">public</strong>:
  Derivada(){
    cout &lt;&lt; <strong class="hl-string"><em style="color:red">"Construtor da classe Derivada\n"</em></strong>;
  }
};

<strong class="hl-keyword">int</strong> main(<strong class="hl-keyword">void</strong>){
  Derivada d;
}

	  </pre>
      </div></div><br class="example-break">
      <p>O <a class="xref" href="cha.heranca.html#exe.heranca-construtor" title="Exemplo 5.5. Construtores no processo de heran&ccedil;a">Exemplo&nbsp;5.5</a>, quando executado, produz a seguinte sa&iacute;da:</p>
      <pre class="screen"><code class="computeroutput">Construtor da classe Base
      Construtor da classe Intermediaria
      Construtor da classe Derivada</code></pre>
      <p>Observe a sequ&ecirc;ncia de invoca&ccedil;&otilde;es de construtores. Primeiro s&atilde;o chamados os das superclasses e, em seguida, os das subclasses. &Eacute; importante que o processo ocorra nessa ordem, pois os recursos demandados pela classe base devem estar presentes para para s&oacute; ent&atilde;o alocar os recursos (especializados) da classe derivada.</p>
      <p>Caso o construtor <span class="foreignphrase"><em class="foreignphrase">default</em></span> n&atilde;o exista na classe base, um construtor v&aacute;lido dever&aacute; se indicado em uma lista de inicializadores que seguir&aacute; o construtor da classe derivada.</p>
      <div class="example"><a name="exe.heranca-construtor-semdefault"></a><p class="title"><b>Exemplo 5.6. Especificando os construtores das classes base na lista de iniciadores</b></p><div class="example-contents">
	
	<pre class="programlisting">#include &lt;iostream&gt;

<strong class="hl-keyword">using</strong> <strong class="hl-keyword">namespace</strong> std;

<strong class="hl-keyword">class</strong> Base{
<strong class="hl-keyword">public</strong>:
  Base(<strong class="hl-keyword">int</strong> a){
    cout &lt;&lt; <strong class="hl-string"><em style="color:red">"Construtor da classe Base: "</em></strong> &lt;&lt; a &lt;&lt; <strong class="hl-string"><em style="color:red">"\n"</em></strong>;
  }
};

<strong class="hl-keyword">class</strong> Intermediaria : <strong class="hl-keyword">public</strong> Base{
<strong class="hl-keyword">public</strong>:
  Intermediaria(<strong class="hl-keyword">int</strong> a) : Base(a-<span class="hl-number">1</span>){
    cout &lt;&lt; <strong class="hl-string"><em style="color:red">"Construtor da classe Intermediaria: "</em></strong> &lt;&lt; a &lt;&lt; <strong class="hl-string"><em style="color:red">"\n"</em></strong>;
  }
};

<strong class="hl-keyword">class</strong> Derivada : <strong class="hl-keyword">public</strong> Intermediaria{
<strong class="hl-keyword">public</strong>:
  Derivada(<strong class="hl-keyword">int</strong> a) : Intermediaria(a-<span class="hl-number">1</span>){
    cout &lt;&lt; <strong class="hl-string"><em style="color:red">"Construtor da classe Derivada: "</em></strong> &lt;&lt; a &lt;&lt; <strong class="hl-string"><em style="color:red">"\n"</em></strong>;
  }
};

<strong class="hl-keyword">int</strong> main(<strong class="hl-keyword">void</strong>){
  Derivada d(<span class="hl-number">3</span>);
}

	  </pre>
      </div></div><br class="example-break">
      <p>A lista de inicializadores aparece logo ap&oacute;s o caractere <span class="token">:</span>, onde todos os construtores das classes base poder&atilde;o (ou dever&atilde;o) ser informados. Para cada classe que n&atilde;o possuir construtor <span class="foreignphrase"><em class="foreignphrase">default</em></span> ou que se deseje informar um construtor adequado, dever&aacute; ser inclu&iacute;da uma entrada nesta lista. Na classe <code class="classname">Intermediaria</code>, seu construtor <code class="function">Intermediaria (int a) </code>foi seguido da chamada do construtor <code class="function">Base (a-1)</code>, enquanto que na classe <code class="classname">Derivada</code>, seu construtor <code class="function">Derivada(int a)</code> foi seguido da chamada do construtor <code class="function">Intermediaria(a-1)</code>.</p>
      <p>Para os destrutores, o processo de invoca&ccedil;&atilde;o ocorre na sequ&ecirc;ncia inversa ao modo como ocorre para os construtores. Agora os construtores das classes derivadas s&atilde;o invocados primeiro que os destrutores das classes base, para realizar a desaloca&ccedil;&atilde;o de recursos tamb&eacute;m na ordem inversa. Observe o funcionamento do <a class="xref" href="cha.heranca.html#exe.heranca-destrutor" title="Exemplo 5.7. Ordem de chamada dos destrutores na hierarquia de classes">Exemplo&nbsp;5.7</a></p>
      <div class="example"><a name="exe.heranca-destrutor"></a><p class="title"><b>Exemplo 5.7. Ordem de chamada dos destrutores na hierarquia de classes</b></p><div class="example-contents">
	
	<pre class="programlisting">#include &lt;iostream&gt;

<strong class="hl-keyword">using</strong> <strong class="hl-keyword">namespace</strong> std;

<strong class="hl-keyword">class</strong> Base{
<strong class="hl-keyword">public</strong>:
  ~Base(){
    cout &lt;&lt; <strong class="hl-string"><em style="color:red">"Destrutor da classe Base\n"</em></strong>;
  }
};

<strong class="hl-keyword">class</strong> Intermediaria : <strong class="hl-keyword">public</strong> Base{
<strong class="hl-keyword">public</strong>:
  ~Intermediaria(){
    cout &lt;&lt; <strong class="hl-string"><em style="color:red">"Destrutor da classe Intermediaria\n"</em></strong>;
  }
};

<strong class="hl-keyword">class</strong> Derivada : <strong class="hl-keyword">public</strong> Intermediaria{
<strong class="hl-keyword">public</strong>:
  ~Derivada(){
    cout &lt;&lt; <strong class="hl-string"><em style="color:red">"Destrutor da classe Derivada\n"</em></strong>;
  }
};

<strong class="hl-keyword">int</strong> main(<strong class="hl-keyword">void</strong>){
  Derivada d;
}

	  </pre>
      </div></div><br class="example-break">
      <p>O <a class="xref" href="cha.heranca.html#exe.heranca-destrutor" title="Exemplo 5.7. Ordem de chamada dos destrutores na hierarquia de classes">Exemplo&nbsp;5.7</a>, quando executado, produz a seguinte sa&iacute;da:</p>
      <pre class="screen"><code class="computeroutput">Destrutor da classe Derivada
      Construtor da classe Intermediaria
      Construtor da classe Base</code></pre>
    </div>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.heranca.atribuicoes"></a>5.3. Atribui&ccedil;&otilde;es de valores entre classes</h2></div></div></div>
      
      <p>Outro aspecto da heran&ccedil;a na rela&ccedil;&atilde;o entre classes diz respeito ao processo de atribui&ccedil;&atilde;o de valores entre classes criadas por heran&ccedil;a. Quando se atribui a um objeto de uma classe um outro objeto, algumas coisas devem ser levadas em considera&ccedil;&atilde;o.</p>
      <p>Uma delas &eacute; o fato de objetos de uma classe base poderem receber atribui&ccedil;&otilde;es de objetos de uma classe derivada, como mostra o seguinte exemplo:</p>
      <div class="informalexample">
	<pre class="programlisting"><strong class="hl-keyword">class</strong> Base{
<strong class="hl-keyword">protected</strong>:
  <strong class="hl-keyword">int</strong> a, b;
<strong class="hl-keyword">public</strong>:
  <strong class="hl-keyword">void</strong> foo(<strong class="hl-keyword">int</strong> x, <strong class="hl-keyword">int</strong> y){
    a = x; b = y;
  }
  <strong class="hl-keyword">int</strong> getA(<strong class="hl-keyword">void</strong>) { <strong class="hl-keyword">return</strong> a; }
  <strong class="hl-keyword">int</strong> getB(<strong class="hl-keyword">void</strong>) { <strong class="hl-keyword">return</strong> b; }
};

<strong class="hl-keyword">class</strong> Derivada : <strong class="hl-keyword">public</strong> Base{
  <strong class="hl-keyword">int</strong> c;
<strong class="hl-keyword">public</strong>:
  <strong class="hl-keyword">void</strong> bar(<strong class="hl-keyword">int</strong> z){
    c = z;
  }
};

<strong class="hl-keyword">int</strong> main(<strong class="hl-keyword">void</strong>){
  Base b;
  Derivada d;
  b = d;
  d = b; <em class="hl-comment" style="color: silver">// Erro! "d" possui parte indefinida.</em>
}

	  </pre>
      </div>
      <p>Quando a atribui&ccedil;&atilde;o <span class="emphasis"><em>b = d</em></span> &eacute; realizada, o processo de c&oacute;pia descarta a parte especializada do objeto <code class="varname">d</code>, fazendo a c&oacute;pia das vari&aacute;veis, membro a membro, no objeto <code class="varname">b</code> apenas da parte referente &agrave; classe <code class="classname">Base</code>. J&aacute; o processo inverso n&atilde;o &eacute; permitido. Quando uma atribui&ccedil;&atilde;o do tipo <span class="emphasis"><em>d = b</em></span> &eacute; realizada, parte do objeto <code class="varname">d</code> &eacute; indefinida. Sendo assim, um erro de compila&ccedil;&atilde;o &eacute; gerado informando o problema.</p>
      <p>Caso atribui&ccedil;&atilde;o de uma classe base para uma classe derivada seja necess&aacute;ria, tal comportamento pode ser definido realizando sobrecarga de um operador de atribui&ccedil;&atilde;o (operador <span class="token">=</span>).</p>
      <p>Observe o exemplo a seguir:</p>
      <div class="informalexample">
	<pre class="programlisting"><strong class="hl-keyword">class</strong> Base{
  <strong class="hl-keyword">int</strong> a, b;
<strong class="hl-keyword">public</strong>:
  <strong class="hl-keyword">void</strong> foo(<strong class="hl-keyword">int</strong> x, <strong class="hl-keyword">int</strong> y){
    a = x; b = y;
  }
};

<strong class="hl-keyword">class</strong> Derivada : <strong class="hl-keyword">public</strong> Base{
  <strong class="hl-keyword">int</strong> c;
<strong class="hl-keyword">public</strong>:
  Derivada&amp; <strong class="hl-keyword">operator</strong>=(Base &amp;x){
    a = x.getA(); 
    b = x.getB();
    c = <span class="hl-number">0</span>;
  }
  <strong class="hl-keyword">void</strong> bar(<strong class="hl-keyword">int</strong> z){
    c = z;
  }
};

<strong class="hl-keyword">int</strong> main(<strong class="hl-keyword">void</strong>){
  Base b;
  Derivada d;
  b = d;
  d = b; <em class="hl-comment" style="color: silver">//OK! Parte indefinida de "d" agora &#65533; tratada</em>
}

	  </pre>
      </div>
      <p>A sobrecarga do operador de atribui&ccedil;&atilde;o orienta a classe como tratar adequadamente membros de sua classe base destinados &agrave; c&oacute;pia. Neste exemplo, o estado do objeto da classe <code class="classname">Derivada</code> &eacute; estabelecido pela observa&ccedil;&atilde;o cuidadosa dos membros da classe <code class="classname">Base</code>. </p>
    </div>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.heranca.exercicios"></a>5.4. Exerc&iacute;cios de fixa&ccedil;&atilde;o</h2></div></div></div>
      
      <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
	  <p>Considere a classe <code class="classname">Veiculo</code> mostrada na <a class="xref" href="cha.classes.objetos.html#sec.classes.objetos.exercicios" title="3.4. Exerc&iacute;cios de fixa&ccedil;&atilde;o">Se&ccedil;&atilde;o&nbsp;3.4</a>. Com base nessa classe, defina duas classes herdeiras denominadas <code class="classname">Carro</code> e <code class="classname">Caminhao</code> com as seguintes caracter&iacute;sticas:</p>
	  
	  <div class="segmentedlist"><table border="0"><thead><tr class="segtitle"><th>Fun&ccedil;&atilde;o (classe Carro) </th><th>Descri&ccedil;&atilde;o</th></tr></thead><tbody><tr class="seglistitem">
	      <td class="seg">Construtor</td>
	      <td class="seg">Inicializado com o n&uacute;mero de passageiros, n&uacute;mero de rodas e carga m&aacute;xima de passageiros suportada</td>
	    </tr><tr class="seglistitem">
	      <td class="seg"><code class="function">int getPassageiros()</code></td>
	      <td class="seg">Retorna o n&uacute;mero atual de passageiros no ve&iacute;culo.</td>
	    </tr><tr class="seglistitem">
	      <td class="seg"><code class="function">setPassageiros(int)</code></td>
	      <td class="seg">Define o n&uacute;mero atual de passageiros no ve&iacute;culo.</td>
	    </tr></tbody></table></div>
	  
	  <div class="segmentedlist"><table border="0"><thead><tr class="segtitle"><th>Fun&ccedil;&atilde;o (classe Caminh&atilde;o) </th><th>Descri&ccedil;&atilde;o</th></tr></thead><tbody><tr class="seglistitem">
	      <td class="seg">Construtor</td>
	      <td class="seg">Inicializado com o n&uacute;mero de n&uacute;mero de rodas e carga m&aacute;xima suportada.</td>
	    </tr><tr class="seglistitem">
	      <td class="seg"><code class="function">void setCarga(float)</code></td>
	      <td class="seg">Define a carga transportada.</td>
	    </tr><tr class="seglistitem">
	      <td class="seg"><code class="function">float eficiencia()</code></td>
	      <td class="seg">Retorna a rela&ccedil;&atilde;o entre a carga suportada e massa total do ve&iacute;culo carregado.</td>
	    </tr><tr class="seglistitem">
	      <td class="seg"><code class="function">float cargaPorRoda()</code></td>
	      <td class="seg">Retorna a massa suportada por cada uma das rodas do caminh&atilde;o, supondo distribui&ccedil;&atilde;o igual de for&ccedil;a por todo o ve&iacute;culo.</td>
	    </tr></tbody></table></div>
	</li><li class="listitem">
	  <p>Utilizando a implementa&ccedil;&atilde;o da classe <code class="classname">Poligono</code> desenvolvida na <a class="xref" href="cha.classes.objetos.html#sec.classes.objetos.exercicios" title="3.4. Exerc&iacute;cios de fixa&ccedil;&atilde;o">Se&ccedil;&atilde;o&nbsp;3.4</a>, crie uma subclasse <code class="classname">Retangulo</code> derivada da superclasse <code class="classname">Poligono</code>. O construtor da nova classe dever&aacute; ser da forma <code class="function">Retangulo(int x, int y, int largura, int altura)</code>, denotando a posi&ccedil;&atilde;o <span class="inlinemediaobject"><span class="phrase">$(x,y)$</span></span> do ret&acirc;ngulo e suas dimens&otilde;es - altura e largura. Crie um pequeno exemplo para testar sua implementa&ccedil;&atilde;o da classe <code class="classname">Retangulo</code>. No exemplo, defina um novo ret&acirc;ngulo na posi&ccedil;&atilde;o <span class="inlinemediaobject"><span class="phrase">$(x,y)=(0,0)$</span></span> e calcule a sua &aacute;rea usando a fun&ccedil;&atilde;o j&aacute; implementada na classe <code class="classname">Poligono</code>. Mude a posi&ccedil;&atilde;o do ret&acirc;ngulo usando a fun&ccedil;&atilde;o <code class="function">move(double,double)</code> para <span class="inlinemediaobject"><span class="phrase">$(x,y)=(-3,4)$</span></span> e recalcule a &aacute;rea do ret&acirc;ngulo.
	  </p>
	</li><li class="listitem">
	  <p>No seguinte trecho de c&oacute;digo, identifique, se existirem, as linhas que poder&atilde;o apresentar problemas de compila&ccedil;&atilde;o e explique o(s) motivo(s) do(s) problema(s) que voc&ecirc; identificou.</p>
	  <pre class="programlisting">#include &lt;iostream&gt;
<strong class="hl-keyword">class</strong> A{
  <strong class="hl-keyword">int</strong> a1;
<strong class="hl-keyword">public</strong>:
  <strong class="hl-keyword">int</strong> a2;
};
<strong class="hl-keyword">class</strong> B : <strong class="hl-keyword">public</strong> A{
  <strong class="hl-keyword">int</strong> b1;
<strong class="hl-keyword">public</strong>:
  <strong class="hl-keyword">int</strong> b2;
  B(){
    b1=a1;
    b2=a2;
  }
};
<strong class="hl-keyword">int</strong> main(<strong class="hl-keyword">void</strong>){
  <strong class="hl-keyword">int</strong> c;
  B b;
  c = b.b1;
  c = b.b2;
}</pre>
	</li></ol></div>
    </div>
  </div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="navfooter"><hr><table width="100%" class="navfoot" summary="Navigation footer"><tr><th width="40%" align="left"><a accesskey="p" class="navfoot" href="cha.construtores.destrutores.html">&laquo;&nbsp;Cap&iacute;tulo 4. Construtores e destrutores</a>&nbsp;</th><th width="20%" align="center"><a accesskey="h" class="navfoot" href="index.html">&#8657;Principal&#8657;</a></th><th width="40%" align="right">&nbsp;<a accesskey="n" class="navfoot" href="cha.sobrecarga.html">Cap&iacute;tulo 6. Sobrecarga de operadores&nbsp;&raquo;</a></th></tr></table></div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="navheader"><hr><table class="navfoot" width="100%"><tr><td align="center"><p class="copyright">Copyright &copy; 2012 Agostinho Brito</p></td></tr></table></div></body></html>