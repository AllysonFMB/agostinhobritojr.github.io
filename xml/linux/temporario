<!--  
<chapter>
    <title>Arquivos e Diretórios no Unix</title>

<sect1>
    <title>Introdução</title>
    
    Neste capítulo, serão discutidas as tarefas básicas de manipulação de diretórios e arquivos no Unix.
    
<sect1>
    <title>Manipulação de diretórios</title>
<sect2>
	<title>Navegando entre diretórios</title>

    Do mesmo modo que em outros sistemas operacionais, os diretórios no Unix são organizados numa estrutura de árvore. 

    A mudança entre os diretórios é feita através do comando <emphasis>cd</emphasis> ({\tt change dir}), cuja sintaxe é \\

    <emphasis>cd [nome_do_diretório]</emphasis> \\

    O exemplo abaixo mostra o usuário aluno se deslocando para o diretório {\tt /usr/bin}.

\begin{quote}
\begin{verbatim}
maquina:~$ cd documentos
maquina:~/documentos$ cd 
maquina:~$ 
\end{verbatim}
\end{quote}

    Quando o comando é executado sem argumento, o sistema desloca o usuário para o seu <foreignphrase>home_dir</foreignphrase>. Um argumento especial que pode ser passado ao comando <emphasis>cd</emphasis> é {\tt '~usuário'}, possibilitando que o deslocamento seja feito para o <foreignphrase>home_dir</foreignphrase> do usuário especificado.

    A referência a todos os diretórios é absoluta na raiz da árvore de diretórios, como em {\tt /home/aluno}. A referência relativa pode ser feita em relação a dois arquivos existentes dentro de cada diretório do sistema, que são:

\begin{description}
\item [../] referência ao diretório pai do diretório corrente.
\item [./] referência ao diretório corrente.
\end{description}

    A identificação do diretório corrente é feita através do comando <emphasis>pwd</emphasis> ({\em present work directory}), cuja sintaxe é mostrada no exemplo a seguir.

\begin{quote}
\begin{verbatim}
maquina:~$ pwd
/home/aluno 
maquina:~$
\end{verbatim}
\end{quote}

    A visualização do conteúdo de um diretório é feita com o comando <emphasis>ls</emphasis>, de sintaxe 

\begin{quote}
<emphasis>ls [opções][arquivo1 [arquivo2]...]</emphasis>
\end{quote}

\begin{quote}
\begin{verbatim}
maquina:~$ ls
documentos/      exemplo2.txt     faq.txt
exemplo1.txt     financas/        linux1.gif
maquina:~$ 
\end{verbatim}
\end{quote}

    Como pôde ser notado, o comando <emphasis>ls</emphasis> quando executado sem opções não mostra muita informação sobre os arquivos do diretório, apenas os seus nomes. As opções mais comuns que podem ser utilizadas para enriquecer a saída do comando <emphasis>ls</emphasis> são:

\begin{description}
\item [-l] listagem longa
\item [-a] listagem de todos os arquivos
\end{description}

\begin{quote}
\begin{verbatim}
maquina:~$ ls -la 
total 121
drwxr-xr-x   4 aluno    users        1024 Mar 31 13:27 ./
drwxr-xr-x   7 root     root         1024 Mar 31 12:53 ../
-rw-r--r--   1 aluno    users          26 Mar 31 13:08 .bash_history
-rw-r--r--   1 aluno    users          34 Nov 23  1993 .less
-rw-r--r--   1 aluno    users         114 Nov 23  1993 .lessrc
drwxr-xr-x   2 aluno    users        1024 Mar 31 13:15 documentos/
-rw-r--r--   1 aluno    users          43 Mar 31 12:58 exemplo1.txt
-rw-r--r--   1 aluno    users          41 Mar 31 12:58 exemplo2.txt
drwxr-xr-x   2 aluno    users        1024 Mar 31 13:28 financas/
-rw-r--r--   1 aluno    users      108111 Mar 31 13:00 faq.txt
-rw-r--r--   1 aluno    users        5041 Mar 31 12:58 linux1.gif
maquina:~$ 
\end{verbatim}
\end{quote}

<sect2>
	<title>Permissões de arquivos</title>

    Como pôde ser visto no exemplo anteiror, a listagem longa mostra uma série de atributos relacionados a cada arquivo existente em um diretório. Entre estes atributos, a primeira seqüência de caracteres é dividida em três subseqüências que definem as permissões dadas pelo usuário aos seus arquivos arquivo, de acordo com a classificação de cada usuário. As atribuições de cada subseqüência são mostradas na Figura \ref{fig:perm}.

\begin{figure}[htbp]
    \begin{center}
        \fbox{\includegraphics[width=\linewidth]{permissoes.pdf}}
    \end{center}
    \caption{Atributos de permissão de arquivo}
    \label{fig:perm}
\end{figure}

    A mudança das permissões de uma arquivo é feita com o comando <emphasis>chmod</emphasis>, de sintaxe

<emphasis>chmod modo arquivo</emphasis>

    O <emphasis>modo</emphasis> define as permissões do arquivo, sendo os mais comuns são formados por uma combinação das letras 'ugoa', referentes os usuários, e 'rwx', referentes ao tipo de permissão, ligadas pelos caracteres '+' ou '-'. As permissões do usuário são 'u', para o proprietário do arquivo, 'g', para o grupo a que pertence, 'o', para outros usuários e 'a'(all), para todo os usuários. Os tipos de permissão são 'r', para leitura, 'w', para escrita, e 'x', para execução.

\begin{quote}
\begin{verbatim}
maquina:~$ chmod [go]-[rw] exemplo1.txt
maquina:~$ 
\end{verbatim}
\end{quote}

<sect2>
	<title>Criando e destruindo diretórios</title>

    Os comandos para criar e apagar diretórios no Unix são <emphasis>mkdir</emphasis> e <emphasis>rmdir</emphasis>, respectivamente. As sintaxes destes comandos são:

\begin{description}
\item<emphasis>mkdir diretório [...]</emphasis>
\item<emphasis>rmdir diretório [...]</emphasis>
\end{description}

\begin{enumerate}
\item criando o diretório {\tt documentos}:

\begin{quote}
\begin{verbatim}
maquina:~$ pwd
/home/aluno
maquina:~$ mkdir curso
maquina:~$ cd curso
maquina:~/curso$ pwd
/home/aluno/curso
maquina:~/curso$
\end{verbatim}
\end{quote}

\item removendo o diretório {\tt curso}:

\begin{quote}
\begin{verbatim}
maquina:~$ pwd
/home/aluno/curso
maquina:~$ cd ..
maquina:~$ rmdir curso
maquina:~$ cd curso
bash: curso: No such file or directory
maquina:~$
\end{verbatim}
\end{quote}

\end{enumerate}

{\flushleft Lembrete: para que um diretório possa ser removido, é necessário que o mesmo esteja vazio.}

<sect1>
    <title>Manipulação de arquivos</title>
<sect2>
	<title>Criando e listando arquivos</title>

    Diversas são as maneiras de se criar um arquivo no Unix, seja através de um editor de textos, seja pelo produto da compilação de um programa ou por quaisquer outras alternativas. A mais simples delas é utilizando o comando <emphasis>touch</emphasis>.
    
    O <emphasis>touch</emphasis> é geralmente utilizado para atualizar a hora e a data de um determinado arquivo e. Caso este arquivo não exista, ele será criado pelo <emphasis>touch</emphasis>, porém sem conteúdo algum. A sua sintaxe do comando touch é: \\

<emphasis>touch arquivo</emphasis> 

\begin{quote}
\begin{verbatim}
maquina:~$ ls
documentos/      exemplo2.txt     faq.txt  mail/
exemplo1.txt     financas/        linux1.gif
maquina:~$ touch teste.txt
maquina:~$ ls
documentos/      exemplo2.txt     faq.txt  mail/
exemplo1.txt     financas/        linux1.gif       teste.txt
maquina:~$
\end{verbatim}
\end{quote}

    Para visualizaçao do conteúdo de um arquivo pode ser feita de diversas formas, sendo a mais simples através do comando <emphasis>cat</emphasis>, como exemplificado a seguir.

\begin{quote}
\begin{verbatim}
maquina:~$ cat exemplo1.txt
exemplo de arquivo no linux: exemplo1.txt 
maquina:~$ 
\end{verbatim}
\end{quote}

    Se um arquivo for muito grande, comando <emphasis>cat</emphasis> não conseguirá mostrar o seu conteúdo inteiro na tela, caso o número de linhas do linhas do console não seja suficiente. Para contornar esta situação, o comando <emphasis>more</emphasis> pode ser utilizado, pois além de exibir o conteúdo do arquivo, realiza uma parada cada vez que uma tela é preenchida.


<sect2>
	<title>Copiando, movendo e removendo arquivos</title>

    O comando <emphasis>cp</emphasis> permite ao usuário realizar cópias de arquivos ou diretórios. A sintaxe do comando <emphasis>cp</emphasis> é: \\

<emphasis>cp [-r] fonte destino</emphasis>

\begin{quote}
\begin{verbatim}
maquina:~/financas$ ls
balanco.txt
maquina:~/financas$ cp balanco.txt balanco.copia
maquina:~/financas$ ls
balanco.txt   balanco.copia
maquina:~/financas$ 
\end{verbatim}
\end{quote}

    Quando utilizado com a opção {\tt -r}, o comando <emphasis>cp</emphasis> realiza a cópia recursiva de diretórios é realizada, semelhante ao <emphasis>xcopy</emphasis> do MS-DOS.

    Muitas vezes, ao invés de copiar um arquivo para outro lugar, é necessário renomeá-lo ou movê-lo na árvore de diretórios. Ambas estas tarefas são executadas através do comando <emphasis>mv</emphasis>, que faz a mudança de nome dos arquivos. Em Unix, mover um arquivo (inclusive diretórios) de um lugar para outro significa apenas alterar o seu nome. A sintaxe do comando <emphasis>mv</emphasis> é: \\

    <emphasis>mv [opções] fonte... destino</emphasis>

\begin{quote}
\begin{verbatim}
maquina:~$ ls
documentos/      exemplo2.txt     faq.txt  mail/
exemplo1.txt     financas/        linux1.gif       teste.txt
maquina:~$ mv teste.txt financas
maquina:~$ cd financas
maquina:~$ ls
balanco.txt   balanco.copia    teste.txt
maquina:~$ mv teste.txt teste.move
maquina:~$ ls
balanco.txt   balanco.copia    teste.move
maquina:~$
\end{verbatim}
\end{quote}

    A remoção de arquivos, por sua vez, é feita através do comando <emphasis>rm</emphasis>, como mostra o exemplo a seguir, onde o arquivo {\tt exemplo2.txt} é apagado.

\begin{quote}
\begin{verbatim}
maquina:~$ ls
documentos/      exemplo2.txt     faq.txt
exemplo1.txt     financas/        linux1.gif
maquina:~$ rm exemplo2.txt
maquina:~$ ls
documentos/      financas/        linux1.gif
exemplo1.txt     faq.txt
maquina:~$ 
\end{verbatim}
\end{quote}


    Deve ser tomado muito cuidado no do comando <emphasis>rm</emphasis>, pois uma vez excluído um arquivo, o mesmo não poderá ser recuperado (ao contrário do sistema MS-DOS). Um comando da forma {\tt rm *} (utilizando o coringa ``*'') destrói todos os arquivos do diretório corrente. Por isto, é muitas vezes recomendável utilizar o comando <emphasis>rm</emphasis> com a opção {\tt '-i'}, que força o usuário a confirmar cada remoção de arquivo.

    O comando <emphasis>rm</emphasis> também pode ser utilizado de forma semelhante ao comando <emphasis>deltree</emphasis> do MS-DOS, bastando para isto executá-lo com a opção {\tt '-r'}. Com isto, todos os arquivos contidos em uma árvore de diretório serão apagados, começando dos mais profundos até apagar o próprio diretório.

\subsection {Procurando coisas no Unix}

    Eventualmente é necessário procurar alguma informação dentro de um arquivo ou até mesmo, saber onde um determinado arquivo se encontra dentro da árvore de diretórios.

    Um dos comandos mais úteis dentro do Unix é o <emphasis>grep</emphasis>, cuja utilidade é procurar caracteres dentro de um arquivo de texto. Sempre que o caracter passado como argumento para <foreignphrase>matching</foreignphrase> é encontrado em uma linha do arquivo, a mesma é enviada para a saída do programa. A sintaxe do comando <emphasis>grep</emphasis> é da forma: \\

<emphasis>grep cadeia_de_caracteres [arquivos]</emphasis> \\

{\flushleft e} a maneira mais simples de utilizar o <emphasis>grep</emphasis> é como mostra o exemplo a seguir.


{\flushleft Exemplo de utilização do comando <emphasis>grep</emphasis>:}
\begin{quote}
\begin{verbatim}
maquina:~/documentos$ cat teste.txt
Exemplo de um arquivo em Linux
que mostra a utilidade do
programa grep.
maquina:~/documentos$ grep utilidade teste.txt
que mostra a utilidade do
maquina:~/documentos$ 
\end{verbatim}
\end{quote}


    Outro comando bastante útil é o <emphasis>find</emphasis>. Ele funciona procurando recursivamente um arquivo dentro de um diretório, obedecendo um critério de busca. Caso o arquivo seja encontrado, uma ação definida pelo usuário é executada. Sua sintaxe é: \\

<emphasis>find diretório critério_de_busca ação</emphasis>. \\

    Exemplo de utilização do comando <emphasis>find</emphasis>.

\begin{quote}
\begin{verbatim}
maquina:~$ find /home -name balanco.txt -print
/home/aluno/financas/balanco.txt
maquina:~$
\end{verbatim}
\end{quote}

    Neste exemplo, o diretório inicial de busca foi {\tt /home}, o critério de procura foi {\tt -name balanco.txt} e a ação {\tt -print}, indicando que nome absoluto do arquivo deveria ser mostrado quando o mesmo fosse encontrado.

<sect2>
	<title>Ordenando o conteúdo de um arquivo</title>

    O comando <emphasis>sort</emphasis> possibilita que as linha de um arquivo possam ser ordenadas de acordo com um conjunto de opções indicadas. Sua sintaxe é dada por:
\begin{quote}
    <emphasis>sort [-dfn] [arquivo1 [...]]</emphasis>
\end{quote}     
{\flushleft onde:}
\begin{description}
\item [{\tt d}] indica que apenas letras e dígitos importam na ordenação;
\item [{\tt f}] ignora a diferença entre maiúsculas e minúsculas; 
\item [{\tt n}] faz a ordenação numérica do arquivo.
\end{description}

{\flushleft Exemplo de uso do comando <emphasis>sort</emphasis>:}
\begin{quote}
\begin{verbatim}
maquina:~$ 
maquina:~$ cat ordena.txt 
0.001 primeiro 
23.42 segundo 
2.342 terceiro 
4.03  quarto 
maquina:~$ sort ordena.txt 
0.001 primeiro 
2.342 terceiro 
23.42 segundo 
4.03  quarto 
maquina:~$ sort -n ordena.txt 
0.001 primeiro 
2.342 terceiro 
4.03  quarto 
23.42 segundo 
maquina:~$ 
\end{verbatim}
\end{quote}


<sect2>
	<title><emphasis><foreignphrase>Links</foreignphrase></title></emphasis>
    
    O sistema de arquivos do Unix, implementa o conceito de <foreignphrase>link</foreignphrase>. No Unix, criar um <foreignphrase>link</foreignphrase> significa apenas em adicionar um entrada na tabela de diretórios que aponta para uma área no disco rígido. 

    Existem dois tipos de links no Unix: o físico (<foreignphrase>hard link</foreignphrase>) e o simbólico (<foreignphrase>symbolic link</foreignphrase>).

     Cada vez que um <foreignphrase>hard link</foreignphrase> é criado, o contador com número de pontos de link que apontam para a relativa área de disco é incrementado. Quando um <foreignphrase>hard link</foreignphrase> é destruído (por exemplo, durante a remoção de um arquivo), o contador para a área de disco correspondente ao mesmo é decrementada e, quando o mesmo chega a zero, o <foreignphrase>kernel</foreignphrase> desaloca a área de disco para ser utilizada para outros fins. <foreignphrase>Hard links</foreignphrase> não podem apontar para diretórios ou arquivos inexistentes no sistema.

    O <foreignphrase>symbolic link</foreignphrase>, por sua vez, é um arquivo que contém o nome de um arquivo no seu corpo. Cada vez que o kernel encontra um <foreignphrase>symbolic link</foreignphrase>, ele substitui o nome do link pelo seu conteúdo e continua a interpretação do arquivo, até encontrar um <foreignphrase>hard link</foreignphrase>. <foreignphrase>Symbolic links</foreignphrase> podem apontar para quaisquer tipos de arquivos, inclusive inexistentes.

    <foreignphrase>Links</foreignphrase> podem ser criados no Unix através do comando <emphasis>ln</emphasis>, cuja sintaxe é:

<emphasis>ln [opções] fonte [destino]</emphasis>
    
{{\flushleft Exemplos} de criação de <foreignphrase>hard link</foreignphrase> e <foreignphrase>symbolic link</foreignphrase>:


{\flushleft <foreignphrase>Hard link:</foreignphrase>}

\begin{quote}
\begin{verbatim}
maquina:~$ ls -la
maquina:~/financas$ ls -la
total 3
drwxr-xr-x   2 aluno     users        1024 Feb  6 06:31 ./
drwxr-xr-x   4 aluno     users        1024 Feb  5 13:53 ../
-rw-r--r--   1 aluno     users          20 Feb  5 14:52 balanco.txt
maquina:~/financas$ ln balanco.txt hard
maquina:~/financas$ ls -la
total 4
drwxr-xr-x   2 aluno     users        1024 Feb  6 06:32 ./
drwxr-xr-x   4 aluno     users        1024 Feb  5 13:53 ../
-rw-r--r--   2 aluno     users          20 Feb  5 14:52 balanco.txt
-rw-r--r--   2 aluno     users          20 Feb  5 14:52 hard
maquina:~/financas$
\end{verbatim}
\end{quote}


{\flushleft <foreignphrase>Symbolic link:</foreignphrase>}
\begin{quote}
\begin{verbatim}
maquina:~/financas$ ls -la
total 4
drwxr-xr-x   2 aluno     user       1024 Feb  6 06:32 ./
drwxr-xr-x   3 aluno     users      1024 Feb  5 13:53 ../
-rw-r--r--   2 aluno     users        20 Feb  5 14:52 balanco.txt
-rw-r--r--   2 aluno     users        20 Feb  5 14:52 hard
maquina:~/financas$ ln -s balanco.txt soft
maquina:~/financas$ ls -la
drwxr-xr-x   2 aluno     users      1024 Feb  6 06:40 ./
drwxr-xr-x   3 aluno     users      1024 Feb  5 13:53 ../
-rw-r--r--   2 aluno     users        20 Feb  5 14:52 balanco.txt
-rw-r--r--   2 aluno     users        20 Feb  5 14:52 hard
lrwxrwxrwx   1 aluno     users         7 Feb  6 06:40 soft -> balanco.txt
maquina:~/financas$ 
\end{verbatim}
\end{quote}


    Como pode ser visto, o <foreignphrase>hard link</foreignphrase> de nome {\tt hard} é apenas mais um apontador para a área de disco previamente apontada por {\tt balanco.txt}. Caso a entrada {\tt balanco.txt} seja removida da tabela de diretório, o conteúdo do arquivo para onde tal entrada apontava ainda continuará existindo, visto que a entrada {\tt hard} ainda continua apontando para lá.

<sect2>
	<title>Imprimindo arquivos</title>

    Os serviços de impressão podem ser utilizados através do comando <emphasis>lpr</emphasis>. Ao chamar este comando, um serviço de impressão dos arquivos especificados é iniciado.
    
    A sintaxe do comando <emphasis>lpr</emphasis> é:

\begin{quote}
<emphasis>lpr [-Pprinter] [-\$num] [-C class] [-J job] [-T title] [-U user] [-i[numcols]] [-1234 font] [-wnum] [-cdfghlnmprstv] [name ...]</emphasis>
\end{quote}

    As opções mais utilizadas deste comando são:

\begin{description}
\item[-P] identifica a impressora que imprimirá o arquivo.
\item[-\$num] define o número de cópias que deverão ser impressas.
\end{description}

    Os dois exemplos a seguir ilustram o uso do comando <emphasis>lpr</emphasis>.

\begin{quote}
\begin{verbatim}
maquina:~/financas$ lpr -Plaser teste.ps
maquina:~/financas$ lpr -$3 cap1.tex
\end{verbatim}
\end{quote}

    No primeiro caso, o arquivo {\tt teste.ps} foi enviado para a fila de impressão da impressora de nome {\tt laser}, enquanto que no segundo são impressas três cópias do arquivo {\tt cap1.tex} para a impressora default do sistema.

<sect2>
	<title>Arquivando e compactando arquivos</title>
    
    Memórias de massa são dispositivos utilizados em praticamente toda máquina que comporta um sistema operacional. Muitas vezes, entretanto, devido às limitações do meio de armazenamento, arquivos muito grandes não podem ser escritos neste meio, como no caso de discos flexíveis de 3,5''. Neste contexto, os chamados {\em compactadores de arquivos} tornam-se bons aliados na redução do tamanho de arquivos extensos.

    Além disso, é freqüentemente necessário realizar tranferências de dados entre duas estações de trabalho ou realizar <foreignphrase>backups</foreignphrase> dos conjuntos de arquivos das máquinas de um determinado sistema.  

    Duas ferramentas bastante úteis no Unix e que atendem a estas necessidades são os programas <emphasis>tar</emphasis> e <emphasis>gzip</emphasis>.

\subsubsection{O comando tar}

    O <emphasis>tar</emphasis> funciona como um arquivador, tranferindo conjuntos de arquivos para um determinado arquivo de destino, seja este último um arquivo comum ou um <foreignphrase>driver</foreignphrase> de um periférico (disco flexível, fita magnética etc).

{\flushleft Sintaxe do comando <emphasis>tar</emphasis>:}

\begin{quote}
<emphasis>tar [opções] arquivo1 [arquivo2[...]]</emphasis>
\end{quote}

{\flushleft onde} <emphasis>[opções]</emphasis> é uma lista de opções para o <emphasis>tar</emphasis>, e <emphasis>arquivo1 [arquivo2[...]]</emphasis> são os arquivos a serem manipulados no arquivamento.


{\flushleft Exemplo de uso do comando <emphasis>tar</emphasis>:}
\begin{quote}
\begin{verbatim}
maquina:~$ tar cvf backup.tar .
./
.less
.lessrc
exemplo1.txt
tar: backup.tar is the archive; not dumped
linux1.gif
.bash_history
faq.txt
documentos/
documentos/teste.txt
financas/
financas/balanco.txt
financas/hard
financas/soft
maquina:~$
\end{verbatim}
\end{quote}
    
    Neste exemplo, os arquivos existentes no diretório {\tt /home/aluno/figs} são arquivados no arquivo {\tt backup.tar}. Como pode ser observados, três argumentos são passados ao comando <emphasis>tar</emphasis>. O primeiro deles é <emphasis>cvf</emphasis>. O ``c'' indica que o usuário deseja criar um novo arquivo. O ``v'' sinaliza o modo <foreignphrase>``verbose''</foreignphrase>, que mostra na tela os nomes dos arquivos enquanto são arquivados. O ``f'' indica que o argumento segundo argumento, <emphasis>backup.tar</emphasis>, é o nome do destino a ser criado. O último argumento, por sua vez, é o diretório que se deseja arquivar.

    Caso o usuário deseje extrair o conteúdo do arquivo {\tt backup.tar}, basta executar o comando {\tt tar xvf backup.tar} que os arquivos ali armazenados serão extraídos para o diretório corrente. No exemplo a seguir, o conteúdo do arquivo {\tt backup.tar} é extraído no diretório backup.


{\flushleft Exemplo de uso do comando <emphasis>tar</emphasis>:}
\begin{quote}
\begin{verbatim}
maquina:~$ mkdir backup
maquina:~$ cp backup.tar backup
maquina:~$ rm backup.tar
maquina:~$ cd backup
maquina:~/backup$ ls -l
total 131
-rw-r--r--   1 aluno    users      133120 Mar 31 14:08 backup.tar
maquina:~/backup$ tar xvf backup.tar
./
.less
.lessrc
exemplo1.txt
linux1.gif
.bash_history
faq.txt
documentos/
documentos/teste.txt
financas/
financas/balanco.txt
financas/hard
financas/soft
maquina:~/backup$ ls -la
total 251
drwxr-xr-x   4 aluno    users        1024 Mar 31 14:05 ./
drwxr-xr-x   5 aluno    users        1024 Mar 31 14:12 ../
-rw-r--r--   1 aluno    users          26 Mar 31 13:08 .bash_history
-rw-r--r--   1 aluno    users          34 Nov 23  1993 .less
-rw-r--r--   1 aluno    users         114 Nov 23  1993 .lessrc
-rw-r--r--   1 aluno    users      133120 Mar 31 14:12 backup.tar
drwxr-xr-x   2 aluno    users        1024 Mar 31 13:43 documentos/
-rw-r--r--   1 aluno    users          43 Mar 31 12:58 exemplo1.txt
drwxr-xr-x   2 aluno    users        1024 Mar 31 13:58 financas/
-rw-r--r--   1 aluno    users      108111 Mar 31 13:00 faq.txt
-rw-r--r--   1 aluno    users        5041 Mar 31 12:58 linux1.gif
maquina:~/backup$ 
\end{verbatim}
\end{quote}
    
    O comando <emphasis>tar</emphasis> também pode ser utilizado para enviar o arquivo {\tt backup.tar} para um periférico do sistema, tal como uma unidade de disco flexível de 3,5''. Neste caso, se o usuário executar o comando

\begin{quote}
\begin{verbatim}
maquina:~$ tar cvf /dev/fd0 backup.tar
\end{verbatim}
\end{quote}


{\flushleft o} arquivo {\tt backup.tar} será enviado para o drive A: da máquina. O procedimento para enviar arquivos para outros periféricos também é semelhante, bastando apenas utilizar o nome correto do driver do dispositivo.

\subsubsection{O comando gzip}

    Apesar de sua versatilidade, o comando <emphasis>tar</emphasis> não realiza a compressão dos arquivos durante o arquivamento. Assim, dois arquivos de 500kb cada um ocuparão um espaco em disco de 1Mb após o arquivamento.

    Entretanto, o comando <emphasis>gzip</emphasis> pode ser utilizado como uma ferramenta de compressão de arquivos no Unix. Seu uso é simples, como mostra a sintaxe a seguir:

<emphasis>gzip [opções] [-S suffix] [arquivo1 [...]</emphasis>


{\flushleft Exemplo de utilização do comando <emphasis>gzip</emphasis>:}
\begin{quote}
\begin{verbatim}
maquina:~$ gzip backup.tar
maquina:~$ gzip -d backup.tar.gz
\end{verbatim}
\end{quote}

    No primeiro caso, o comando <emphasis>gzip</emphasis> compactou o arquivo {\tt backup.tar}, criando o arquivo <emphasis>backup.tar.gz</emphasis> (``.gz'' é a extensão <foreignphrase>default</foreignphrase> do gzip). No segundo caso, o arquivo <emphasis>backup.tar.gz</emphasis> foi descompactado utilizando a opção ``-d''. O usuário também pode utilizar o comando <emphasis>gunzip</emphasis>\footnote{Equivalente à opção ``-d''.} para descompactar um arquivo.

    Para arquivar e compactar um conjunto de arquivos, o usuário pode utilizar o comando <emphasis>tar</emphasis> com a opção ``z'' incluída, como mostra o exemplo a seguir.

\begin{quote}
\begin{verbatim}
maquina:~$ tar czvf backup.tar.gz /home/aluno/financas
\end{verbatim}
\end{quote}

    Assim o conteúdo do diretório {\tt /home/aluno/financas} será arquivado e automaticamente compactado no arquivo {\tt backup.tar.gz}.

<sect2>
	<title>Utilizando o conjunto de ferramentas <emphasis>mtools</title></emphasis>

    No Unix existe um conjunto de ferramentas que permitem ao usuário manipular arquivos em discos flexíveis no formato MS-DOS. Dentre as mais utilizadas, podem ser encontradas as seguintes:

\begin{description}

\item <emphasis>mcd [diretorio]</emphasis> - Muda o diretório corrente da unidade especificada.

\item <emphasis>mcopy fonte [destino]</emphasis> - Copia arquivo especificado em [fonte] para a localização de [destino]. Caso o destino não seja especificado, o diretório corrente é assumido. Exemplo: mcopy exemplo1.txt a:

\item <emphasis>mdel arquivo</emphasis> - Remove o arquivo especificado do disco.

\item <emphasis>mdir [drive] [arquivos]</emphasis> - Exibe o conteúdo do diretório corrente do drive especificado ou lista os arquivos citados como argumentos.

\item <emphasis>mformat drive</emphasis> - Formata o drive especificado no padrão MS-DOS. 

\item <emphasis>mmkdir diretorio</emphasis> - Cria um diretório no sistema de arquivo MS-DOS.


\end{description}

    Em todos os comandos, quando o nome drive não é especificado (como em a: ou b: ), é assumido que as transações serão efetuadas no drive a: .

<chapter>
    <title>Processos em Unix</title>

<sect1>
    <title>Introdução</title>

    Em toda ambiente multitarefa, dentre os quais o Unix é considerado, os recursos computacionais da máquina são alocados pelo kernel para todas as aplicações que concorrem no sistema. Em ambientes Unix em geral, todos os programas executados na máquina são denominados processos, onde cada processo possui conjuntos de parâmetros associados ao mesmo.

    Neste capítulo serão mostradas os procedimentos básicos de visualização e manipulação de processos no Unix.

<sect1>
    <title>Visualizando processos em Unix</title>

    A lista dos processos ativos no sistema pode ser visualizada por intermédio do comando <emphasis>ps</emphasis>, como mostrado a seguir:

\begin{quote}
\begin{verbatim}
maquina:~$ ps
   PID  TT  STAT  TIME  COMMAND
    24   1    S    0:03   -bash
   161   1    R    0:00    ps
maquina:~$
\end{verbatim}
\end{quote}

    Neste exemplo, podemos notar algumas variáveis associadas a cada processo que identificam características próprias de cada um. Entre elas, podemos observar:

\begin{description}
\item[PID] Número identificador do processo
\item[TT] Terminal de onde o processo foi iniciado.
\item[STAT] Status do processo
\item[TIME] Tempo de CPU utilizado.
\item[COMMAND] Nome do programa em execução.
\end{description}
    
    Dentre estes parâmetros, destaca-se o número identificador do processo (<emphasis>PID</emphasis>). Este número é de suma importância para os sistema operacional, pois é a variável que possibilita a máquina distinguir os processos em execução, e para o usuário, pois no caso de acontecer algum problema, como o bloqueamento de um processo, é conveniente que o mesmo seja finalizado, repercutindo assim em uma melhoria na performance da máquina. Quando processo fica bloqueados, o tempo de uso da CPU é tomado sem realização de tarefa útil.

    Diversas são as opções que podem ser passadas ao comando <emphasis>ps</emphasis>. Entretanto, as duas formas mais comuns de utilização do comando ps são: 

\begin{description}
\item[ps] Mostra apenas os processos do usuário.
\item[ps -aux] Mostra todos os processos da máquina.
\end{description}

<sect1>
    <title>{\bf<foreignphrase>Foreground</foreignphrase></title> e {\bf<foreignphrase>Background</foreignphrase>}}

    Os processos podem ser executados de duas formas: em <foreignphrase>foreground</foreignphrase> (primeiro plano) ou <foreignphrase>background</foreignphrase> (segundo plano). Os processos executado em <foreignphrase>foreground</foreignphrase> são aqueles que necessitam de interação direta com o usuário, incluindo troca de informações. Os processo em <foreignphrase>background</foreignphrase> não necessitam desta interação com o usuário.

    Muitas vezes é preciso passar um processo que está sendo executado em <foreignphrase>foreground</foreignphrase> para <foreignphrase>background</foreignphrase> e vice-versa. Numa sessão de transferência de arquivos entre máquinas remotas, a velocidade da linha de transmissão pode aumentar demasiadamente o tempo de transferência (horas, às vezes!). Neste caso, seria interessante passar o processo para segundo plano, liberando a <foreignphrase>shell</foreignphrase> para outras atividades do usuário.

    A passagem de um processo de <foreignphrase>foreground</foreignphrase> para <foreignphrase>background</foreignphrase> é feita primeiro suspendendo o processo, utilizando o conjunto de teclas <emphasis>$<$CTRL$>$+z</emphasis>, seguido do comando <emphasis>bg</emphasis>, que envia o processo para segundo plano. Deve ficar claro que suspender a execução de um processo não significa finalizá-lo, apenas torná-lo temporariamente inativo. 

    A lista dos processos executados em <foreignphrase>background</foreignphrase> pode ser visualizada com o comando <emphasis>jobs</emphasis>, que mostra cada processo associado com um número de <foreignphrase>job</foreignphrase>. Caso o usuário necessite interagir novamente com o processo, deve utilizar o comando <emphasis>fg</emphasis> seguido de \% número de <foreignphrase>job</foreignphrase>. Exemplo:

\begin{quote}
\begin{verbatim}
maquina:~$ jobs
[1]  - Running                       xemacs
[2]  + Suspended (tty output)        vi
maquina:~$ fg %2
\end{verbatim}
\end{quote}

<sect1>
    <title>Finalizando processos</title>

    Quando for necessário finalizar a execução de um processo, duas alternativas são possíveis ao usuário: pela própria interface do aplicativo, ou através do comando <emphasis>kill</emphasis>\footnote{Alguns processo em foreground também podem ser finalizado com o comando $<$CTRL$>$+c}. No caso de um processo ficar bloqueado devido a algum erro de execução, utilizando desne\-ces\-sa\-ria\-mente tempo de CPU, o uso do comando <emphasis>kill</emphasis> se faz necessário. Sua sintaxe é descrita na linha a seguir:

<emphasis>kill [-sinal] número do processo</emphasis>

    Caso o processo não seja finalizado com o procedimento acima, o comando <emphasis>kill</emphasis> deve ser utilizado com o sinal <emphasis>-9</emphasis>, indicando término incondicional do processo, que será encerrado de forma abrupta. Uma observação importante é que só é permitido ao usuário finalizar apenas os seus processos, não podendo intervir nos processo de outros usuários. Um exemplo de uso do comando <emphasis>kill</emphasis> é mostrado a seguir.

\begin{quote}
\begin{verbatim}
maquina:~$ ps
   PID  TTY  STAT  TIME  COMMAND
    24   1    S    0:03   -bash
    60   2    S    0:03   -bash     
   161   1    R    0:00    ps
maquina:~$ kill 60
maquina:~$ ps
   PID  TTY  STAT  TIME  COMMAND
    24   1    S    0:03   -bash
   161   1    R    0:00    ps
maquina:~$ 
\end{verbatim}
\end{quote}

<sect2>
	<title><foreignphrase>Pipelines</foreignphrase></title>

    O <foreignphrase>pipeline</foreignphrase> consiste em canalizar a saída de um processo para a entrada de outro processo. Isto pode ser feito através do caracter de {\em pipe} ``$\mid$'', como mostra o exemplo a seguir, onde a saída de um comando <emphasis>ls -la</emphasis> é enviada para a entrada do comando <emphasis>grep txt</emphasis>. Com isto, apenas os arquivos que possuírem o conjunto de caracteres {\tt 'txt'} no seu nome serão apresentados na tela.

\begin{quote}
\begin{verbatim}
maquina:~$ ls -la
total 120
drwxr-xr-x   4 aluno    users        1024 Mar 31 13:42 ./
drwxr-xr-x   7 root     root         1024 Mar 31 12:53 ../
-rw-r--r--   1 aluno    users          26 Mar 31 13:08 .bash_history
-rw-r--r--   1 aluno    users          34 Nov 23  1993 .less
-rw-r--r--   1 aluno    users         114 Nov 23  1993 .lessrc
drwxr-xr-x   2 aluno    users        1024 Mar 31 13:43 documentos/
-rw-r--r--   1 aluno    users          43 Mar 31 12:58 exemplo1.txt
drwxr-xr-x   2 aluno    users        1024 Mar 31 13:58 financas/
-rw-r--r--   1 aluno    users      108111 Mar 31 13:00 faq.txt
-rw-r--r--   1 aluno    users        5041 Mar 31 12:58 linux1.gif
maquina:~$ ls -la |grep txt
-rw-r--r--   1 aluno    users          43 Mar 31 12:58 exemplo1.txt
-rw-r--r--   1 aluno    users      108111 Mar 31 13:00 faq.txt
maquina:~$ 
\end{verbatim}
\end{quote}

<sect2>
	<title>Redirecionamento</title>

    Redirecionar consiste em alterar a origem da entrada ou o destino da saída de um processo, que, em geral, são as entrada e saída padrões do sistema. O redirecionamento pode ser feito com os caracteres $<$ e $>$, que redirecionam a entrada e a saída, respectivamente.

\begin{quote}
\begin{verbatim}
maquina:~$ ls -la > lista
maquina:~$ cat lista
total 120
drwxr-xr-x   4 aluno    users        1024 Mar 31 13:42 ./
drwxr-xr-x   7 root     root         1024 Mar 31 12:53 ../
-rw-r--r--   1 aluno    users          26 Mar 31 13:08 .bash_history
-rw-r--r--   1 aluno    users          34 Nov 23  1993 .less
-rw-r--r--   1 aluno    users         114 Nov 23  1993 .lessrc
drwxr-xr-x   2 aluno    users        1024 Mar 31 13:43 documentos/
-rw-r--r--   1 aluno    users          43 Mar 31 12:58 exemplo1.txt
drwxr-xr-x   2 aluno    users        1024 Mar 31 13:58 financas/
-rw-r--r--   1 aluno    users      108111 Mar 31 13:00 faq.txt
-rw-r--r--   1 aluno    users        5041 Mar 31 12:58 linux1.gif
maquina:~$ 
\end{verbatim}
\end{quote}



<chapter>
    <title>Unix em Redes TCP/IP</title>

<sect1>
    <title>Introdução</title>

No sistema Unix, são encontrados os dois principais protocolos de redes para sistemas Unix: o UUCP e o TCP/IP. O UUCP foi desenvolvido no final da década de setenta por Mike Lesk da AT\&T Bell Laboratories para permitir o desenvolvimento de uma rede de computadores através de acesso discado em linhas telefônicas públicas. O UUCP foi muito popular na época em que foi criado, pois permitia a comunicação de usuários residenciais, uti\-li\-zando um modem, com servidores de correio eletrônico e USENET News. Hoje, contudo, as comunicações através do UUCP encontram-se cada vez mais raras, uma vez que este protocolo permite a utilização de interfaces gráficas, tão comuns nos aplicativos atuais.

Neste capítulo, serão abordadas algumas aplicações do protocolo TCP/IP, tais como acesso a terminais remotos, transferência de arquivos e correio eletrônico, que estão entre as mais utilizadas pelos usuários da Internet. Neste contexto, objetivo deste capítulo é fornecer ao usuário os procedimentos necessários para que o mesmo possa tirar proveito dos principais aplicativos de rede existente no Unix.

<sect1>
    <title>TCP/IP</title>

O TCP/IP (Transmission Control Protocol/Internet Protocol) consiste em um conjunto de paradigmas que permite grupos de máquinas se comunicarem através de uma rede. De posse do sistema Unix em uma máquina e fazendo uso do TCP/IP, uma conexão desta última com a Internet possibilita a comunicação com quaisquer máquinas ou usuários do mundo que também façam parte desta rede.

<sect1>
    <title>Conceitos básicos sobre Internet</title>

A Internet se popularizou no início da década de noventa com a sua libereção para o setor comercial nos Estados Unidos. Com isso, milhares de empresas entraram na rede, visando um mercado em expansão de milhões de pessoas que estava prestes a explodir em tamanho.

A Internet possui atualmente uma taxa de crescimento vertiginosa e, por que não mensionar, assustadora, visto que o número de máquinas conectadas à mesma praticamente duplica a cada ano (ver Tabela \ref{table:hosts}). 

\begin{table}[htpb]
\begin{quote}
<emphasis>Internet Domain Survey\dag, Julho 1996</emphasis>

<foreignphrase>Number of Hosts, Domains and Nets</foreignphrase>.\\ 
    \begin{tabular}{|c|c|c|c|c|c|c|}
    \hline
     Date & Hosts & Domains & Replied to Ping\ddag & A & B & C \\ \hline
     Jul 96 & 12,881,000 & 488,000 & 2,569,000 & 95 & 5892 & 128378 \\ \hline
     Jan 96 & 9,472,000 & 240,000 & 1,682,000 & 92 & 5655 & 87924 \\ \hline
     Jul 95 & 6,642,000 & 120,000 & 1,149,000 & 91 & 5390 & 56057 \\ \hline
     Jan 95 & 4,852,000 & 71,000 & 970,000 & 91 & 4979 & 34340 \\ \hline
     Jul 94 & 3,212,000 & 46,000 & 707,000 & 89 & 4493 & 20628 \\ \hline
     Jan 94 & 2,217,000 & 30,000 & 576,000 & 74 & 4043 & 16422 \\ \hline
     Jul 93 & 1,776,000 & 26,000 & 464,000 & 67 & 3728 & 9972 \\ \hline
     Jan 93 & 1,313,000 & 21,000 &  & 54 & 3206 & 4998 \\ \hline\hline
    \end{tabular}

    \begin{tabular}{l}    
    \footnotesize
    \dag Produzido por Network Wizards (disponível em http://www.nw.com)
    \end{tabular}

    \begin{tabular}{l}    
    \footnotesize
    \ddag <foreignphrase>Estimated by pinging 1\% of all hosts</foreignphrase>.
    \end{tabular}

    \caption{Número de máquinas, domínios e redes na Internet.}

    \label{table:hosts}
\end{quote}
\end{table}

Como em toda tecnologia de rede, cada máquina na Internet precisa ter um endereço único. A forma de endereçamento adotada é um número inteiro formado por trinta e dois bits. Convencionou-se representar esse número como sendo formado de quatro octetos separados por pontos, cada um variando de 0 a 255. Um exemplo de endereço válido na Internet é 205.216.146.42. Contudo, a tarefa de memorizar um número IP não é agradável para o homem, muito menos os milhares de números IP existentes na Internet.

Para contornar esse problema, foi criado o conceito de domínio, que é uma forma de transformar endereços númericos, difíceis de serem memorizados, em um nomes que representem as máquinas em locais da grande rede. Para a Internet, foram adotados os chamados domínios hierárquicos.

Os domínios hieráquicos são dividos em duas categorias: geográficos e oficiais. Os domínios geográficos possuem o código do país no nível mais alto, como em

{\tt endereço_da_máquina.sub_organização.organização.br}

Por exemplo, o endereço www.yahoo.com (204.71.177.73) pertence ao domínio {\tt yahoo.com}. Os sufixos de cada país foram padronizado por entidades internacionais, e com exceção dos Estados Unidos, todo domínio na Internet termina com o sufixo do país em que se encontra. Veja abaixo alguns exemplos de sufixos:

\begin{description}
\item[ar] Argentina.
\item[au] Austrália.
\item[br] Brasil.
\item[ca] Canada.
\item[ch] Chile.
\item[fr] França.
\item[uk] Reino Unido.
\end{description}

Nos Estados Unidos, berço da Internet, os sufixos são diferentes. Foram adotados domínios oficiais, onde cada sufixo indica o tipo de instituição à qual a máquina pertence. 

Os domínios oficiais dos Estados Unidos são:

\begin{description}
\item[\bf com] Para designar uma instituição comerca
\item[\bf edu] Para designar uma instituição educacional.
\item[\bf gov] Instituição governamental.
\item[\bf mil] Instituições militares.
\item[\bf org] Domínios reservados para organizações privadas.
\item[\bf net] <foreignphrase>Gateways</foreignphrase> e outros computadores administrativos da rede.
\end{description}

<sect1>
    <title>Aplicativos de redes</title>

<sect2>
	<title>Correio Eletrônico</title>

Um dos aplicativos mais utilizados na Internet é o correio eletrônico. Com ele, usuários podem enviar e receber mensagens de quaisquer pessoas que possuam endereços eletrônicos na rede. O correio eletrônico está diretamente relacionado ao conceito de endereço eletrônico, que provê todas as informações necessárias para que uma mensagem, partindo de qualquer parte do mundo, possa chegar até o seu destinatário. O endereço eletrônico pode representar tanto um indivíduo quanto um conjunto de indivíduos e é formado pela combinação

\begin{center}
<emphasis>login_do_usuário@domínio_da_máquina</emphasis>
\end{center}

{\flushleft Exemplo: <emphasis>joao@engcomp.ufrn.br</emphasis>}

Uma mensagem de correio eletrônico é formada basicamente de duas partes distintas: 

\begin{enumerate}
\item o cabeçalho, que contém informações a respeito de quem esta enviando a mensagem e para quem, bem como todo o trajeto feito pela mensagem na Internet; 
\item o corpo ou conteúdo da mensagem.
\end{enumerate}

No Unix, existem vários programas de correio eletrônico, sejam eles orientados a caracteres ou a interfaces gráficas. A maior parte deles é original dos sistemas Unix. Como exemplos de programas de correio eletrônico no Unix, podemos citar o <emphasis>pine</emphasis> e o <emphasis>mail</emphasis>.
    
Ao entrar em um sistema Unix genérico, é costumeiro que o usuário receba uma aviso a existência ou não de mensagens para si. Um dos programas mais utilizados para leitura de correio eletrônico no Unix é o <emphasis>pine</emphasis>. Ao executar o <emphasis>pine</emphasis> o usuário tem acesso a uma interface de texto bastante auto-explicativa, como mostrado a seguir.
    
\begin{center}
\begin{boxedverbatim}
PINE 3.96   MAIN MENU                            Folder: INBOX  93  Messages  

       ?     HELP               -  Get help using Pine                   
       C     COMPOSE MESSAGE    -  Compose and send/post a message       
       I     FOLDER INDEX       -  View messages in current folder       
       L     FOLDER LIST        -  Select a folder OR news group to view 
       A     ADDRESS BOOK       -  Update address book                   
       S     SETUP              -  Configure or update Pine              
       Q     QUIT               -  Exit the Pine program                 

   Copyright 1989-1997.  PINE is a trademark of the University of Washington.
                    [Folder "INBOX" opened with 93 messages]
? Help                     P PrevCmd                  R RelNotes            
O OTHER CMDS L [ListFldrs] N NextCmd                  K KBLock              
\end{boxedverbatim}
\end{center}

Para ler as mensagens, basta selecionar a opção ``{\tt L}'' do menu e selecionar a pasta {\tt INBOX} na tela seguinte. INBOX representa todas as mensagens existentes na caixa postal do usuário. Uma vez selecionada a pasta INBOX, uma tela semelhante a seguinte aparecerá no terminal.

\begin{small}
\begin{center}
\begin{boxedverbatim}
PINE 3.96   FOLDER INDEX                 Folder: INBOX  Message 1 of 90       

      1 Oct 15 Ernesto Paulo dos   (1,858) [linux-br] Bons Livros sobre Linux e 
+     2 Oct 15 orders@amazon.com   (2,810) Your Order with Amazon.com (#002-0898
      3 Oct 16 Tiago Walzer Kuhn   (1,672) [linux-br] Re: Bons Livros sobre Linu
      4 Oct 16 Klaus Steding-Jess  (2,717) Re: [TeX-BR] man2latex               
+     5 Oct 16 Agostinho M. Brito    (592) ftp.icce.rug.nl                      
+     6 Oct 18 orders@amazon.com   (1,997) Your Amazon.com order (#002-0898723-5
      7 Oct 19 Andrés Ortiz Salaz  (6,238) [Fwd: Curso "virtual" de linguagem C]
      8 Oct 22 Ying Zhang          (2,842) [linux-br] [comp.os.linux.announce] S
      9 Oct 26 Tobias Gloth        (4,136) [linux-br] [comp.os.linux.announce] M
                          [Already at start of Index]
? Help       M Main Menu  P PrevMsg     - PrevPage    D Delete      R Reply     
O OTHER CMDS V [ViewMsg]  N NextMsg   Spc NextPage    U Undelete    F Forward  
\end{boxedverbatim}
\end{center}
\end{small}

A mensagem pode ser selecionada com as setas do teclado. Para compor mensagens, seleciona-se a opção <emphasis>C</emphasis> no menu principal do programa ou digita-se a tecla <emphasis>C</emphasis>, de <foreignphrase>compose</foreignphrase>. Na tela de composição de e-mail, o usuário precisará preencher os campos {\tt to}, indicando o endereço do destinatário, <foreignphrase>subject</foreignphrase>, o assunto da mensagem e escrever a mensagem propriamente dita. Exemplo:
\begin{center}
\begin{boxedverbatim}
PINE 3.96   COMPOSE MESSAGE              Folder: INBOX  104 Messages  
To      : ambj@leca.ufrn.br
Cc      : 
Attchmnt: 
Subject : teste de e-mail
----- Message Text -----
Alo, agostinho.

         Estou testando correio eletronico.
         Abracos, Agostinho


^G Get Help ^X Send    ^R Rich Hdr ^Y PrvPg/Top ^K Cut Line  ^O Postpone  
^C Cancel   ^D Del Char^J Attach   ^V NxtPg/End ^U UnDel Line^T To AddrBk
\end{boxedverbatim}  
\end{center}

<sect2>
	<title>Transferência de arquivos</title>

A transferência de arquivos é hoje um recurso mais do que conhecido pelos usuários da Internet. Encontram-se espalhados nas máquinas ao redor do mundo milhares documentos ou aplicações científicas, demonstrativos de jogos, aplicativos para diversos sistemas operacionais, diversos artigos e dicas sobre determinados programas ou periféricos existentes no mercado, além de diversos produtos que  empresas de informática estão disponibilizando pela rede. Todos estes recursos e muitos outros não mencionados estão ao alcance dos usuários da Internet, desde que, é claro, possuam as ferramentas adequadas para a transferência de arquivos entre máquinas.

Um dos mecanismos que surgiu junto com a Internet foi o FTP (File Transfer Protocol), cuja função é a de possibilitar troca de arquivos entre computadores remotos. Em muitos sistemas, é também o nome do programa que implementa o protocolo.

O <emphasis>ftp</emphasis> é um software interativo de transferência de arquivos e necessita de que o usuário insira as informações necessárias ao gerenciamento das funções do programa.
    
Para dar início a uma sessão de FTP, basta digitar a linha de comando a seguir:\\

<emphasis>ftp $<$nome da máquina servidora de ftp$>$</emphasis>\\

Feito isso, será pedido ao usuário um login e uma senha. Caso este último não possua uma conta na máquina remota conectada, poderá utilizar o login anonymous\footnote{É necessário que a máquina remota possibilite o acesso do usuário anonymous}, cuja a senha é o próprio endereço eletrônico do usuário local. O conta de usuário anonymous existe em muitas máquinas como uma forma de possibilitar a usuários de outros sistemas o acesso a diretórios locais que contenha informações de domínio público.

{\flushleft Comandos básicos do programa <emphasis>ftp</emphasis>:}

\begin{center}
\begin{tabularx}{\linewidth}{l|X}
  \hline\hline
  <emphasis>comando</emphasis> & descrição \\ \hline\hline
  <emphasis>dir</emphasis> &  Lista o conteúdo do diretório da máquina remota. \\ \hline
  <emphasis>binary</emphasis> & Informa ao FTP que os arquivos a serem transferidos são programas e não texto. \\ \hline
  <emphasis>ascci</emphasis> &  Informa ao FTP que os arquivos transferidos são no modo texto. \\ \hline
  <emphasis>get $<$arquivo$>$</emphasis> &  Transfere o arquivo remoto para a sua máquina. \\ \hline
  <emphasis>put $<$arquivo$>$</emphasis> &  Transfere o arquivo de sua máquina para a máquina remota. \\ \hline
  <emphasis>mget $<$arquivo1$>${[</emphasis>$<$arquivo2$>$...{]}} &  Transfere o arquivo remoto para a sua máquina.\\ \hline
  <emphasis>mput $<$arquivo1$>${[</emphasis>$<$arquivo2$>$...{]}} &  Transfere o arquivo de sua máquina para a máquina remota.\\ \hline
  <emphasis>cd $<$diretório$>$</emphasis> &  Muda de diretório na máquina remota.\\ \hline
  <emphasis>lcd $<$diretório$>$</emphasis> &  Muda de diretório na máquina local.\\ \hline
  <emphasis>quit ou bye</emphasis> &  Finaliza o FTP.\\ \hline
  <emphasis>help</emphasis> &  Exibe informações sobre todos os comandos disponíveis.\\ \hline
  \hline
\end{tabularx}
\end{center}

Exemplo de abertura de sessão <emphasis>ftp</emphasis>:

\begin{quote}
\begin{verbatim}
maquina:~$ ftp ftp.engcomp.ufrn.br
Connected to ftp.engcomp.ufrn.br.
220 ribeira FTP server (Version wu-2.4(1) Tue Dec 5 20:51:15 CST 1995) 
ready.
Name (ribeira.engcomp.ufrn.br:aluno): anonymous
331 Guest login ok, send your complete e-mail address as password.
Password:
230-Welcome, archive user!  This is an experimental FTP server. If have
230-any unusual problems, please report them via e-mail to root
230-If you do have problems, please try using a dash (-) as the first
230-character of your password -- this will turn off the continuation 
230-messages that may be confusing your ftp client.
230-
230 Guest login ok, access restrictions apply.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> 
\end{verbatim}
\end{quote}

<sect2>
	<title>Emulação de Terminal Remoto</title>

    Uma das facilidades provenientes dos ambientes de redes, dentre os quais destaca-se a Internet, é a possibilidade de executar comandos em uma máquina através de um acesso remoto à mesma. O ambiente no qual um determinado usuário executa os comandos remotos é conhecido no jargão de redes como {\em terminal remoto}. Em outras palavras, um usuário logado em uma máquina X realiza uma conexão de terminal remoto com uma máquina Y e, a partir daí, realiza comandos na máquina X que serão executados na máquina Y.

    Este recurso de execução remota de comandos permite, por exemplo, que pesquisadores de um laboratório utilizem o poder computacional de processamento de um outro computador, localizado em um outro laboratório de qualquer parte do mundo.

    Para utilizar o terminal remoto é necessário que o usuário possua uma conta no sistema remoto. Em algumas ocasiões, pode existir uma conta de domínio público, semelhante ao usuário anonymous do aplicativo <emphasis>ftp</emphasis>. Entretanto, isto não é costumeiro em se tratando de acesso remoto, por questões de segurança do sistema.

    Os dois comandos mais utilizados para iniciar uma sessão de terminal remoto são <emphasis>telnet</emphasis> e <emphasis>rlogin</emphasis>:

\begin{description}
\item[<emphasis>Telnet</emphasis>]: Sintaxe: <emphasis>telnet endereço_da_máquina</emphasis>
\item[<emphasis>Rlogin</emphasis>]: Sintaxe: <emphasis>rlogin endereço_da_máquina</emphasis>
\end{description}

    O comando <emphasis>rlogin</emphasis> inicia uma sessão de terminal remoto em uma máquina Y, na mesma conta de usuário da máquina X (mesmo <foreignphrase>login name</foreignphrase>). A diferença básica do <emphasis>rlogin</emphasis> em relação ao <emphasis>telnet</emphasis> é que o primeiro não requisita a identificação do usuário (login), apenas a sua senha.

<sect2>
	<title>Conversando pela Internet</title>

    O Unix implementa uma aplicação muito interessante do Unix: o <emphasis>talk</emphasis>. O <emphasis>talk</emphasis> é um programa interativo e permite que um usuário possa conversar em tempo real com outro via Internet. Para iniciar uma sessão de <foreignphrase>talk</foreignphrase>, é necessário confirmar se a pessoa com a qual se deseja conversar está logada no momento e em alguma máquina.

    O estabelecimento de uma chamada de <foreignphrase>talk</foreignphrase> é feita executando o comando com os argumentos adequados:

    <emphasis>talk login_do_usuário_remoto@máquina_remota</emphasis>

    Uma vez executado esse comando, será preciso que o usuário remoto para qual a chamada de <foreignphrase>talk</foreignphrase> foi solicitada confirme o pedido. Esta confirmação é feita quando o usuário remoto executa o comando <emphasis>talk</emphasis> passando como argumentos o endereço do usuário que iniciou a conexão. Uma vez confirmada a solicitação de <foreignphrase>talk</foreignphrase>, a tela é dividida em duas janelas, onde na janela de cima são escritas as mensagens do usuário local, e na de baixo são apresentadas as mensagens enviadas pelo usuário remoto. Uma sessão de <foreignphrase>talk</foreignphrase> pode ser finalizada com o comando $<$CTRL$>$+c.

<sect2>
	<title>Verificando se uma máquina está ativa com <emphasis>ping</emphasis>

     O comando <emphasis>ping</emphasis>, serve para saber se determinada máquina na Internet está funcionando. A sua sintaxe é:

    <emphasis>ping endereço_da_máquina</emphasis>

    Uma vez executado o comando, mensagens de retorno serão apresentadas na tela, indicando se a máquina está ligada e funcionando ou que o seu endereço não é reconhecido. Neste último caso, três hipóteses podem ser consideradas: 

\begin{enumerate}
\item não existe uma máquina na Internet com o nome ou o número passado como argumento.
\item a máquina está desligada.
\item alguma máquina que entremeia o caminho para a máquina de destino encontra-se fora do ar.
\end{enumerate}

<chapter>
    <title>Edição de textos com <emphasis>joe</emphasis></title> 

<sect1>
    <title>Introdução</title>

Existem diversos editores de texto para Unix. Entre os mais conhecidos e utili\-zados, destacam-se o <emphasis>vi</emphasis>, amplamente difundido na maioria dos sistemas Unix, e o <emphasis>emacs</emphasis>, desenvolvido pela GNU. A popularização destes editores se deu principalmente devido à enormidade de recursos e ferramentas de edição e processamento de texto disponíveis em cada um, que, algumas vezes, os tornam difíceis de utilizar.

Também podem ser encontrados muitos editores gráficos do tipo WYSIWYG(<foreignphrase>What You See Is What You Get</foreignphrase>, alguns deles em versões <foreignphrase>freeware</foreignphrase> (a grande maioria) e alguns em versões comerciais. Podemos citar como exemplos de bons editores gráficos os pacotes Andrew, Lyx, Thot, Applixware e StarOffice, tendo este último funcionalidades bastante semelhantes às do Microsoft Word 6.0.

Neste capítulo será apresentado um dos editores ascii de texto mais populares no sistema Linux: o <emphasis>joe</emphasis>. O que motiva o seu uso é o fato de sua operacão ser simples, pois seus comandos se assemelham bastante aos utilizados em editores como o WordStar, Sidekick e Turbo Pascal para MSDOS, com os quais a maioria dos usuários de PC são familiares. Esta sua característica o torna bastante atrativo para edição de textos em terminais. 


<sect1>
    <title>O editor de textos <emphasis>joe</emphasis></title>

Para executar o joe basta digitar o comando <emphasis>joe</emphasis> seguido ou não do nome do arquivo que se deseja editar, e da tecla $<$ENTER$>$. Com isso, a tela de edição do <emphasis>joe</emphasis> será apresentada para o usuário tal como mostrado abaixo. 

\begin{center}
\begin{boxedverbatim}
IW  teste.txt                     Row 1    Col 1    4:49  Ctrl-K H for help

Este e' um exemplo de texto editado no joe,
um popular editor de texto bastante utilizado por
usua'rios do sistema Linux.

Seus comandos sao bastante semelhantes aos do WordStar e 
Sidekick para MSDOS.

        
        Use o joe para editar os seus textos!




** Joe's Own Editor v2.2 ** Copyright (C) 1994 Joseph H. Allen **
\end{boxedverbatim}
\end{center}

Para acessar a ajuda <foreignphrase>on-line</foreignphrase>, basta digitar a combinação de teclas $<$CTRL$>$+K+H (\^{}KH, segundo a notação do <emphasis>joe</emphasis>) que a tela de ajuda aparecerá, como mostrado a seguir. Para fechar a tela de ajuda, basta digitar a combinação \^{}KH novamente.

\begin{center}
\begin{boxedverbatim} 
 CURSOR           GO TO            BLOCK      DELETE   MISC         EXIT       
 ^B left ^F right ^U  prev. screen ^KB begin  ^D char. ^KJ reformat ^KX save   
 ^P up   ^N down  ^V  next screen  ^KK end    ^Y line  ^T  options  ^C  abort  
 ^Z previous word ^A  beg. of line ^KM move   ^W >word ^R  refresh  ^KZ shell  
 ^X next word     ^E  end of line  ^KC copy   ^O word< ^@  insert   FILE       
 SEARCH           ^KU top of file  ^KW file   ^J >line SPELL        ^KE edit   
 ^KF find text    ^KV end of file  ^KY delete ^_ undo  ^[N word     ^KR insert 
 ^L  find next    ^KL to line No.  ^K/ filter ^^ redo  ^[L file     ^KD save  
\end{boxedverbatim}
\end{center}
A movimentação do cursor dentro do texto pode ser feita com as setas do teclado, para mudar entre linhas e colunas, ou através das teclas PGUP e PGDN, para deslocamento entre páginas. 

Para procurar por grupos de caracteres dentro do texto, basta utilizar a combinação de teclas \^{}KF e indicar a <foreignphrase>string</foreignphrase> de texto desejada. Feito isso, o joe requisita algumas opções de busca, tais como sensibilidade ao caso (MAIÚSCULAS/minúsculas) e direção de busca. Para repetir a última busca realizada, basta digitar \^{}L.

Para remover caracteres, podem ser utilizadas as teclas $<$BACKSPACE$>$, para apagar um caracter à esquerda do cursor, e $<$DEL$>$, para apagar caracteres à direita do cursos. A remoção de linhas inteiras é feita digitando o comando \^{}Y. O joe também suporta operações de bloco. Para marcar o início e o fim de um bloco, digita-se \^{}KB e \^{}KK, respectivamente. Para remover o bloco marcado, digita-se \^{}KY. Para mover o bloco para a posição corrente do cursor, basta digitar \^{}KM. A cópia do bloco para a posição do cursor, por sua vez, é feita com a combinação de teclas \^{}KC.

O joe mantém uma lista de todas as mudanças realizadas pelo usuário no documento, permitindo desfazer e refazer quaisquer ações dentro de uma sessão de edição de texto. Para desfazer a mudança mais recente, digita-se $<$CTRL$>$+$<$SHIFT$>$+_ (control-sublinhado). Para refazer uma mudança desfeita anteriormente, basta digitar $<$CTRL$>$+$<$SHIFT$>$+\^{} (control-circunflexo).

As mudanças realizadas no arquivo podem ser salvas com a combinação de teclas \mbox{$<$CTRL$>$+K+D}. Para sair do <emphasis>joe</emphasis> e salvar as mudanças correntes, basta digitar \^{}KX. Caso o usuário não deseje salvar as alterações, o mesmo pode sair do editor digitando \^{}C. Se alguma mudança tiver sido efetuada, o <emphasis>joe</emphasis> irá perguntar se o usuário deseja sair sem salvar as alterações.

No quadro abaixo são apresentados os principais comandos do <emphasis>joe</emphasis>, incluindo operações de movimentação na tela, manipulação de blocos e arquivos, busca de expressões e remoção de objetos, entre outros. 

\begin{center}
\begin{boxedverbatim}
 CURSOR                     MOVER                      MARCAR BLOCO
 ^B esquerda                ^U  tela anterior          ^KB início  
 ^P cima                    ^V  tela posterior         ^KK final    
 ^Z palavra anterior        ^A  início da linha        ^KM mover   
 ^X palavra posterior       ^E  fim da linha           ^KC copiar   
 ^F direita                 ^KU início do arquivo      ^KW salvar  
 ^N baixo                   ^KV final do arquivo       ^KY apagar
                            ^KL mover para linha       ^K/ filtro

 DELETAR                MISCELÂNEA              SAIR   
 ^D caracter            ^KJ reformatar          ^KX salvar   
 ^Y linha               ^T  opções              ^C  abortar  
 ^W palavra a direita   ^R  refrescar           ^KZ shell  
 ^O palavra a esquerda  ^@  inserir             ARQUIVO      
 ^J final da linha      SPELL                   ^KE editar 
 ^_ desfazer            ^[N palavra             ^KR inserir 
 ^^ refazer             ^[L arquivo             ^KD salvar  

 BUSCA          
 ^KF procurar texto   
 ^L  procurar próximo
\end{boxedverbatim}
\end{center}
É importante ter em mente que o <emphasis>joe</emphasis> é apenas um editor de texto
ascii e não um completo processador de texto. Opções tais como mudança
de fontes, alinhamento ou insersão de gráficos são deixadas por conta
de pacotes como o \LaTeX, que dão ao usuário munição suficiente para
construir as mais variadas formas de arranjo textos e objetos gráficos
em um documento.



<chapter>
    <title>O ambiente gráfico X Window</title> 

<sect1>
    <title>Introdução</title>

O sistema X Window (ou simplesmente ``<emphasis>X</emphasis>'') é um ambiente de trabalho gráfico utilizado em quase todos os desktops Unix existentes no mundo. Foi desenvolvido inicialmente pelo MIT (<foreignphrase>Massachusetts Institute of Technology</foreignphrase>), sendo o projeto posteriormente repassado para um conjunto de empresas denominado ``<foreignphrase>The X Consortium</foreignphrase>'' e mantidos por eles desde então.

O X é constituído de um programa chamado <emphasis>servidor gráfico</emphasis>, responsável por desenhar os elementos da tela e de uma série de bibliotecas auxiliares. Os programas utilitários são denominados <emphasis>clientes</emphasis>. O browser <emphasis>netscape</emphasis> é um exemplo de programa cliente.

No Linux, o X Window é implementado por um conjunto de programas e bibliotecas denominado <emphasis>XFree86</emphasis>. O XFree86 é totalmente gratuito e dá suporte às mais diversas placas de vídeo disponíveis no mercado.

O X Window traz para o usuário Unix o conforto de trabalhar em um ambiente gráfico, com ícones, editores de texto e imagem etc e possibilita, entre outras coisas, que aplicativos desenvolvidos em um tipo de unix possam ser exibidos na tela de outro.

<sect1>
    <title>Iniciando e Finalizando o X Window</title>

Em diversas máquinas, o X é normalmente iniciado após o boot. Neste caso, para o usuário utilizar o sistema, é preciso entrar com o seu username e a sua senha em alguma janela de diálog específica.

Quando o X Window não é iniciado após o boot, o comando\\

{\tt startx} 

{\flushleft resolverá o problema}. {\tt startx} é um <foreignphrase>shell script</foreignphrase> que executa o servidor gráfico e inicia o gerenciador de janelas.

O gerenciador de janelas é quem arruma na tela todo o arsenal de aplicativos e realiza as interações entre o usuário e o X Window. Dependendo do gerenciador de janelas utilizado, o usuário poderá ter um ícone indicando as horas, outro para abrir um terminal de comandos etc. O Linux é um dos sistemas que mais possue gerenciadores de janela. Entre outros, podemos citar  <emphasis>fvwm</emphasis>, <emphasis>olwm</emphasis>, <emphasis>mwm</emphasis>, <emphasis>Kde</emphasis> e <emphasis>gnome</emphasis>.

A finalização do X geralmente é feita através de alguma entrada de menu do tipo ``Exit Window Manager'', ou simplesmente ``exit''. Caso não seja encontrada alguma saída óbvia, basta digitar a combinação das teclas \fbox{CTRL}+\fbox{ALT}+\fbox{BACKSPACE}.

<sect1>
    <title>Executando aplicativos</title>

Os aplicativos mais comuns podem ser encontrados nos menus que o gerenciador de janelas apresenta, tais como <emphasis>shells</emphasis>, <emphasis>gerenciadores de arquivo</emphasis> e <emphasis>editores de texto</emphasis>. Quando a aplicação procurada não se encontra no menu, a maneira mais rápida de executá-la é através de uma shell.

A shell é na maioria das vezes o primeiro aplicativo procurado por um usuário Unix, pois agiliza a tarefa de interagir com o sistema. No X Window, o programa {\tt xterm} disponibiliza a shell para o usuário. Praticamente todos aplicativos gráficos do sistema podem ser executados pelo usuário diretamente de um terminal. Recomenda-se fazer a execução do aplicativo em <foreignphrase>background</foreignphrase> para liberar a shell para outras atividades.

<sect1>
    <title>Usando o mouse</title>

No X Window, as três teclas do mouse possuem uma função específica. Caso o mouse possua apenas dois botões, ou o botão do meio esteja desabilitado, o clique simultâneo dos botões esquerdo e direito simulam o efeito do botão central.

A tecla da esquerda é utilizada para selecionar elementos na tela (botões, menu, barras de rolagem etc), maximizar, minimizar e fechar janelas, além de marcar texto nos programas que permitam esta operação.

A tecla do meio é utilizada principalmente para colar objetos selecionado com o botão da esquerda, principalmente texto.

A tecla da direita abre menus na tela do tipo ``<foreignphrase>pop-up</foreignphrase>'' para o usuário. Sua utilização é mais intensiva se dá no gerenciador de janelas olwm. Neste sistema, as aplicações são chamadas com o mouse a partir do menu <foreignphrase>pop-up</foreignphrase> apresentado quando o usuário clica com o botão direito no fundo da área de trabalho.

<sect1>
    <title>A área de trabalho</title>

A área de trabalho do usuário, ou <foreignphrase>Desktop</foreignphrase>, é a região da tela onde todos os aplicativos gráficos são lançados. Os gerenciadores de janela geralmente executam um programa que disponibiliza várias áreas de trabalho para o usuário, ou <foreignphrase>Desktops</foreignphrase> virtuais. Com isto, a sobrecarga visual é dividida em diversos ambientes, tornando o uso da máquina mais agradável.

A figura \ref{fig:xwindow} mostra uma tela do X Window System utilizando o gerenciador de janelas fvwm95.

\begin{figure}[htbp]
  \begin{center}
    \includegraphics[width=\linewidth]{xwindow.pdf}
    \caption{O Ambiente X Window utilizando o gerenciador de janelas fvwm95.}
    \label{fig:xwindow}
  \end{center}
\end{figure}

Alguns gerenciadores de <foreignphrase>Desktops</foreignphrase> possibilitam inclusive que o usuário desloque uma janela de um <foreignphrase>Desktop</foreignphrase> para outro.

<sect1>
    <title>Definindo o Display</title>

Em se tratando de X Window, toda aplicação gráfica possui um display associado à mesma. O display é o nome da tela gráfica que o servidor X controla. No Unix, é uma combinação de três elementos:

\begin{itemize}
\item Nome da máquina onde será exibida a aplicação.
\item Número do servidor gráfico a ser utilizado (uma máquina pode ter mais de um servidor em funcionamento).
\item Número da tela gráfica (o servidor X pode controlar mais de uma tela ao mesmo tempo).
\end{itemize}

O display é geralmente definido pela variável de ambiente <emphasis>DISPLAY</emphasis>. Assim para definir que um aplicativo deverá ser apresentado na máquina {\tt maquina.engcomp.ufrn.br}, pelo primeiro servidor na primeira tela, basta executar o seguinte comando:

\begin{itemize}
\item Para {\tt tcsh}:
\begin{quote}
\begin{verbatim}
maquina:~$ setenv DISPLAY maquina.engcomp.ufrn.br:0.0
\end{verbatim}
\end{quote}
\item Para {\tt bash}:
\begin{quote}
\begin{verbatim}
maquina:~$ export DISPLAY=maquina.engcomp.ufrn.br:0.0
\end{verbatim}
\end{quote}
\end{itemize}

<sect1>
    <title>Permitindo que máquinas remotas acessem o servidor X local</title>

A variável de ambiente apresentada na seção anterior serve para indicar que o local onde a aplicação gráfica será apresentada, não para garantir que o servidor especificado irá permitir esta operação. Por questões de segurança, o servido X não oferece a priori os seus serviços para todas as máquinas da sua rede. Assi, cada vez o usuário precise apresentar aplicações lançadas por máquinas remotas na tela gráfica local o servidor deverá ser informado através do comando <emphasis>xhost</emphasis>. 

O comando <emphasis>xhost</emphasis> quando executado sem argumentos exibe a lista de todas as máquinas autorizadas a lançar aplicações no servidor local. As máquinas que podem utilizar o servidor X são adicionadas ao sistema da forma

\begin{quote}
\begin{verbatim}
maquina:~$ xhost + maquina_A
\end{verbatim}
\end{quote}

e retiradas da forma

\begin{quote}
\begin{verbatim}
maquina:~$ xhost - maquina_A
\end{verbatim}
\end{quote}

Se um determinado usuário utilizando o computador <emphasis>A</emphasis> deseja utilizar o poder computacional do computador <emphasis>B</emphasis> para executar um aplicativo gráfico (xpaint, por exemplo) e apresentar tela do programa no computador <emphasis>A</emphasis> o procedimento para realizar esta tarefa seria o seguinte:

\begin{quote}
\begin{verbatim}
maquina_A:~$ xhost +
maquina_A:~$ telnet maquina_B
Trying 10.0.0.1...
Connected to maquina_B.
Escape character is '^]'.

Linux 2.0.34 (maquina_B) (ttyp1)

maquina_B login: usuario
Password: 
maquina_B:~$ setenv DISPLAY maquina_A:0.0
maquina_B:~$ xpaint &
maquina_B:~$ 
\end{verbatim}
\end{quote}

\begin{thebibliography}{9}
\bibitem{1} GREENFIELD, L. <emphasis>The Linux users' guide</emphasis>, 1994. Disponível via ftp anônimo em {\tt sunsite.unc.edu}, no diretório {\tt /pub/Linux/docs/LDP}.
\bibitem{2} WELSH, M. <emphasis>Linux instalation and getting started</emphasis>, 1994. Disponível via ftp anônimo em {\tt sunsite.unc.edu}, no diretório {\tt /pub/Linux/docs/LDP}.
\end{thebibliography}
-->
