<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>
<book xmlns="http://docbook.org/ns/docbook"
      xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0" xml:lang="pt-br">
  <info>
    <title>Introdução ao Linux</title>
    <author>
      <personname>
	<firstname>Agostinho</firstname>
	<othername>de Medeiros</othername>
	<surname>Brito Júnior</surname>
      </personname>
    </author>
    <copyright><year>2013</year><holder>Agostinho Brito</holder></copyright>
    <address>DCA-CT-UFRN</address>
  </info>

  <!-- Capitulo 1 -Introducao -->
  <chapter xml:id="cha.introducao">
    <title>Introdução</title>
    <para>Unix é o sistema operacional mais popular e difundido no mundo, especiamente em ambientes de rede distribuídos, devido à sua grande base de suporte e distribuição existentes. Foi originalmente criado em meados de 1970 como um sistema multi-tarefa para operação em minicomputadores e <foreignphrase>mainframes</foreignphrase>. Hoje, o Unix é a pedra fundamental de máquinas de grande e médio porte, tais como IBMs, DECs e Suns, suportando ambientes e aplicativos poderosos que exigem muito dos sistemas em que operam.</para>
    <para>O sistema Unix permite a alocação de recursos em máquinas, tais como CPU, memória principal e de massa, console, impressoras, modems, scanners e diversos outros periféricos existentes. Tem características multi-usuário, permitindo que várias pessoas utilizem os recursos da máquina de forma seletiva, e multi-tarefa, pois uma ou mais tarefas podem ser executadas ao mesmo tempo em um mesmo processador.</para>
    <para>Por ter sido o Unix um sistema escrito em linguagem C, diversas implementações suas podem ser encontradas, tais como: AIX, para IBM, SunOS e Solaris, para estações SUN, e Linux, para máquinas IBM/PC e compatíveis.</para>
    <para>Neste documento serão apresentados conceitos básicos sobre o sistema Unix e comentados os programas de uso mais comum nas tarefas diárias realizadas por um usuário.</para>
  </chapter>

  <!-- A estrutura do sistema Unix -->
  <chapter xml:id="cha.estrutura">
    <title>A estrutura do sistema Unix</title>
    <sect1>
      <title>Acesso ao hardware</title>
      <para>O coração de um sistema Unix é o seu <foreignphrase>kernel</foreignphrase>. O <foreignphrase>kernel</foreignphrase> é a parte do sistema que possibilita o acesso aos recursos da CPU, à memória principal e aos periféricos existentes na máquina. Desse modo, toda e qualquer ação que a máquina realiza é coordenada pelo kernel, através de chamadas do mesmo (chamadas de sistema). Estas chamadas podem ser realizadas diretamente das aplicações, através de <foreignphrase>shells</foreignphrase> (interpretadores de comando) ou por intermédio de bibliotecas, como mostra a <xref linkend="fig-unix-kernel"/>.</para>
      <figure xml:id="fig-unix-kernel">
	<title>Estrutura básica do Unix</title>
	<mediaobject>
	  <imageobject role="html">
	    <imagedata format="SVG" fileref="figuras/kernel.svg"/>
	  </imageobject>
	</mediaobject>
      </figure>
    </sect1>
    <sect1>
      <title>Processos</title>
      <para>No Unix, todas as atividades dos usuários são feitas através de processos, sequências únicas de eventos que ocorrem em uma máquina, onde cada processo possui um número identificador.</para>
    </sect1>
    <sect1>
      <title>Arquivos</title>
      <para>Tudo em Unix é tratado como arquivo, incluindo diretórios, que são tipos especiais de arquivos. Todas as comunicações com dispositivos de entrada e saída, incluindo periféricos são realizadas com o envio e/ou recebimento de dados para o arquivo do dispositivo. Por exemplo, todas as comunicações com o acionador de disco flexível de 3,5'' são realizadas através do arquivo <filename class="devicefile">/dev/fd0</filename>, caso o drive A: da máquina seja de 3,5''.</para>
      <para>No Unix, além dos arquivos tradicionalmente conhecidos, existe um outro tipo de arquivo: o <foreignphrase>link</foreignphrase>, que consiste em um apontador para um outro arquivo existente no sistema. Sua natureza será discutida no decorrer deste documento.</para>
      <para>Cada arquivo possui um conjunto de atributos que indicam as classes de usuários que podem visualizá-los ou alterá-los, acrescentando o conceito de privacidade, inexistente no sistema MS-DOS.</para>
    </sect1>
    <sect1>
      <title>Diretórios de usuários</title>
      <para>Cada usuário tem liberdade para atuar dentro de diretórios próprios chamados de <foreignphrase>home_dirs</foreignphrase>. Neste diretório, o usuário tem o direito de criar os seus subdiretórios e arquivos pessoais e atribuir permissões a estes arquivos para que possam ser acessados ou não por determinados grupos de usuários. No <filename class="directory">home_dir</filename> também ficam situados arquivos de configuração e personalização de programas de uso geral dos usuários do sistema.</para>
    </sect1>
    <sect1>
      <title>Usuários do sistema Unix</title>
      <para>Ao contrário de um sistema MS-DOS tradicional, onde todos os usuários podem enxergar, alterar e instalar os arquivos que quiserem ao seu belprazer, no Unix isto não é possível, salvo poucas exceções. Existem dois tipos básicos de usuários: o administrador, também chamado de <foreignphrase>root</foreignphrase> ou superusuário, a quem são irrestritos os privilégios, e o usuário normal, que possui o direito de atuar apenas em diretórios restritos (por exemplo, seu <filename class="directory">home_dir</filename>), não podendo alterar ou afetar arquivos de outros usuários do sistema.</para>
      <para>O administrador de sistemas é responsável, entre outras coisas, pela inclusão ou exclusão de usuários normais, designação de espaço em disco, instalar e configurar novos softwares e hardwares e eliminar eventuais problemas que possam ocorrer nos softwares do sistema. Seus privilégios devem ser protegidos de modo a evitar a intrusão e o uso inapropriado do sistema por usuários mal-intencionados ou inexperientes.</para>
    </sect1>
  </chapter>

  <!-- Conceitos iniciais -->
  <chapter xml:id='cha.conceitos'>
    <title>Conceitos iniciais</title>
    <para>Este capítulo se destina a introduzir os conceitos básicos envolvidos na operação de um ambiente Unix, tais como entrar no sistema, uso de senha e movimentação entre diretórios.</para>
    <sect1>
      <title>Entrada, saída e identificação de usuários</title>
      <para>O sistema Unix, devido à sua característica multi-usuário, necessita de um mecanismo de controle de acesso ao sistema, evitando que alguns usuários manipulem indevidamente o diretório de outros ou até mesmo que pessoas alheias a um sistema tente invadi-lo.</para>
      <para>A identificação do usuário no Unix é feita durante o processo de <foreignphrase>login</foreignphrase> (entrada no sistema). Através de um <foreignphrase>username</foreignphrase>, único para cada pessoa, e de uma senha (<foreignphrase>password</foreignphrase>), de conhecimento único do usuário, o processo de <foreignphrase>login</foreignphrase> verifica se a combinação <foreignphrase>username/password</foreignphrase> é válida. Caso o seja, o processo de <foreignphrase>login</foreignphrase> é terminado e o usuário estará apto a executar comandos no sistema.</para>
      <important>
	<para>A SENHA DEVE SER DE CONHECIMENTO ÚNICO DO USUÁRIO!</para>
      </important>
      <para>O processo de <foreignphrase>login</foreignphrase> funciona com a entrada do <foreignphrase>username</foreignphrase> e da senha pelo usuário, tal como mostram as linhas a seguir:</para>
      <screen>
	maquina login: aluno
	password:
	Last login: Mon Mar 31 12:31:13 from localhost
	Linux 2.0.35.
	maquina:~$ 
      </screen>
      <para>Caso o usuário erre sua senha, uma nova requisição de login é mostrada na tela, possibilitando que a entrada dos dados corretos\footnote{Observe que a password não é mostrada durante o processo de login, para evitar que outros a vejam.}.</para>
      <screen>
	maquina login: aluno
	password:

	login incorrect
	maquina login:
      </screen>
      <para>Um cuidado que deve ser tomado no Unix é com a distinção pelo sistema entre caracteres maiúsculos e minúsculos. Desse modo, a palavra Maria é diferente de MaRIa ou maRia. Portanto, deve-se prestar sempre atenção nos caracteres que são escritos na tela de modo a evitar confusões e transtornos.</para>
    </sect1>
    <sect1>
      <title>Mudança de senha</title>
      <para>É sempre recomendável mudar constantemente a senha. Muitas vezes, quando um usuário acessa o sistema de uma máquina externa ao mesmo, a conexão pode estar sendo monitorada por um terceiro usuário mal intencionado. De posse da sua senha, este usuário poderia, por exemplo, ler suas correspondências pessoais ou, na pior das hipóteses, utilizar a sua conta para fins indevidos.</para>
      <para>A mudança de senha no Unix é feita com o comando <command>passwd</command>. O programa <command>passwd</command> solicita ao usuário que entre com a senha antiga e depois com a nova. Para evitar erros de digitação, a nova senha deve ser repetida, como mostra o exemplo a seguir.</para>
      <screen>
	maquina:~$ passwd
	Changing password for aluno
	Enter old password: 
	Enter new password: 
	Re-type new password: 
	Password changed
	maquina:~$
      </screen>
    </sect1>
    <sect1>
      <title>Executando comandos</title>
      <para>Existem diversas maneiras de executar comandos em Unix. A mais simples é digitar o nome do comando seguido de ENTER. Os comandos também podem ser executados em seqüência, como em</para>
      <screen><prompt>maquina:~$</prompt> <command>ls</command>; pwd; finger aluno; whoami</screen>
      <para>Os comandos podem também ser executados em segundo plano (<foreignphrase>background</foreignphrase>), bastando para isto que o caracter <symbol>&amp;</symbol> seja acrescentado ao final do comando. Com isto, o comando será executado e a linha de comando ficará livre para o usuário executar outros comandos concomitantemente àqueles executados em <foreignphrase>background</foreignphrase>.</para>
      <para>Além disso, os comandos podem ser executados em <foreignphrase>pipeline</foreignphrase>, onde a saída de um programa é lançada na entrada e outro. O <foreignphrase>pipeline</foreignphrase> de comandos é indicado com o caracter <keycap>|</keycap>, como mostra o exemplo a seguir.</para>
      <screen>maquina:~$ ls | grep txt
exemplo1.txt
exemplo2.txt
faq.txt
maquina:~$
      </screen>
      <para>Neste exemplo, a lista de todos os arquivos do diretório <filename class="directory">/home/aluno</filename> é lançada na entrada do comando <command>grep txt</command>, que mostra as linhas que combinam com o padrão 'txt'.</para>
      <para>Os programas executados via linha de comando são interpretados pelas chamadas <foreignphrase>shells</foreignphrase> do sistema, semelhantes ao programa <command>command.com</command> do DOS.</para>
      <para>As <foreignphrase>shells</foreignphrase> do Unix possuem um histórico dos comandos utilizados em uma sessão de login e podem ser visualizados através do comando <command>history</command>. Ao chamar o comando <command>history</command>, é exibida na tela a lista dos últimos comandos executados pelo usuário precedidos do número de ordem do comando e da hora em que cada um foi executado.</para>
      <para>Caso o usuário deseje executar novamente um mesmo comando é necessário apenas chamar na <foreignphrase>shell</foreignphrase> uma referência ao comando desejado com o caracter <keycap>!</keycap>, como mostra o exemplo a seguir, onde o comando de ordem 73 é, no caso, <command>ls</command>.</para>
      <screen>
	maquina:~$ !73
	ls
	documentos/      exemplo2.txt     faq.txt
	exemplo1.txt     financas/        linux1.gif
	maquina:~$
      </screen>
    </sect1>
    <sect1>
      <title>Ajuda <foreignphrase>on-line</foreignphrase></title>
      <para>O Unix possui um conjunto de ferramentas muito poderosas que ajudam o usuário a sanar grande parte de suas dúvidas em relação ao uso de comandos no sistema: as chamadas <foreignphrase>man pages</foreignphrase>. As <foreignphrase>man pages</foreignphrase> são documentos que detalham o uso de cada comando e descrevem os vários parâmetros que podem ser passados aos comandos no momento de sua execução. As <foreignphrase>man pages</foreignphrase> podem ser acessadas pelo uso do comando <command>man</command>, de sintaxe</para>
      <cmdsynopsis>
	<command>man</command>
	<arg choice="opt"><option>opções</option></arg>
	<arg choice="opt"><option>seção</option></arg>
	<arg choice="req">nome_do_comando</arg>
      </cmdsynopsis>
      <para>onde:</para>
      <glosslist>
	<glossentry>
	  <glossterm>opções</glossterm>
	  <glossdef>
	    <para>conjuntos de opções que podem ser passadas ao comando <command>man</command></para>
	  </glossdef>
	</glossentry>
	<glossentry>
	  <glossterm>section</glossterm>
	  <glossdef>
	    <para>seção do manual que o usuário deseja visualizar.</para>
	  </glossdef>
	</glossentry>
      </glosslist>
      <para>Exemplo de utilização do comando <command>man</command>:</para>
      <screen>
	maquina:~$ man man 
      </screen>
      <para>Neste exemplo, o sistema fornece informações ao usuário sobre o uso do comando <command>man</command>. A navegação dentro da página do manual pode ser feita com as setas do teclado. Para sair do navegador, basta digitar a tecla <keycap>q</keycap> (quit). </para>
      <para>É comum encontrar no Unix referência a comandos expressa sob a forma <command>man (1)</command>, por exemplo. Esta notação indica que a documentação do comando referenciado encontra-se localizada na seção 1 das páginas do manual.</para> 
    </sect1>
    <sect1>
      <title>Identificando usuários</title>
      <para>Muitas vezes é conveniente saber a lista de usuários logados em uma determinada máquina, ou em um terminal. Isto pode ser feito através de dois comandos no Unix: <command>who</command> e <command>whoami</command>.</para>
      <para>O comando <command>who</command> exibe a lista de usuários logados numa estação.</para>
      <screen>
	maquina:~$ who
	aluno     tty0    Feb  4 11:52 (:0.0)
	maquina:~$
      </screen>
      <para>O comando <command>whoami</command>, por sua vez, exibe o login do usuário que está logado no terminal onde o comando whoami foi executado.</para>
      <screen>
	maquina:~$ whoami
	aluno
	maquina:~$ 
      </screen>
      <para>Os comandos <command>who</command> e <command>whoami</command>, entretanto, não mostram muitas informações sobre os usuários que estão em uma máquina. Informações mais detalhadas sobre o usuário podem ser obtidas utilizando o comando <command>finger</command>, cujo uso é simples, bastando apenas executar o comando seguido do nome do usuário, como mostra o exemplo a seguir.</para>
      <screen>
	maquina:~$ finger aluno
	Login: aluno                             Name: aluno 
	Directory: /home/aluno                   Shell: /bin/bash
	Last login Tue Feb  4 14:09 (EDT) on tty0 from localhost
	No mail.
	No Plan.
	maquina:~$
      </screen>
      <para>Caso a informação procurada seja de um usuário não pertencente ao grupo local, pode-se acrescentar no parâmetro do finger o nome do domínio ou máquina onde o usuário possui a sua conta, como em <command>finger joao@engcomp.ufrn.br</command>.</para>
    </sect1>
    <sect1>
      <title>Saindo do sistema</title>
      <para>No Unix, as sessões de <command>login</command> no sistema iniciadas pelo usuário são finalizadas através do comando <command>logout</command>, como mostra o exemplo a seguir.</para>
      <screen>
	maquina:~$ logout

	Welcome to Linux 2.2.14.
	maquina login:
      </screen>
    </sect1>
  </chapter>

  <!-- Capitulo 2 - Arquivos e Diretórios no Unix -->

  <chapter xml:id='cha.arquivos'>
    <title>Arquivos e Diretórios no Unix</title>
    <para>Neste capítulo, serão discutidas as tarefas básicas de manipulação de diretórios e arquivos no Unix.</para>    

    <sect1>
      <title>Manipulação de diretórios</title>
      <para>Do mesmo modo que em outros sistemas operacionais, os diretórios no Unix são organizados numa estrutura de árvore. </para>
      <para>A mudança entre os diretórios é feita através do comando <command>cd</command>, cuja sintaxe é:</para>
      <cmdsynopsis>
	<command>cd</command>
	<arg>nome_do_diretório</arg>
      </cmdsynopsis>
      
      <para>O exemplo abaixo mostra o usuário aluno se deslocando para o diretório <filename class="directory">/usr/bin</filename>.</para>
      <example xml:id="exemplo-uso-cd">
	<title>Uso do comando cd.</title>
	<screen>
	  maquina:~$ cd /usr/bin
	  maquina:/usr/bin$ cd 
	  maquina:~$
	</screen>
      </example>
      <para>Quando o comando é executado sem argumento, o sistema desloca o usuário para o seu diretório pessoal (<foreignphrase>home dir</foreignphrase>). Quando executado da forma <command>cd ~usuario</command> o deslocamento se dá para o diretório pessoal usuário especificado, obtendo-se o mesmo efeito que o do comando <command>cd /home/usuario</command>.</para>
      <para> A referência a todos os diretórios é absoluta na raiz da árvore de diretórios, como em <filename class="directory">/home/aluno</filename>. A referência relativa pode ser feita em relação a dois arquivos existentes dentro de cada diretório do sistema, que são:</para>
      <glosslist>
	<glossentry>
	  <glossterm>../</glossterm>
	  <glossdef>
	    <para>referência ao diretório pai do diretório corrente.</para>
	  </glossdef>
	</glossentry>
	<glossentry>
	  <glossterm>./</glossterm>
	  <glossdef>
	    <para>referência ao diretório corrente.</para>
	  </glossdef>
	</glossentry>
      </glosslist>
      <para>A identificação do diretório corrente é feita através do comando <command>pwd</command> (<foreignphrase>present work directory</foreignphrase>), cuja sintaxe é mostrada no exemplo a seguir.</para>
      <screen>
	maquina:~$ pwd
	/home/aluno 
	maquina:~$
      </screen>
      <para>A visualização do conteúdo de um diretório é feita com o comando {\bf ls}, de sintaxe</para>
      <cmdsynopsis>
	<command>ls</command>
	<arg choice="opt">opções</arg>
	<arg choice="opt">arquivo1 <arg choice="opt">arquivo2</arg> ...</arg>
      </cmdsynopsis>
      <example>
	<title>Exemplo de uso do comando <command>ls</command>.</title>
	<screen>
	  maquina:~$ ls
	  documentos/      exemplo2.txt     faq.txt
	  exemplo1.txt     financas/        linux1.gif
	  maquina:~$
	</screen>
      </example>
      <para>Como pode ser notado, o comando <command>ls</command> quando executado sem opções não mostra muita informação sobre os arquivos do diretório, apenas os seus nomes. As opções mais comuns que podem ser utilizadas para enriquecer a saída do comando <command>ls</command> são:</para>
      <glosslist>
	<glossentry>
	  <glossterm>-l</glossterm>
	  <glossdef>
	    <para>listagem longa</para>
	  </glossdef>
	</glossentry>
	<glossentry>
	  <glossterm>-a</glossterm>
	  <glossdef>
	    <para>listagem de todos os arquivos, inclusive arquivos ocultos.</para>
	  </glossdef>
	</glossentry>
      </glosslist>
      <example xml:id="exemplo-ls-2">
	<title>Exemplo de uso do comando <command>ls</command></title>
	<screen>
	  maquina:~$ ls -la 
	  total 121
	  drwxr-xr-x   4 aluno    users        1024 Mar 31 13:27 ./
	  drwxr-xr-x   7 root     root         1024 Mar 31 12:53 ../
	  -rw-r--r--   1 aluno    users          26 Mar 31 13:08 .bash_history
	  -rw-r--r--   1 aluno    users          34 Nov 23  1993 .less
	  -rw-r--r--   1 aluno    users         114 Nov 23  1993 .lessrc
	  drwxr-xr-x   2 aluno    users        1024 Mar 31 13:15 documentos/
	  -rw-r--r--   1 aluno    users          43 Mar 31 12:58 exemplo1.txt
	  -rw-r--r--   1 aluno    users          41 Mar 31 12:58 exemplo2.txt
	  drwxr-xr-x   2 aluno    users        1024 Mar 31 13:28 financas/
	  -rw-r--r--   1 aluno    users      108111 Mar 31 13:00 faq.txt
	  -rw-r--r--   1 aluno    users        5041 Mar 31 12:58 linux1.gif
	  maquina:~$ 
	</screen>
      </example>
      <!--/sect1-->
      <sect2>
	<title>Permissões de arquivos</title>
	<para>Como pôde ser visto no exemplo <xref linkend="exemplo-ls-2"/>, a listagem longa mostra uma série de atributos relacionados a cada arquivo existente em um diretório. Entre estes atributos, a primeira seqüência de caracteres é dividida em três subseqüências que definem as permissões dadas pelo usuário aos seus arquivos arquivo, de acordo com a classificação de cada usuário. As atribuições de cada subseqüência são mostradas na Figura <xref linkend="figura-permissoes-arquivos"/>.</para>
	<figure xml:id="figura-permissoes-arquivos">
	  <title>Atributos de permissão de arquivo</title>
	  <mediaobject>
	    <imageobject role="html">
	      <!--\includegraphics[width=\linewidth]{permissoes.pdf}-->
	      <imagedata format="SVG" fileref="figuras/permissoes.svg"/>
	    </imageobject>
	  </mediaobject>
	</figure>
	

	<para>A mudança das permissões de uma arquivo é feita com o comando <command>chmod</command>, de sintaxe 
	<command>chmod modo arquivo</command>.</para>

	<para>O <command>modo</command> define as permissões do arquivo, sendo os mais comuns são formados por uma combinação das letras 'ugoa', referentes os usuários, e 'rwx', referentes ao tipo de permissão, ligadas pelos caracteres '+' ou '-'. As permissões do usuário são 'u', para o proprietário do arquivo, 'g', para o grupo a que pertence, 'o', para outros usuários e 'a'(all), para todo os usuários. Os tipos de permissão são 'r', para leitura, 'w', para escrita, e 'x', para execução.</para>
	<example xml:id='exemplo-chmod'>
	  <title>Exemplo de uso do comando <command>chmod</command></title>
	  <screen>
	    maquina:~$ chmod [go]-[rw] exemplo1.txt
	    maquina:~$ 
	  </screen>
	</example>
      </sect2>

      <sect2>
	<title>Criando e destruindo diretórios </title>
	<para>Os comandos para criar e apagar diretórios no Unix são <command>mkdir</command> e <command>rmdir</command>, respectivamente. As sintaxes destes comandos são:</para>

	<cmdsynopsis>
	  <command>mkdir</command>            <!-- TEM QUE VER A SINTAXE -->
	  <arg>diretório</arg>
	  <arg>...</arg>
	  <command>rmdir</command>
	  <arg>diretório</arg>
	  <arg>...</arg>
	</cmdsynopsis>

	<glosslist>
	  <glossentry>
	    <glossterm>1. criando o diretório <filename class="directory">curso</filename></glossterm>
	    <glossdef>
	      <screen>
		maquina:~$ pwd
		/home/aluno
		maquina:~$ mkdir curso
		maquina:~$ cd curso
		maquina:~/curso$ pwd
		/home/aluno/curso
		maquina:~/curso$
	      </screen>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm>2. removendo o diretório <filename class="directory">curso</filename> </glossterm>
	    <glossdef>
	      <screen>
		maquina:~$ pwd
		/home/aluno/curso
		maquina:~$ cd ..
		maquina:~$ rmdir curso
		maquina:~$ cd curso
		bash: curso: No such file or directory
		maquina:~$
	      </screen>
	    </glossdef>
	  </glossentry>
	</glosslist>

	<para>Lembrete: para que um diretório possa ser removido, é necessário que o mesmo esteja vazio.</para>

      </sect2>
      <!--/chapter-->
    </sect1>

    <!-- Manipulação de arquivos -->

    <!--chapter xml:id='cha.manipulacao'-->
    <sect1>
      <title>Manipulação de arquivos </title>
      <sect2>
	<title>Criando e listando arquivos </title>
	
	<para>Diversas são as maneiras de se criar um arquivo no Unix, seja através de um editor de textos, seja pelo produto da compilação de um programa ou por quaisquer outras alternativas. A mais simples delas é utilizando o comando <command>touch</command>.</para>    
	<para>O <command>touch</command> é geralmente utilizado para atualizar a hora e a data de um determinado arquivo e caso este arquivo não exista, ele será criado pelo <command>touch</command>, porém sem conteúdo algum. A sua sintaxe do comando touch é:</para>
	<cmdsynopsis>
	  <command>touch</command>            
	  <arg>arquivo</arg>
	</cmdsynopsis>

	<example xml:id='exemplo-touch'>
	  <title>Exemplo de uso do comando <command>touch</command></title>
	  <screen>
	    maquina:~$ ls
	    documentos/      exemplo2.txt     faq.txt  mail/
	    exemplo1.txt     financas/        linux1.gif
	    maquina:~$ touch teste.txt
	    maquina:~$ ls
	    documentos/      exemplo2.txt     faq.txt  mail/
	    exemplo1.txt     financas/        linux1.gif       teste.txt
	    maquina:~$
	  </screen>
	</example>

	<para>Para visualizaçao do conteúdo de um arquivo pode ser feita de diversas formas, sendo a mais simples através do comando <command>cat</command>, como exemplificado a seguir.</para>

	<example xml:id='exemplo-cat'>
	  <title>Exemplo de uso do comando <command>cat</command></title>
	  <screen>
	    maquina:~$ cat exemplo1.txt
	    exemplo de arquivo no linux: exemplo1.txt 
	    maquina:~$ 
	  </screen>
	</example>

	<para>Se um arquivo for muito grande, comando <command>cat</command> não conseguirá mostrar o seu conteúdo inteiro na tela, caso o número de linhas do linhas do console não seja suficiente. Para contornar esta situação, o comando <command>more</command> pode ser utilizado, pois além de exibir o conteúdo do arquivo, realiza uma parada cada vez que uma tela é preenchida.</para>
      </sect2>

      <sect2>
	<title>Copiando, movendo e removendo arquivos</title>

	<para> O comando <command>cp</command> permite ao usuário realizar cópias de arquivos ou diretórios. A sintaxe do comando <command>cp</command> é:</para>

	<cmdsynopsis>
	  <command>cp</command>            
	  <arg>-r</arg>
	  <arg>fonte destino</arg>
	</cmdsynopsis>
	
	<example xml:id='exemplo-cp'>
	  <title>Exemplo de uso do comando <command>cp</command></title>
	  <screen>
	    maquina:~/financas$ ls
	    balanco.txt
	    maquina:~/financas$ cp balanco.txt balanco.copia
	    maquina:~/financas$ ls
	    balanco.txt   balanco.copia
	    maquina:~/financas$ 
	  </screen>
	</example>

	<para>Quando utilizado com a opção <prompt>'-r'</prompt>, o comando <command>cp</command> realiza a cópia recursiva de diretórios é realizada, semelhante ao <command>xcopy</command> do MS-DOS.</para>
	
	<para>Muitas vezes, ao invés de copiar um arquivo para outro lugar, é necessário renomeá-lo ou movê-lo na árvore de diretórios. Ambas estas tarefas são executadas através do comando <command>mv</command>, que faz a mudança de nome dos arquivos. Em Unix, mover um arquivo (inclusive diretórios) de um lugar para outro significa apenas alterar o seu nome. A sintaxe do comando <command>mv</command> é:</para>

	<cmdsynopsis>
	  <command>mv</command>            
	  <arg>opções</arg>
	  <arg>fonte</arg>
	  <arg>destino</arg>
	</cmdsynopsis>

	<example xml:id='exemplo-mv'>
	  <title>Exemplo de uso do comando <command>mv</command></title>
	  <screen>
	    maquina:~$ ls
	    documentos/      exemplo2.txt     faq.txt  mail/
	    exemplo1.txt     financas/        linux1.gif       teste.txt
	    maquina:~$ mv teste.txt financas
	    maquina:~$ cd financas
	    maquina:~$ ls
	    balanco.txt   balanco.copia    teste.txt
	    maquina:~$ mv teste.txt teste.move
	    maquina:~$ ls
	    balanco.txt   balanco.copia    teste.move
	    maquina:~$
	  </screen>
	</example>

	<para> A remoção de arquivos, por sua vez, é feita através do comando <command>rm</command>, como mostra o exemplo a seguir, onde o arquivo  <filename class="directory">exemplo2.txt</filename> é apagado.</para>

	<example xml:id='exemplo-rm'>
	  <title>Exemplo de uso do comando <command>rm</command></title>
	  <screen>
	    maquina:~$ ls
	    documentos/      exemplo2.txt     faq.txt
	    exemplo1.txt     financas/        linux1.gif
	    maquina:~$ rm exemplo2.txt
	    maquina:~$ ls
	    documentos/      financas/        linux1.gif
	    exemplo1.txt     faq.txt
	    maquina:~$ 	
	  </screen>
	</example>

	<para>Deve ser tomado muito cuidado no do comando <command>rm</command>, pois uma vez excluído um arquivo, o mesmo não poderá ser recuperado (ao contrário do sistema MS-DOS). Um comando da forma <prompt>'rm *'</prompt> (utilizando o coringa "*") destrói todos os arquivos do diretório corrente. Por isto, é muitas vezes recomendável utilizar o comando <command>rm</command> com a opção <prompt>'-i'</prompt>, que força o usuário a confirmar cada remoção de arquivo.</para>

	<para>O comando <command>rm</command> também pode ser utilizado de forma semelhante ao comando <command>deltree</command> do MS-DOS, bastando para isto executá-lo com a opção <prompt>'-r'</prompt>. Com isto, todos os arquivos contidos em uma árvore de diretório serão apagados, começando dos mais profundos até apagar o próprio diretório.</para>

      </sect2>

      <sect2>
	<title>Procurando coisas no Unix</title>
	
	<para>Eventualmente é necessário procurar alguma informação dentro de um arquivo ou até mesmo, saber onde um determinado arquivo se encontra dentro da árvore de diretórios.</para>
	<para> Um dos comandos mais úteis dentro do Unix é o <command>grep</command>, cuja utilidade é procurar caracteres dentro de um arquivo de texto. Sempre que o caracter passado como argumento para <foreignphrase>matching</foreignphrase> é encontrado em uma linha do arquivo, a mesma é enviada para a saída do programa. A sintaxe do comando <command>grep</command> é da forma:</para>

	<cmdsynopsis>
	  <command>grep</command>
	  <arg>cadeia_de_caracteres</arg>
	  <arg>arquivos</arg>
	</cmdsynopsis>

	<para>e a maneira mais simples de utilizar o <command>grep</command> é como mostra o exemplo a seguir.</para>

	<example xml:id='exemplo-grep'>
	  <title>Exemplo de uso do comando <command>grep</command></title>
	  <screen>
	    maquina:~/documentos$ cat teste.txt
	    Exemplo de um arquivo em Linux
	    que mostra a utilidade do
	    programa grep.
	    maquina:~/documentos$ grep utilidade teste.txt
	    que mostra a utilidade do
	    maquina:~/documentos$ 
	  </screen>
	</example>

	<para>Outro comando bastante útil é o <command>find</command>. Ele funciona procurando recursivamente um arquivo dentro de um diretório, obedecendo um critério de busca. Caso o arquivo seja encontrado, uma ação definida pelo usuário é executada. Sua sintaxe é:</para>

	<cmdsynopsis>
	  <command>find</command>
	  <arg>diretório</arg>
	  <arg>critério_de_busca</arg>
	  <arg>ação</arg>
	</cmdsynopsis>

	<example xml:id='exemplo-find'>      
	  <title>Exemplo de uso do comando <command>find</command></title>
	  <screen>
	    maquina:~$ find /home -name balanco.txt -print
	    /home/aluno/financas/balanco.txt
	    maquina:~$
	  </screen>
	</example>

	<para>Neste exemplo, o diretório inicial de busca foi <prompt>/home</prompt>, o critério de procura foi <prompt>-name balanco.txt</prompt> e a ação <prompt>-print</prompt>, indicando que nome absoluto do arquivo deveria ser mostrado quando o mesmo fosse encontrado. </para>
      </sect2>

      <sect2>
	<title>Ordenando o conteúdo de um arquivo</title>

	<para>O comando <command>sort</command> possibilita que as linha de um arquivo possam ser ordenadas de acordo com um conjunto de opções indicadas. Sua sintaxe é dada por:</para>

	<cmdsynopsis>
	  <command>sort </command>
	  <arg>-dfn</arg>
	  <arg>[arquivo1 [...]</arg>
	</cmdsynopsis>

	<para>onde:</para>

	<glosslist>
	  <glossentry>
	    <glossterm><prompt>[d]</prompt></glossterm>
	    <glossdef>
	      <para>indica que apenas letras e dígitos importam na ordenação;</para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm><prompt>[f]</prompt></glossterm>
	    <glossdef>
	      <para>ignora a diferença entre maiúsculas e minúsculas;</para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm><prompt>[n]</prompt></glossterm>
	    <glossdef>
	      <para>faz a ordenação numérica do arquivo.</para>
	    </glossdef>
	  </glossentry>

	</glosslist>

	<example xml:id='exemplo-sort'>      
	  <title>Exemplo de uso do comando <command>sort</command></title>
	  <screen>
	    maquina:~$ 
	    maquina:~$ cat ordena.txt 
	    0.001 primeiro 
	    23.42 segundo 
	    2.342 terceiro 
	    4.03  quarto 
	    maquina:~$ sort ordena.txt 
	    0.001 primeiro 
	    2.342 terceiro 
	    23.42 segundo 
	    4.03  quarto 
	    maquina:~$ sort -n ordena.txt 
	    0.001 primeiro 
	    2.342 terceiro 
	    4.03  quarto 
	    23.42 segundo 
	    maquina:~$ 
	  </screen>
	</example>
	
      </sect2>

      <sect2>
	<title><command><foreignphrase>Links</foreignphrase></command></title>

	<para>O sistema de arquivos do Unix, implementa o conceito de <foreignphrase>link</foreignphrase>. No Unix, criar um <foreignphrase>link</foreignphrase> significa apenas em adicionar um entrada na tabela de diretórios que aponta para uma área no disco rígido.</para> 

	<para>Existem dois tipos de links no Unix: o físico (<foreignphrase>hard link</foreignphrase>) e o simbólico (<foreignphrase> symbolic link</foreignphrase>).</para>

	<para> Cada vez que um <foreignphrase>hard link</foreignphrase> é criado, o contador com número de pontos de link que apontam para a relativa área de disco é incrementado. Quando um <foreignphrase>hard link</foreignphrase> é destruído (por exemplo, durante a remoção de um arquivo), o contador para a área de disco correspondente ao mesmo é decrementada e, quando o mesmo chega a zero, o <foreignphrase>kernel</foreignphrase> desaloca a área de disco para ser utilizada para outros fins. <foreignphrase>Hard links</foreignphrase> não podem apontar para diretórios ou arquivos inexistentes no sistema.</para>

	<para>O <foreignphrase>symbolic link</foreignphrase>, por sua vez, é um arquivo que contém o nome de um arquivo no seu corpo. Cada vez que o kernel encontra um <foreignphrase>symbolic link</foreignphrase>, ele substitui o nome do link pelo seu conteúdo e continua a interpretação do arquivo, até encontrar um <foreignphrase>hard link</foreignphrase>. <foreignphrase>Symbolic links</foreignphrase> podem apontar para quaisquer tipos de arquivos, inclusive inexistentes.</para>

	<para><foreignphrase> Links</foreignphrase> podem ser criados no Unix através do comando <command>ln</command>, cuja sintaxe é:</para>

	<cmdsynopsis>
	  <command>ln</command>
	  <arg>opções</arg>
	  <arg>fonte</arg>
	  <arg>destino</arg>
	</cmdsynopsis>

	<example xml:id='exemplo-link'>      
	  <title>Exemplo de criação de <foreignphrase>hard link</foreignphrase> e <foreignphrase>symbolic link</foreignphrase>:</title>
	  <para><foreignphrase>Hard link</foreignphrase>:</para>
	  <screen>
	    maquina:~$ ls -la
	    maquina:~/financas$ ls -la
	    total 3
	    drwxr-xr-x   2 aluno     users        1024 Feb  6 06:31 ./
	    drwxr-xr-x   4 aluno     users        1024 Feb  5 13:53 ../
	    -rw-r--r--   1 aluno     users          20 Feb  5 14:52 balanco.txt
	    maquina:~/financas$ ln balanco.txt hard
	    maquina:~/financas$ ls -la
	    total 4
	    drwxr-xr-x   2 aluno     users        1024 Feb  6 06:32 ./
	    drwxr-xr-x   4 aluno     users        1024 Feb  5 13:53 ../
	    -rw-r--r--   2 aluno     users          20 Feb  5 14:52 balanco.txt
	    -rw-r--r--   2 aluno     users          20 Feb  5 14:52 hard
	  </screen>

	  <para><foreignphrase>Symbolic link</foreignphrase>:</para>
	  <screen>
	    maquina:~/financas$ ls -la
	    total 4
	    drwxr-xr-x   2 aluno     user       1024 Feb  6 06:32 ./
	    drwxr-xr-x   3 aluno     users      1024 Feb  5 13:53 ../
	    -rw-r--r--   2 aluno     users        20 Feb  5 14:52 balanco.txt
	    -rw-r--r--   2 aluno     users        20 Feb  5 14:52 hard
	    maquina:~/financas$ ln -s balanco.txt soft
	    maquina:~/financas$ ls -la
	    drwxr-xr-x   2 aluno     users      1024 Feb  6 06:40 ./
	    drwxr-xr-x   3 aluno     users      1024 Feb  5 13:53 ../
	    -rw-r--r--   2 aluno     users        20 Feb  5 14:52 balanco.txt
	    -rw-r--r--   2 aluno     users        20 Feb  5 14:52 hard
	    lrwxrwxrwx   1 aluno     users         7 Feb  6 06:40 soft -> balanco.txt
	    maquina:~/financas$
	  </screen>
	</example>

	<para>Como pode ser visto, o <foreignphrase>hard link</foreignphrase> de nome <prompt>hard</prompt> é apenas mais um apontador para a área de disco previamente apontada por <filename class="directory">balanco.txt</filename>. Caso a entrada  <filename class="directory">balanco.txt</filename> seja removida da tabela de diretório, o conteúdo do arquivo para onde tal entrada apontava ainda continuará existindo, visto que a entrada <prompt>hard</prompt> ainda continua apontando para lá.</para>
      </sect2>

      <sect2>
	<title>Imprimindo arquivos</title>

	<para>Os serviços de impressão podem ser utilizados através do comando <command>lpr</command>. Ao chamar este comando, um serviço de impressão dos arquivos especificados é iniciado.</para>
	<para> A sintaxe do comando <command>lpr</command> é:</para>

	<cmdsynopsis>
	  <command>lpr</command>
	  <arg>-Pprinter</arg>
	  <arg>-$num</arg>
	  <arg>-C class</arg>
	  <arg>-J job</arg>
	  <arg>-T tittle</arg>
	  <arg>-U user</arg>
	  <arg>-i[numcols]</arg>
	  <arg>-1234 font</arg>
	  <arg>-wnum</arg>
	  <arg>-cdfghlnmprstv</arg>
	  <arg>name ...</arg>	
	</cmdsynopsis>

	<para>As opções mais utilizadas deste comando são:</para>

	<glosslist>
	  <glossentry>
	    <glossterm><prompt>[-P]</prompt></glossterm>
	    <glossdef>
	      <para>identifica a impressora que imprimirá o arquivo.</para>
	    </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm><prompt>[-$num]</prompt></glossterm>
	    <glossdef>
	      <para>define o número de cópias que deverão ser impressas.</para>
	    </glossdef>
	  </glossentry>
	</glosslist>

	<para>Os dois exemplos a seguir ilustram o uso do comando <command>lpr</command>.</para>

	<example xml:id='exemplo-lpr'>      
	  <title>Exemplo de uso do comando <command>lpr</command></title>
	  <screen>
	    maquina:~/financas$ lpr -Plaser teste.ps
	    maquina:~/financas$ lpr -$3 cap1.tex
	  </screen>
	</example>

	<para>No primeiro caso, o arquivo  <filename class="directory">teste.ps</filename> foi enviado para a fila de impressão da impressora de nome <prompt>laser</prompt>, enquanto que no segundo são impressas três cópias do arquivo <filename class="directory">cap1.tex</filename> para a impressora default do sistema.</para>

      </sect2>

      <sect2>
	<title>Arquivando e compactando arquivos</title>
	
	<para>Memórias de massa são dispositivos utilizados em praticamente toda máquina que comporta um sistema operacional. Muitas vezes, entretanto, devido às limitações do meio de armazenamento, arquivos muito grandes não podem ser escritos neste meio, como no caso de discos flexíveis de 3,5". Neste contexto, os chamados <foreignphrase>compactadores de arquivos</foreignphrase> tornam-se bons aliados na redução do tamanho de arquivos extensos.</para>

	<para> Além disso, é frequentemente necessário realizar tranferências de dados entre duas estações de trabalho ou realizar <foreignphrase>backups</foreignphrase> dos conjuntos de arquivos das máquinas de um determinado sistema.</para>  

	<para>Duas ferramentas bastante úteis no Unix e que atendem a estas necessidades são os programas <command>tar</command> e <command>gzip</command>.</para>
	
	<!--/sect1-->

	<sect3>
	  <title>O comando tar</title>

	  <para>O <command>tar</command> funciona como um arquivador, tranferindo conjuntos de arquivos para um determinado arquivo de destino, seja este último um arquivo comum ou um  <foreignphrase>driver</foreignphrase> de um periférico (disco flexível, fita magnética etc).</para>

	  <para>Sintaxe do comando <command>tar</command>:</para>

	  <cmdsynopsis>
	    <command>tar</command>
	    <arg>opções</arg>
	    <arg>arquivo1</arg>
	    <arg>arquivo2[...]</arg>
	  </cmdsynopsis>

	  <para>Onde <command>[opções]</command> é uma lista de opções para o <command>tar</command>, e <command>arquivo1 [arquivo2[...]]</command> são os arquivos a serem manipulados no arquivamento.</para>

	  <example xml:id='exemplo-tar'>      
	    <title>Exemplo de uso do comando <command>tar</command></title>
	    <screen>
	      maquina:~$ tar cvf backup.tar .
	      ./
	      .less
	      .lessrc
	      exemplo1.txt
	      tar: backup.tar is the archive; not dumped
	      linux1.gif
	      .bash_history
	      faq.txt
	      documentos/
	      documentos/teste.txt
	      financas/
	      financas/balanco.txt
	      financas/hard
	      financas/soft
	      maquina:~$
	    </screen>
	  </example>
	  
	  <para>Neste exemplo, os arquivos existentes no diretório <filename class="directory">/home/aluno/figs</filename> são arquivados no arquivo <filename class="directory">backup.tar</filename>. Como pode ser observados, três argumentos são passados ao comando <command>tar</command>. O primeiro deles é <command>cvf</command>. O "c" indica que o usuário deseja criar um novo arquivo. O "v" sinaliza o modo <foreignphrase>"verbose"</foreignphrase>, que mostra na tela os nomes dos arquivos enquanto são arquivados. O "f" indica que o argumento segundo argumento,<filename class="directory">backup.tar</filename>, é o nome do destino a ser criado. O último argumento, por sua vez, é o diretório que se deseja arquivar.</para>

	  <para>Caso o usuário deseje extrair o conteúdo do arquivo <filename class='directory'> backup.tar</filename>, basta executar o comando <prompt>tar xvf backup.tar</prompt> que os arquivos ali armazenados serão extraídos para o diretório corrente. No exemplo a seguir, o conteúdo do arquivo <filename class='directory'> backup.tar</filename> é extraído no diretório backup.</para>

	  <example xml:id='exemplo-tar2'>      
	    <title>Exemplo de uso do comando <command>tar</command></title>
	    <screen>
	      maquina:~$ mkdir backup
	      maquina:~$ cp backup.tar backup
	      maquina:~$ rm backup.tar
	      maquina:~$ cd backup
	      maquina:~/backup$ ls -l
	      total 131
	      -rw-r--r--   1 aluno    users      133120 Mar 31 14:08 backup.tar
	      maquina:~/backup$ tar xvf backup.tar
	      ./
	      .less
	      .lessrc
	      exemplo1.txt
	      linux1.gif
	      .bash_history
	      faq.txt
	      documentos/
	      documentos/teste.txt
	      financas/
	      financas/balanco.txt
	      financas/hard
	      financas/soft
	      maquina:~/backup$ ls -la
	      total 251
	      drwxr-xr-x   4 aluno    users        1024 Mar 31 14:05 ./
	      drwxr-xr-x   5 aluno    users        1024 Mar 31 14:12 ../
	      -rw-r--r--   1 aluno    users          26 Mar 31 13:08 .bash_history
	      -rw-r--r--   1 aluno    users          34 Nov 23  1993 .less
	      -rw-r--r--   1 aluno    users         114 Nov 23  1993 .lessrc
	      -rw-r--r--   1 aluno    users      133120 Mar 31 14:12 backup.tar
	      drwxr-xr-x   2 aluno    users        1024 Mar 31 13:43 documentos/
	      -rw-r--r--   1 aluno    users          43 Mar 31 12:58 exemplo1.txt
	      drwxr-xr-x   2 aluno    users        1024 Mar 31 13:58 financas/
	      -rw-r--r--   1 aluno    users      108111 Mar 31 13:00 faq.txt
	      -rw-r--r--   1 aluno    users        5041 Mar 31 12:58 linux1.gif
	      maquina:~/backup$
	    </screen>
	  </example>
	  
	  <para>O comando <command>tar</command> também pode ser utilizado para enviar o arquivo <filename class='directory'>backup.tar</filename> para um periférico do sistema, tal como uma unidade de disco flexível de 3,5". Neste caso, se o usuário executar o comando</para>

	  <screen>
	    maquina:~$ tar cvf /dev/fd0 backup.tar
	  </screen>


	  <para>O arquivo <filename class='directory'>backup.tar</filename> será enviado para o drive A: da máquina. O procedimento para enviar arquivos para outros periféricos também é semelhante, bastando apenas utilizar o nome correto do driver do dispositivo.</para>

	</sect3>

	<sect3>
	  <title>O comando gzip</title>
	  
	  <para>Apesar de sua versatilidade, o comando <command>tar</command> não realiza a compressão dos arquivos durante o arquivamento. Assim, dois arquivos de 500kb cada um ocuparão um espaco em disco de 1Mb após o arquivamento.</para>

	  <para>Entretanto, o comando <command>gzip</command> pode ser utilizado como uma ferramenta de compressão de arquivos no Unix. Seu uso é simples, como mostra a sintaxe a seguir:</para>

	  <cmdsynopsis>
	    <command>gzip</command>
	    <arg>opções</arg>
	    <arg>-S suffix</arg>
	    <arg>arquivo1 [...]</arg>
	  </cmdsynopsis>

	  <example xml:id='exemplo-gzip'>      
	    <title>Exemplo de utilização do comando <command>gzip</command></title>
	    <screen>
	      maquina:~$ gzip backup.tar
	      maquina:~$ gzip -d backup.tar.gz
	    </screen>
	  </example>
	  
	  <para>No primeiro caso, o comando <command>gzip</command> compactou o arquivo <filename class='directory'>backup.tar</filename>, criando o arquivo <filename class='directory'>backup.tar.gz</filename> (".gz" é a extensão <foreignphrase>default</foreignphrase> do gzip). No segundo caso, o arquivo <filename class='directory'>backup.tar.gz</filename> foi descompactado utilizando a opção "-d". O usuário também pode utilizar o comando <command>gunzip</command> (equivalente à opção "-d") para descompactar um arquivo.</para>

	  <para>Para arquivar e compactar um conjunto de arquivos, o usuário pode utilizar o comando <command>tar</command> com a opção "z" incluída, como mostra o exemplo a seguir.</para>

	  <screen>
	    maquina:~$ tar czvf backup.tar.gz /home/aluno/financas
	  </screen>

	  <para>Assim o conteúdo do diretório <filename class='directory'>/home/aluno/financas</filename> será arquivado e automaticamente compactado no arquivo <filename class='direcotory'> backup.tar.gz</filename>.</para>
	  
	</sect3>

      </sect2>
      
      <sect2>
	<title>Utilizando o conjunto de ferramentas <command>mtools</command></title>

	<para>No Unix existe um conjunto de ferramentas que permitem ao usuário manipular arquivos em discos flexíveis no formato MS-DOS. Dentre as mais utilizadas, podem ser encontradas as seguintes:</para>

	<glosslist>

	  <glossentry>
	    <glossterm><command>mcd [diretorio]</command></glossterm>
	    <glossdef>
	      <para>Muda o diretório corrente da unidade especificada.</para>
	    </glossdef>
	  </glossentry>

	  <glossentry>
	    <glossterm><command>mcopy fonte [destino]</command></glossterm>
	    <glossdef>
	      <para>Copia arquivo especificado em <prompt>fonte</prompt> para a localização de <prompt>destino</prompt>. Caso o destino não seja especificado, o diretório corrente é assumido. Exemplo: <prompt>mcopy exemplo1.txt a:</prompt></para>
	    </glossdef>
	  </glossentry>

	  <glossentry>
	    <glossterm><command>mdel arquivo</command></glossterm>
	    <glossdef>
	      <para>Remove o arquivo especificado do disco.</para>
	    </glossdef>
	  </glossentry>

	  <glossentry>
	    <glossterm><command>mdir [drive] [arquivos]</command></glossterm>
	    <glossdef>
	      <para>Exibe o conteúdo do diretório corrente do drive especificado ou lista os arquivos citados como argumentos.</para>
	    </glossdef>
	  </glossentry>

	  <glossentry>
	    <glossterm><command>mformat drive</command></glossterm>
	    <glossdef>
	      <para>Formata o drive especificado no padrão MS-DOS.</para>
	    </glossdef>
	  </glossentry>

	  <glossentry>
	    <glossterm><command>mmkdir diretorio</command></glossterm>
	    <glossdef>
	      <para>Cria um diretório no sistema de arquivo MS-DOS.</para>
	    </glossdef>
	  </glossentry>

	</glosslist>

	<para>Em todos os comandos, quando o nome drive não é especificado (como em a: ou b: ), é assumido que as transações serão efetuadas no drive a: .</para>

      </sect2>
    </sect1>
  </chapter>

  <!-- Processos em Unix  -->

  <chapter xml:id='cha.processos'>
    <title>Processor em Unix</title>
    <para>Neste capítulo serão mostradas os procedimentos básicos de visualização e manipulação de processos no Unix.</para>
    <sect1>
      <title>Introdução</title>
      <para>Em toda ambiente multitarefa, dentre os quais o Unix é considerado, os recursos computacionais da máquina são alocados pelo kernel para todas as aplicações que concorrem no sistema. Em ambientes Unix em geral, todos os programas executados na máquina são denominados processos, onde cada processo possui conjuntos de parâmetros associados ao mesmo.</para>      
    </sect1>

    <sect1>
      <title>Visualizando processos em Unix</title>

      <para>A lista dos processos ativos no sistema pode ser visualizada por intermédio do comando <command>ps</command>, como mostrado a seguir:</para>
      <example xml:id='exemplo-ps'>
	<title>Exemplo de utilização do comando <command>ps</command></title>
	<screen>
	  maquina:~$ ps
	  PID  TT  STAT  TIME  COMMAND
	  24   1    S    0:03   -bash
	  161   1    R    0:00    ps
	  maquina:~$	
	</screen>
      </example>

      <para>Neste exemplo, podemos notar algumas variáveis associadas a cada processo que identificam características próprias de cada um. Entre elas, podemos observar:</para>

      <glosslist>
	<glossentry>
	  <glossterm><prompt>PID</prompt></glossterm>
	  <glossdef>
	    <para>Número identificador do processo.</para>
	  </glossdef>
	</glossentry>

	<glossentry>
	  <glossterm><prompt>TT</prompt></glossterm>
	  <glossdef>
	    <para>Terminal de onde o processo foi iniciado.</para>
	  </glossdef>
	</glossentry>

	<glossentry>
	  <glossterm><prompt>STAT</prompt></glossterm>
	  <glossdef>
	    <para>Status do processo.</para>
	  </glossdef>
	</glossentry>


	<glossentry>
	  <glossterm><prompt>TIME</prompt></glossterm>
	  <glossdef>
	    <para>Tempo de CPU utilizado.</para>
	  </glossdef>
	</glossentry>


	<glossentry>
	  <glossterm><prompt>COMMAND</prompt></glossterm>
	  <glossdef>
	    <para>Nome do programa em execução.</para>
	  </glossdef>
	</glossentry>
      </glosslist>

      <para>Dentre estes parâmetros, destaca-se o número identificador do processo (<command>PID</command>). Este número é de suma importância para os sistema operacional, pois é a variável que possibilita a máquina distinguir os processos em execução, e para o usuário, pois no caso de acontecer algum problema, como o bloqueamento de um processo, é conveniente que o mesmo seja finalizado, repercutindo assim em uma melhoria na performance da máquina. Quando processo fica bloqueados, o tempo de uso da CPU é tomado sem realização de tarefa útil.</para>

      <para>Diversas são as opções que podem ser passadas ao comando <command>ps</command>. Entretanto, as duas formas mais comuns de utilização do comando ps são:</para>

      <glosslist>
	<glossentry>
	  <glossterm><command>ps</command></glossterm>
	  <glossdef>
	    <para>Mostra apenas os processos do usuário.</para>
	  </glossdef>
	</glossentry>

	<glossentry>
	  <glossterm><command>ps -aux</command></glossterm>
	  <glossdef>
	    <para>Mostra todos os processos da máquina.</para>
	  </glossdef>
	</glossentry>
      </glosslist>

    </sect1>

    <sect1>
      <title><command><foreignphrase>Foreground</foreignphrase></command> e <command><foreignphrase>Background</foreignphrase></command></title>

      <para>Os processos podem ser executados de duas formas: em <foreignphrase>foreground</foreignphrase> (primeiro plano) ou <foreignphrase>background</foreignphrase> (segundo plano). Os processos executado em <foreignphrase>foreground</foreignphrase> são aqueles que necessitam de interação direta com o usuário, incluindo troca de informações. Os processo em <foreignphrase>background</foreignphrase> não necessitam desta interação com o usuário.</para>

      <para>Muitas vezes é preciso passar um processo que está sendo executado em <foreignphrase>foreground</foreignphrase> para <foreignphrase>background</foreignphrase> e vice-versa. Numa sessão de transferência de arquivos entre máquinas remotas, a velocidade da linha de transmissão pode aumentar demasiadamente o tempo de transferência (horas, às vezes!). Neste caso, seria interessante passar o processo para segundo plano, liberando a <foreignphrase>shell</foreignphrase> para outras atividades do usuário.</para>

      <para>A passagem de um processo de <foreignphrase>foreground</foreignphrase> para <foreignphrase>background</foreignphrase> é feita primeiro suspendendo o processo, utilizando o conjunto de teclas <command>&lt;CTRL&gt;+z</command>, seguido do comando <command>bg</command>, que envia o processo para segundo plano. Deve ficar claro que suspender a execução de um processo não significa finalizá-lo, apenas torná-lo temporariamente inativo.</para>

      <para>A lista dos processos executados em <foreignphrase>background</foreignphrase> pode ser visualizada com o comando <command>jobs</command>, que mostra cada processo associado com um número de <foreignphrase>job</foreignphrase>. Caso o usuário necessite interagir novamente com o processo, deve utilizar o comando <command>fg</command> seguido de % número de <foreignphrase>job</foreignphrase>. Exemplo:</para>

      <example xml:id='exemplo-fg'>
	<title>Exemplo de utilização do comando <command>jobs</command> e <command>fg</command></title>
	<screen>
	  maquina:~$ jobs
	  [1]  - Running                       xemacs
	  [2]  + Suspended (tty output)        vi
	  maquina:~$ fg %2
	</screen>
      </example>

    </sect1>

    <sect1>
      <title>Finalizando processos</title>
      
    <para>Quando for necessário finalizar a execução de um processo, duas alternativas são possíveis ao usuário: pela própria interface do aplicativo, ou através do comando <command>kill</command>(Alguns processo em foreground também podem ser finalizado com o comando &lt;CTRL&gt;+c). No caso de um processo ficar bloqueado devido a algum erro de execução, utilizando desne\-ces\-sa\-ria\-mente tempo de CPU, o uso do comando <command>kill</command> se faz necessário. Sua sintaxe é descrita na linha a seguir:</para>

    <cmdsynopsis>
      <command>kill</command>
      <arg>-sinal</arg>
      <arg>número do processo</arg>
    </cmdsynopsis>
    
    <para>Caso o processo não seja finalizado com o procedimento acima, o comando <command>kill</command> deve ser utilizado com o sinal <command>-9</command>, indicando término incondicional do processo, que será encerrado de forma abrupta. Uma observação importante é que só é permitido ao usuário finalizar apenas os seus processos, não podendo intervir nos processo de outros usuários. Um exemplo de uso do comando <command>kill</command> é mostrado a seguir.</para>

    <example xml:id='exemplo-kill'>
      <title>Exemplo de utilização do comando <command>kill</command></title>
      <screen>
	maquina:~$ ps
	PID  TTY  STAT  TIME  COMMAND
	24   1    S    0:03   -bash
	60   2    S    0:03   -bash     
	161   1    R    0:00    ps
	maquina:~$ kill 60
	maquina:~$ ps
	PID  TTY  STAT  TIME  COMMAND
	24   1    S    0:03   -bash
	161   1    R    0:00    ps
	maquina:~$ 
      </screen>
    </example>

    <sect2>
      <title><foreignphrase>Pipelines</foreignphrase></title>

      <para>O <foreignphrase>pipeline</foreignphrase> consiste em canalizar a saída de um processo para a entrada de outro processo. Isto pode ser feito através do caracter de <foreignphrase>pipe</foreignphrase> "|", como mostra o exemplo a seguir, onde a saída de um comando <command>ls -la</command> é enviada para a entrada do comando <command>grep txt</command>. Com isto, apenas os arquivos que possuírem o conjunto de caracteres <prompt>'txt'</prompt> no seu nome serão apresentados na tela.</para>

      <example xml:id='exemplo-pipe'>
	<title>Exemplo de utilização do <foreignphrase>pipeline</foreignphrase></title>
	<screen>
	  \begin{quote}
	  \begin{verbatim}
	  maquina:~$ ls -la
	  total 120
	  drwxr-xr-x   4 aluno    users        1024 Mar 31 13:42 ./
	  drwxr-xr-x   7 root     root         1024 Mar 31 12:53 ../
	  -rw-r--r--   1 aluno    users          26 Mar 31 13:08 .bash_history
	  -rw-r--r--   1 aluno    users          34 Nov 23  1993 .less
	  -rw-r--r--   1 aluno    users         114 Nov 23  1993 .lessrc
	  drwxr-xr-x   2 aluno    users        1024 Mar 31 13:43 documentos/
	  -rw-r--r--   1 aluno    users          43 Mar 31 12:58 exemplo1.txt
	  drwxr-xr-x   2 aluno    users        1024 Mar 31 13:58 financas/
	  -rw-r--r--   1 aluno    users      108111 Mar 31 13:00 faq.txt
	  -rw-r--r--   1 aluno    users        5041 Mar 31 12:58 linux1.gif
	  maquina:~$ ls -la |grep txt
	  -rw-r--r--   1 aluno    users          43 Mar 31 12:58 exemplo1.txt
	  -rw-r--r--   1 aluno    users      108111 Mar 31 13:00 faq.txt
	  maquina:~$ 
	</screen>
      </example>
    </sect2>

    <sect2>
      <title>Redirecionamento</title>

      <para>Redirecionar consiste em alterar a origem da entrada ou o destino da saída de um processo, que, em geral, são as entrada e saída padrões do sistema. O redirecionamento pode ser feito com os caracteres &lt; e &gt;, que redirecionam a entrada e a saída, respectivamente.</para>
 
      <example xml:id='exemplo-redirecionamento'>
	<title>Exemplo de utilização do redirecionamento</title>
	<screen>
	  \begin{quote}
	  \begin{verbatim}
	  maquina:~$ ls -la > lista
	  maquina:~$ cat lista
	  total 120
	  drwxr-xr-x   4 aluno    users        1024 Mar 31 13:42 ./
	  drwxr-xr-x   7 root     root         1024 Mar 31 12:53 ../
	  -rw-r--r--   1 aluno    users          26 Mar 31 13:08 .bash_history
	  -rw-r--r--   1 aluno    users          34 Nov 23  1993 .less
	  -rw-r--r--   1 aluno    users         114 Nov 23  1993 .lessrc
	  drwxr-xr-x   2 aluno    users        1024 Mar 31 13:43 documentos/
	  -rw-r--r--   1 aluno    users          43 Mar 31 12:58 exemplo1.txt
	  drwxr-xr-x   2 aluno    users        1024 Mar 31 13:58 financas/
	  -rw-r--r--   1 aluno    users      108111 Mar 31 13:00 faq.txt
	  -rw-r--r--   1 aluno    users        5041 Mar 31 12:58 linux1.gif
	  maquina:~$ 
	</screen>
      </example>

    </sect2>

    </sect1>

  </chapter>

  
  <!-- Unix em Redes TCP/IP  -->

  <chapter xml:id='cha.redes'>
    <title>Unix em Redes TCP/IP</title>

    <para>Neste capítulo, serão abordadas algumas aplicações do protocolo TCP/IP, tais como acesso a terminais remotos, transferência de arquivos e correio eletrônico, que estão entre as mais utilizadas pelos usuários da Internet. Neste contexto, objetivo deste capítulo é fornecer ao usuário os procedimentos necessários para que o mesmo possa tirar proveito dos principais aplicativos de rede existente no Unix.</para>

    <sect1>
      <title>Introdução</title>
      <para>No sistema Unix, são encontrados os dois principais protocolos de redes para sistemas Unix: o UUCP e o TCP/IP. O UUCP foi desenvolvido no final da década de setenta por Mike Lesk da AT&amp;T Bell Laboratories para permitir o desenvolvimento de uma rede de computadores através de acesso discado em linhas telefônicas públicas. O UUCP foi muito popular na época em que foi criado, pois permitia a comunicação de usuários residenciais, utilizando um modem, com servidores de correio eletrônico e USENET News. Hoje, contudo, as comunicações através do UUCP encontram-se cada vez mais raras, uma vez que este protocolo permite a utilização de interfaces gráficas, tão comuns nos aplicativos atuais.</para>
    </sect1>

    <sect1>
      <title>TCP/IP</title>
      <para>O TCP/IP (Transmission Control Protocol/Internet Protocol) consiste em um conjunto de paradigmas que permite grupos de máquinas se comunicarem através de uma rede. De posse do sistema Unix em uma máquina e fazendo uso do TCP/IP, uma conexão desta última com a Internet possibilita a comunicação com quaisquer máquinas ou usuários do mundo que também façam parte desta rede.</para>
    </sect1>

    <sect1>
      <title>Conceitos básicos sobre Internet</title>
      <para>A Internet se popularizou no início da década de noventa com a sua libereção para o setor comercial nos Estados Unidos. Com isso, milhares de empresas entraram na rede, visando um mercado em expansão de milhões de pessoas que estava prestes a explodir em tamanho.</para>

      <para>A Internet possui atualmente uma taxa de crescimento vertiginosa e, por que não mensionar, assustadora, visto que o número de máquinas conectadas à mesma praticamente duplica a cada ano (ver Tabela <xref linkend="table-host"/>).</para>

      <para><command>Internet Domain Survey<footnote><para>Produzido por Network Wizards (disponível em http://www.nw.com)</para></footnote>, Julho 1996</command></para>
      <para><foreignphrase>Number of Hosts, Domains and Nets.</foreignphrase></para>

      <table xml:id="table-host" frame='all'>
	<title>Número de máquinas, domínios e redes na Internet.</title>


	<tgroup cols='7' align='left' colsep='1' rowsep='1'>
	  <colspec colname='data'/>
	  <colspec colname='hosts'/>
	  <colspec colname='dominio'/>
	  <colspec colname='ping'/>
	  <colspec colname='A'/>
	  <colspec colname='B'/>
	  <colspec colname='C'/>
	  <thead>
	    <row>
	      <entry align='center'>Date</entry>
	      <entry align='center'>Hosts</entry>
	      <entry align='center'>Domains</entry>
	      <entry align='center'>Replied to Ping<footnote><foreignphrase>Estimated by pinging 1% of all hosts. </foreignphrase></footnote></entry>
	      <entry align='center'>A</entry>
	      <entry align='center'>B</entry>
	      <entry align='center'>C</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry align='center'>Jul 96</entry>
	      <entry align='center'>12,881,000</entry>
	      <entry align='center'>488,000</entry>
	      <entry align='center'>2,569,000</entry>
	      <entry align='center'>95</entry>
	      <entry align='center'>5892</entry>
	      <entry align='center'>128378</entry>
	    </row>
	    <row>
	      <entry align='center'>Jan 96</entry>
	      <entry align='center'>9,472,000</entry>
	      <entry align='center'>240,000</entry>
	      <entry align='center'>1,682,000</entry>
	      <entry align='center'>92</entry>
	      <entry align='center'>5655</entry>
	      <entry align='center'>87924</entry>
	    </row>
	    <row>
	      <entry align='center'>Jul 95</entry>
	      <entry align='center'>6,642,000</entry>
	      <entry align='center'>120,000</entry>
	      <entry align='center'>1,149,000</entry>
	      <entry align='center'>91</entry>
	      <entry align='center'>5390</entry>
	      <entry align='center'>56057</entry>
	    </row>
	    <row>
	      <entry align='center'>Jan 95</entry>
	      <entry align='center'>4,852,000</entry>
	      <entry align='center'>71,000</entry>
	      <entry align='center'>970,000</entry>
	      <entry align='center'>91</entry>
	      <entry align='center'>4979</entry>
	      <entry align='center'>34340</entry>
	    </row>
	    <row>
	      <entry align='center'>Jul 94</entry>
	      <entry align='center'>3,212,000</entry>
	      <entry align='center'>46,000</entry>
	      <entry align='center'>707,000</entry>
	      <entry align='center'>89</entry>
	      <entry align='center'>4493</entry>
	      <entry align='center'>20628</entry>
	    </row>
	    <row>
	      <entry align='center'>Jan 94</entry>
	      <entry align='center'>2,217,000</entry>
	      <entry align='center'>30,000</entry>
	      <entry align='center'>576,000</entry>
	      <entry align='center'>74</entry>
	      <entry align='center'>4043</entry>
	      <entry align='center'>16422</entry>
	    </row>
	    <row>
	      <entry align='center'>Jul 93</entry>
	      <entry align='center'>1,776,000</entry>
	      <entry align='center'>26,000</entry>
	      <entry align='center'>464,000</entry>
	      <entry align='center'>67</entry>
	      <entry align='center'>3728</entry>
	      <entry align='center'>9972</entry>
	    </row>
	    <row>
	      <entry align='center'>Jan 93</entry>
	      <entry align='center'>1,313,000</entry>
	      <entry align='center'>21,000</entry>
	      <entry align='center'>-</entry>
	      <entry align='center'>54</entry>
	      <entry align='center'>3206</entry>
	      <entry align='center'>4998</entry>
	    </row>
	  </tbody>
	</tgroup>
	
      </table>

      <para>Como em toda tecnologia de rede, cada máquina na Internet precisa ter um endereço único. A forma de endereçamento adotada é um número inteiro formado por trinta e dois bits. Convencionou-se representar esse número como sendo formado de quatro octetos separados por pontos, cada um variando de 0 a 255. Um exemplo de endereço válido na Internet é 205.216.146.42. Contudo, a tarefa de memorizar um número IP não é agradável para o homem, muito menos os milhares de números IP existentes na Internet.</para>

      <para>Para contornar esse problema, foi criado o conceito de domínio, que é uma forma de transformar endereços númericos, difíceis de serem memorizados, em um nomes que representem as máquinas em locais da grande rede. Para a Internet, foram adotados os chamados domínios hierárquicos.</para>

      <para>Os domínios hieráquicos são dividos em duas categorias: geográficos e oficiais. Os domínios geográficos possuem o código do país no nível mais alto, como em</para>

      <prompt>endereço_da_máquina.sub_organização.organização.br</prompt>

      <para>Por exemplo, o endereço www.yahoo.com (204.71.177.73) pertence ao domínio <prompt>yahoo.com</prompt>. Os sufixos de cada país foram padronizado por entidades internacionais, e com exceção dos Estados Unidos, todo domínio na Internet termina com o sufixo do país em que se encontra. Veja abaixo alguns exemplos de sufixos:</para>

      <glosslist>
	<glossentry>
	  <glossterm><arg>ar</arg></glossterm>
	  <glossdef>
	    <para>Argentina.</para>
	  </glossdef>
	</glossentry>
	<glossentry>
	  <glossterm><arg>au</arg></glossterm>
	  <glossdef>
	    <para>Austrália.</para>
	  </glossdef>
	</glossentry>
	<glossentry>
	  <glossterm><arg>br</arg></glossterm>
	  <glossdef>
	    <para>Brasil.</para>
	  </glossdef>
	</glossentry>
	<glossentry>
	  <glossterm><arg>ca</arg></glossterm>
	  <glossdef>
	    <para>Canadá.</para>
	  </glossdef>
	</glossentry>
	<glossentry>
	  <glossterm><arg>ch</arg></glossterm>
	  <glossdef>
	    <para>Chile.</para>
	  </glossdef>
	</glossentry>
	<glossentry>
	  <glossterm><arg>fr</arg></glossterm>
	  <glossdef>
	    <para>França.</para>
	  </glossdef>
	</glossentry>
	<glossentry>
	  <glossterm><arg>uk</arg></glossterm>
	  <glossdef>
	    <para>Reino Unido.</para>
	  </glossdef>
	</glossentry>
      </glosslist>

      <para>Nos Estados Unidos, berço da Internet, os sufixos são diferentes. Foram adotados domínios oficiais, onde cada sufixo indica o tipo de instituição à qual a máquina pertence.</para>

      <para>Os domínios oficiais dos Estados Unidos são:</para>

      <glosslist>
	<glossentry>
	  <glossterm><command>com</command></glossterm>
	  <glossdef>
	    <para>Para designar uma instituição comercial.</para>
	  </glossdef>
	</glossentry>
	<glossentry>
	  <glossterm><command>edu</command></glossterm>
	  <glossdef>
	    <para>Para designar uma instituição educacional.</para>
	  </glossdef>
	</glossentry>
	<glossentry>
	  <glossterm><command>gov</command></glossterm>
	  <glossdef>
	    <para>Instituição governamental.</para>
	  </glossdef>
	</glossentry>
	<glossentry>
	  <glossterm><command>mil</command></glossterm>
	  <glossdef>
	    <para>Instituições militares.</para>
	  </glossdef>
	</glossentry>
	<glossentry>
	  <glossterm><command>org</command></glossterm>
	  <glossdef>
	    <para>Domínios reservados para organizações privadas.</para>
	  </glossdef>
	</glossentry>
	<glossentry>
	  <glossterm><command>net</command></glossterm>
	  <glossdef>
	    <para><foreignphrase>Gateways</foreignphrase> e outros computadores administrativos da rede.</para>
	  </glossdef>
	</glossentry>
      </glosslist>

    </sect1>

    <sect1>
      <title>Aplicativos de redes</title>

      <sect2>
	<title>Correio Eletrônico</title>
	<para>Um dos aplicativos mais utilizados na Internet é o correio eletrônico. Com ele, usuários podem enviar e receber mensagens de quaisquer pessoas que possuam endereços eletrônicos na rede. O correio eletrônico está diretamente relacionado ao conceito de endereço eletrônico, que provê todas as informações necessárias para que uma mensagem, partindo de qualquer parte do mundo, possa chegar até o seu destinatário. O endereço eletrônico pode representar tanto um indivíduo quanto um conjunto de indivíduos e é formado pela combinação</para>

	<prompt><command>login_do_usuário@domínio_da_máquina</command></prompt>

	<para>Exemplo: <command>joao@engcomp.ufrn.br</command></para> 

	<para>Uma mensagem de correio eletrônico é formada basicamente de duas partes distintas:</para>
	
	<orderedlist numeration="arabic">
	  <listitem>
	    <para>O cabeçalho, que contém informações a respeito de quem esta enviando a mensagem e para quem, bem como todo o trajeto feito pela mensagem na Internet;</para>
	  </listitem>
	  <listitem>
	    <para>o corpo ou conteúdo da mensagem.</para>
	  </listitem>
	</orderedlist>

	<para>No Unix, existem vários programas de correio eletrônico, sejam eles orientados a caracteres ou a interfaces gráficas. A maior parte deles é original dos sistemas Unix. Como exemplos de programas de correio eletrônico no Unix, podemos citar o <application>pine</application> e o <application>mail</application>.</para>
    
	<para>Ao entrar em um sistema Unix genérico, é costumeiro que o usuário receba uma aviso a existência ou não de mensagens para si. Um dos programas mais utilizados para leitura de correio eletrônico no Unix é o <application>pine</application>. Ao executar o <application>pine</application> o usuário tem acesso a uma interface de texto bastante auto-explicativa, como mostrado a seguir.</para>

	<screen>
PINE 3.96   MAIN MENU                            Folder: INBOX  93  Messages  

       ?     HELP               -  Get help using Pine                   
       C     COMPOSE MESSAGE    -  Compose and send/post a message       
       I     FOLDER INDEX       -  View messages in current folder       
       L     FOLDER LIST        -  Select a folder OR news group to view 
       A     ADDRESS BOOK       -  Update address book                   
       S     SETUP              -  Configure or update Pine              
       Q     QUIT               -  Exit the Pine program                 

   Copyright 1989-1997.  PINE is a trademark of the University of Washington.
                    [Folder "INBOX" opened with 93 messages]
? Help                     P PrevCmd                  R RelNotes            
O OTHER CMDS L [ListFldrs] N NextCmd                  K KBLock 
	</screen>

	<para>Para ler as mensagens, basta selecionar a opção "<prompt>L</prompt>" do menu e selecionar a pasta <prompt>INBOX</prompt> na tela seguinte. INBOX representa todas as mensagens existentes na caixa postal do usuário. Uma vez selecionada a pasta INBOX, uma tela semelhante a seguinte aparecerá no terminal.</para>

<screen>
PINE 3.96   FOLDER INDEX                 Folder: INBOX  Message 1 of 90       

      1 Oct 15 Ernesto Paulo dos   (1,858) [linux-br] Bons Livros sobre Linux e 
+     2 Oct 15 orders@amazon.com   (2,810) Your Order with Amazon.com (#002-0898
      3 Oct 16 Tiago Walzer Kuhn   (1,672) [linux-br] Re: Bons Livros sobre Linu
      4 Oct 16 Klaus Steding-Jess  (2,717) Re: [TeX-BR] man2latex               
+     5 Oct 16 Agostinho M. Brito    (592) ftp.icce.rug.nl                      
+     6 Oct 18 orders@amazon.com   (1,997) Your Amazon.com order (#002-0898723-5
      7 Oct 19 Andrés Ortiz Salaz  (6,238) [Fwd: Curso "virtual" de linguagem C]
      8 Oct 22 Ying Zhang          (2,842) [linux-br] [comp.os.linux.announce] S
      9 Oct 26 Tobias Gloth        (4,136) [linux-br] [comp.os.linux.announce] M
                          [Already at start of Index]
? Help       M Main Menu  P PrevMsg     - PrevPage    D Delete      R Reply     
O OTHER CMDS V [ViewMsg]  N NextMsg   Spc NextPage    U Undelete    F Forward  
</screen>

<para>A mensagem pode ser selecionada com as setas do teclado. Para compor mensagens, seleciona-se a opção <command>C</command> no menu principal do programa ou digita-se a tecla <command>C</command>, de <foreignphrase>compose</foreignphrase>. Na tela de composição de e-mail, o usuário precisará preencher os campos <prompt>to</prompt>, indicando o endereço do destinatário, <foreignphrase>subject</foreignphrase>, o assunto da mensagem e escrever a mensagem propriamente dita. Exemplo:</para>

<screen>
PINE 3.96   COMPOSE MESSAGE              Folder: INBOX  104 Messages  
To      : ambj@leca.ufrn.br
Cc      : 
Attchmnt: 
Subject : teste de e-mail
----- Message Text -----
Alo, agostinho.

         Estou testando correio eletronico.
         Abracos, Agostinho


^G Get Help ^X Send    ^R Rich Hdr ^Y PrvPg/Top ^K Cut Line  ^O Postpone  
^C Cancel   ^D Del Char^J Attach   ^V NxtPg/End ^U UnDel Line^T To AddrBk
</screen>
      </sect2>

      <sect2>
	<title>Transferência de arquivos</title>


	<para>A transferência de arquivos é hoje um recurso mais do que conhecido pelos usuários da Internet. Encontram-se espalhados nas máquinas ao redor do mundo milhares documentos ou aplicações científicas, demonstrativos de jogos, aplicativos para diversos sistemas operacionais, diversos artigos e dicas sobre determinados programas ou periféricos existentes no mercado, além de diversos produtos que  empresas de informática estão disponibilizando pela rede. Todos estes recursos e muitos outros não mencionados estão ao alcance dos usuários da Internet, desde que, é claro, possuam as ferramentas adequadas para a transferência de arquivos entre máquinas.</para>

	<para>Um dos mecanismos que surgiu junto com a Internet foi o FTP (File Transfer Protocol), cuja função é a de possibilitar troca de arquivos entre computadores remotos. Em muitos sistemas, é também o nome do programa que implementa o protocolo.</para>

	<para>O <command>ftp</command> é um software interativo de transferência de arquivos e necessita de que o usuário insira as informações necessárias ao gerenciamento das funções do programa.</para>
    
	<para>Para dar início a uma sessão de FTP, basta digitar a linha de comando a seguir:</para>

	<cmdsynopsis>
	  <command>ftp &lt;nome da máquina servidora de ftp&gt; </command>
	</cmdsynopsis>

	<para>Feito isso, será pedido ao usuário um login e uma senha. Caso este último não possua uma conta na máquina remota conectada, poderá utilizar o login anonymous<footnote><para>É necessário que a máquina remota possibilite o acesso do usuário anonymous</para></footnote>, cuja a senha é o próprio endereço eletrônico do usuário local. O conta de usuário anonymous existe em muitas máquinas como uma forma de possibilitar a usuários de outros sistemas o acesso a diretórios locais que contenha informações de domínio público.</para>

	<para>Comandos básicos do programa <command>ftp</command>:</para>

	<table xml:id="table-ftp" frame='all'>
	  <title>Comandos básicos do programa <command>ftp</command></title>
	<tgroup cols='2' align='left' colsep='1' rowsep='1'>
	  <colspec colname='comando'/>
	  <colspec colname='descricao'/>
	  <thead>
	    <row>
	      <entry align='center'><command>Comando</command></entry>
	      <entry align='center'>Descrição</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry align='center'><command>dir</command></entry>
	      <entry align='center'>Lista o conteúdo do diretório da máquina remota.</entry>
	    </row>
	    <row>
	      <entry align='center'><command>binary</command></entry>
	      <entry align='center'>Informa ao FTP que os arquivos a serem transferidos são programas e não texto.</entry> 
	    </row>
	    <row>
	      <entry align='center'><command>ascci</command></entry>
	      <entry align='center'>Informa ao FTP que os arquivos transferidos são no modo texto.</entry>
	    </row>
	    <row>
	      <entry align='center'><command>get &lt;arquivo&gt;</command></entry>
	      <entry align='center'>Transfere o arquivo remoto para a sua máquina.</entry>
	    </row>
	    <row>
	      <entry align='center'><command>put &lt;arquivo&gt;</command></entry>
	      <entry align='center'>Transfere o arquivo de sua máquina para a máquina remota.</entry>
	    </row>
	    <row>
	      <entry align='center'><command>mget &lt;arquivo1&gt; [&lt;arquivo2&gt;...]</command></entry>
	      <entry align='center'>Transfere o arquivo remoto para a sua máquina.</entry>
	    </row>
	    <row>
	      <entry align='center'><command>mput &lt;arquivo1&gt; [&lt;arquivo2&gt;...]</command></entry>
	      <entry align='center'>Transfere o arquivo de sua máquina para a máquina remota.</entry>
	    </row>
	    <row>
	      <entry align='center'><command>cd &lt;diretório&gt;</command></entry>
	      <entry align='center'>Muda de diretório na máquina remota.</entry>
	    </row>
	    <row>
	      <entry align='center'><command>lcd &lt;diretório&gt;</command></entry>
	      <entry align='center'>Muda de diretório na máquina local.</entry>
	    </row>
	    <row>
	      <entry align='center'><command>quit ou bye</command></entry>
	      <entry align='center'>Finaliza o FTP.</entry>
	    </row>
	    <row>
	      <entry align='center'><command>help</command></entry>
	      <entry align='center'>Exibe informações sobre todos os comandos disponíveis.</entry>
	    </row>

	  </tbody>
	</tgroup>
	</table>

	<para>Exemplo de abertura de sessão <command>ftp</command>:</para>

	<example xml:id='exemplo-ftp'>
	  <title>Exemplo de utilização do <command>ftp</command></title>
	  <screen>
	    maquina:~$ ftp ftp.engcomp.ufrn.br
	    Connected to ftp.engcomp.ufrn.br.
	    220 ribeira FTP server (Version wu-2.4(1) Tue Dec 5 20:51:15 CST 1995) 
	    ready.
	    Name (ribeira.engcomp.ufrn.br:aluno): anonymous
	    331 Guest login ok, send your complete e-mail address as password.
	    Password:
	    230-Welcome, archive user!  This is an experimental FTP server. If have
	    230-any unusual problems, please report them via e-mail to root
	    230-If you do have problems, please try using a dash (-) as the first
	    230-character of your password -- this will turn off the continuation 
	    230-messages that may be confusing your ftp client.
	    230-
	    230 Guest login ok, access restrictions apply.
	    Remote system type is UNIX.
	    Using binary mode to transfer files.
	    ftp> 
	  </screen>
	</example>	
      </sect2>

      <sect2>
	<title>Emulação de Terminal Remoto</title>

	<para>Uma das facilidades provenientes dos ambientes de redes, dentre os quais destaca-se a Internet, é a possibilidade de executar comandos em uma máquina através de um acesso remoto à mesma. O ambiente no qual um determinado usuário executa os comandos remotos é conhecido no jargão de redes como <foreignphrase>terminal remoto</foreignphrase>. Em outras palavras, um usuário logado em uma máquina X realiza uma conexão de terminal remoto com uma máquina Y e, a partir daí, realiza comandos na máquina X que serão executados na máquina Y.</para>

	<para>Este recurso de execução remota de comandos permite, por exemplo, que pesquisadores de um laboratório utilizem o poder computacional de processamento de um outro computador, localizado em um outro laboratório de qualquer parte do mundo.</para>

	<para>Para utilizar o terminal remoto é necessário que o usuário possua uma conta no sistema remoto. Em algumas ocasiões, pode existir uma conta de domínio público, semelhante ao usuário anonymous do aplicativo <command>ftp</command>. Entretanto, isto não é costumeiro em se tratando de acesso remoto, por questões de segurança do sistema.</para>

	<para>Os dois comandos mais utilizados para iniciar uma sessão de terminal remoto são <command>telnet</command> e <command>rlogin</command>:</para>

	<glosslist>
	  <glossentry>
	    <glossterm><command>Telnet</command></glossterm>
	    <glossdef>
	      <para>Sintaxe: <command>telnet endereço_da_máquina</command></para>
	  </glossdef>
	  </glossentry>
	  <glossentry>
	    <glossterm><command>Rlogin</command></glossterm>
	    <glossdef>
	      <para>Sintaxe: <command>rlogin endereço_da_máquina</command></para>
	    </glossdef>
	  </glossentry>
	</glosslist>

	<para>O comando <command>rlogin</command> inicia uma sessão de terminal remoto em uma máquina Y, na mesma conta de usuário da máquina X (mesmo <foreignphrase>login name</foreignphrase>). A diferença básica do <command>rlogin</command> em relação ao <command>telnet</command> é que o primeiro não requisita a identificação do usuário (login), apenas a sua senha.</para>
      </sect2>

      <sect2>
	<title>Conversando pela Internet</title>

	<para>O Unix implementa uma aplicação muito interessante do Unix: o <command>talk</command>. O <command>talk</command> é um programa interativo e permite que um usuário possa conversar em tempo real com outro via Internet. Para iniciar uma sessão de <foreignphrase>talk</foreignphrase>, é necessário confirmar se a pessoa com a qual se deseja conversar está logada no momento e em alguma máquina.</para>

	<para>O estabelecimento de uma chamada de <foreignphrase>talk</foreignphrase> é feita executando o comando com os argumentos adequados:</para>
     
	<cmdsynopsis>
	  <command>talk login_do_usuário_remoto@máquina_remota</command>
	</cmdsynopsis>

	<para>Uma vez executado esse comando, será preciso que o usuário remoto para qual a chamada de <foreignphrase>talk</foreignphrase> foi solicitada confirme o pedido. Esta confirmação é feita quando o usuário remoto executa o comando <command>talk</command> passando como argumentos o endereço do usuário que iniciou a conexão. Uma vez confirmada a solicitação de <foreignphrase>talk</foreignphrase>, a tela é dividida em duas janelas, onde na janela de cima são escritas as mensagens do usuário local, e na de baixo são apresentadas as mensagens enviadas pelo usuário remoto. Uma sessão de <foreignphrase>talk</foreignphrase> pode ser finalizada com o comando &lt;CTRL&gt;+c.</para>

      </sect2>

      <sect2>
	<title>Verificando se uma máquina está ativa com <command>ping</command></title>

	<para>O comando <command>ping</command>, serve para saber se determinada máquina na Internet está funcionando. A sua sintaxe é:</para>

	<cmdsynopsis>
	  <command>ping endereço_da_máquina</command>
	</cmdsynopsis>

	<para>Uma vez executado o comando, mensagens de retorno serão apresentadas na tela, indicando se a máquina está ligada e funcionando ou que o seu endereço não é reconhecido. Neste último caso, três hipóteses podem ser consideradas:</para>

	<orderedlist numeration="arabic">
	  <listitem>
	    <para>Não existe uma máquina na Internet com o nome ou o número passado como argumento.</para>
	  </listitem>
	  <listitem>
	    <para>A máquina está desligada.</para>
	  </listitem>
	  <listitem>
	    <para>Alguma máquina que entremeia o caminho para a máquina de destino encontra-se fora do ar.</para>
	  </listitem>
	</orderedlist>
      </sect2>

    </sect1>
  </chapter>

  <!--Edição de textos com joe-->

  <chapter xml:id='cha-joe'>
    <title>Edição de textos com <command>joe</command></title>
    <para>Neste capítulo será apresentado um dos editores ascii de texto mais populares no sistema Linux: o <command>joe</command>. O que motiva o seu uso é o fato de sua operacão ser simples, pois seus comandos se assemelham bastante aos utilizados em editores como o WordStar, Sidekick e Turbo Pascal para MSDOS, com os quais a maioria dos usuários de PC são familiares. Esta sua característica o torna bastante atrativo para edição de textos em terminais.</para>

    <sect1>
      <title>Introdução</title>

      <para>Existem diversos editores de texto para Unix. Entre os mais conhecidos e utilizados, destacam-se o <command>vi</command>, amplamente difundido na maioria dos sistemas Unix, e o <command>emacs</command>, desenvolvido pela GNU. A popularização destes editores se deu principalmente devido à enormidade de recursos e ferramentas de edição e processamento de texto disponíveis em cada um, que, algumas vezes, os tornam difíceis de utilizar. </para>
      
      <para>Também podem ser encontrados muitos editores gráficos do tipo WYSIWYG(<foreignphrase>What You See Is What You Get</foreignphrase>), alguns deles em versões <foreignphrase>freeware</foreignphrase> (a grande maioria) e alguns em versões comerciais. Podemos citar como exemplos de bons editores gráficos os pacotes Andrew, Lyx, Thot, Applixware e StarOffice, tendo este último funcionalidades bastante semelhantes às do Microsoft Word 6.0</para>
    </sect1>

    <sect1>
      <title>O editor de textot <command>joe</command></title>

      <para>Para executar o joe basta digitar o comando <command>joe</command> seguido ou não do nome do arquivo que se deseja editar, e da tecla &lt;ENTER&gt;. Com isso, a tela de edição do <command>joe</command> será apresentada para o usuário tal como mostrado abaixo.</para>
    
      <screen>
IW  teste.txt                     Row 1    Col 1    4:49  Ctrl-K H for help

Este e' um exemplo de texto editado no joe,
um popular editor de texto bastante utilizado por
usua'rios do sistema Linux.

Seus comandos sao bastante semelhantes aos do WordStar e 
Sidekick para MSDOS.

        
        Use o joe para editar os seus textos!




** Joe's Own Editor v2.2 ** Copyright (C) 1994 Joseph H. Allen **
      </screen>

      <para>Para acessar a ajuda <foreignphrase>on-line</foreignphrase>, basta digitar a combinação de teclas &lt;CTRL&gt;+K+H (^KH, segundo a notação do <command>joe</command>) que a tela de ajuda aparecerá, como mostrado a seguir. Para fechar a tela de ajuda, basta digitar a combinação ^KH novamente.</para>

      <screen>
 CURSOR           GO TO            BLOCK      DELETE   MISC         EXIT       
 ^B left ^F right ^U  prev. screen ^KB begin  ^D char. ^KJ reformat ^KX save   
 ^P up   ^N down  ^V  next screen  ^KK end    ^Y line  ^T  options  ^C  abort  
 ^Z previous word ^A  beg. of line ^KM move   ^W >word ^R  refresh  ^KZ shell  
 ^X next word     ^E  end of line  ^KC copy   ^O word&lt; @  insert   FILE       
 SEARCH           ^KU top of file  ^KW file   ^J >line SPELL        ^KE edit   
 ^KF find text    ^KV end of file  ^KY delete ^_ undo  ^[N word     ^KR insert 
 ^L  find next    ^KL to line No.  ^K/ filter ^^ redo  ^[L file     ^KD save  
      </screen>

      <para>A movimentação do cursor dentro do texto pode ser feita com as setas do teclado, para mudar entre linhas e colunas, ou através das teclas PGUP e PGDN, para deslocamento entre páginas.</para>

      <para>Para procurar por grupos de caracteres dentro do texto, basta utilizar a combinação de teclas ^KF e indicar a <foreignphrase>string</foreignphrase> de texto desejada. Feito isso, o joe requisita algumas opções de busca, tais como sensibilidade ao caso (MAIÚSCULAS/minúsculas) e direção de busca. Para repetir a última busca realizada, basta digitar ^L.</para>

      <para>Para remover caracteres, podem ser utilizadas as teclas &lt;BACKSPACE&gt;, para apagar um caracter à esquerda do cursor, e &lt;DEL&gt;, para apagar caracteres à direita do cursos. A remoção de linhas inteiras é feita digitando o comando ^Y. O joe também suporta operações de bloco. Para marcar o início e o fim de um bloco, digita-se ^KB e ^KK, respectivamente. Para remover o bloco marcado, digita-se ^KY. Para mover o bloco para a posição corrente do cursor, basta digitar ^KM. A cópia do bloco para a posição do cursor, por sua vez, é feita com a combinação de teclas ^KC.</para>

      <para>O joe mantém uma lista de todas as mudanças realizadas pelo usuário no documento, permitindo desfazer e refazer quaisquer ações dentro de uma sessão de edição de texto. Para desfazer a mudança mais recente, digita-se &lt;CTRL&gt;+&lt;SHIFT&gt;+_ (control-sublinhado). Para refazer uma mudança desfeita anteriormente, basta digitar &lt;CTRL&gt;+&lt;SHIFT&gt;+^ (control-circunflexo).</para>

      <para>As mudanças realizadas no arquivo podem ser salvas com a combinação de teclas &lt;CTRL&gt;+K+D. Para sair do <command>joe</command> e salvar as mudanças correntes, basta digitar ^KX. Caso o usuário não deseje salvar as alterações, o mesmo pode sair do editor digitando ^C. Se alguma mudança tiver sido efetuada, o <command>joe</command> irá perguntar se o usuário deseja sair sem salvar as alterações.</para>

      <para>No quadro abaixo são apresentados os principais comandos do <command>joe</command>, incluindo operações de movimentação na tela, manipulação de blocos e arquivos, busca de expressões e remoção de objetos, entre outros.</para>

      <screen>
 CURSOR                     MOVER                      MARCAR BLOCO
 ^B esquerda                ^U  tela anterior          ^KB início  
 ^P cima                    ^V  tela posterior         ^KK final    
 ^Z palavra anterior        ^A  início da linha        ^KM mover   
 ^X palavra posterior       ^E  fim da linha           ^KC copiar   
 ^F direita                 ^KU início do arquivo      ^KW salvar  
 ^N baixo                   ^KV final do arquivo       ^KY apagar
                            ^KL mover para linha       ^K/ filtro

 DELETAR                MISCELÂNEA              SAIR   
 ^D caracter            ^KJ reformatar          ^KX salvar   
 ^Y linha               ^T  opções              ^C  abortar  
 ^W palavra a direita   ^R  refrescar           ^KZ shell  
 ^O palavra a esquerda  ^@  inserir             ARQUIVO      
 ^J final da linha      SPELL                   ^KE editar 
 ^_ desfazer            ^[N palavra             ^KR inserir 
 ^^ refazer             ^[L arquivo             ^KD salvar  

 BUSCA          
 ^KF procurar texto   
 ^L  procurar próximo

      </screen> 

      <para >É importante ter em mente que o <command>joe</command> é apenas um editor de texto ascii e não um completo processador de texto. Opções tais como mudança de fontes, alinhamento ou insersão de gráficos são deixadas por conta de pacotes como o LaTeX, que dão ao usuário munição suficiente para construir as mais variadas formas de arranjo textos e objetos gráficos em um documento.</para>

    </sect1>
  </chapter>

  <!--O ambiente gráfica X windows -->
  <chapter xml:id='cha-ambiente'>
    <title>O ambiente gráfica X Windows</title>
    <sect1>
      <title>Introdução</title>

      <para>O sistema X Window (ou simplesmente "<command>X</command>") é um ambiente de trabalho gráfico utilizado em quase todos os desktops Unix existentes no mundo. Foi desenvolvido inicialmente pelo MIT (<foreignphrase>Massachusetts Institute of Technology</foreignphrase>), sendo o projeto posteriormente repassado para um conjunto de empresas denominado "<foreignphrase>The X Consortium</foreignphrase>" e mantidos por eles desde então.</para>

      <para>O X é constituído de um programa chamado <command>servidor gráfico</command>, responsável por desenhar os elementos da tela e de uma série de bibliotecas auxiliares. Os programas utilitários são denominados <command>clientes</command>. O browser <command>netscape</command> é um exemplo de programa cliente.</para>

      <para>No Linux, o X Window é implementado por um conjunto de programas e bibliotecas denominado <command>XFree86</command>. O XFree86 é totalmente gratuito e dá suporte às mais diversas placas de vídeo disponíveis no mercado.</para>

      <para>O X Window traz para o usuário Unix o conforto de trabalhar em um ambiente gráfico, com ícones, editores de texto e imagem etc e possibilita, entre outras coisas, que aplicativos desenvolvidos em um tipo de unix possam ser exibidos na tela de outro.</para>

    </sect1>

    <sect1>
      <title>Iniciando e Finalizando o X Window</title>

      <para>Em diversas máquinas, o X é normalmente iniciado após o boot. Neste caso, para o usuário utilizar o sistema, é preciso entrar com o seu username e a sua senha em alguma janela de diálog específica.</para>

      <para>Quando o X Window não é iniciado após o boot, o comando</para>

      <cmdsynopsis>
	<prompt>startx</prompt>
      </cmdsynopsis> 

      <para>resolverá o problema. <prompt>startx</prompt> é um <foreignphrase>shell script</foreignphrase> que executa o servidor gráfico e inicia o gerenciador de janelas.</para>

      <para>O gerenciador de janelas é quem arruma na tela todo o arsenal de aplicativos e realiza as interações entre o usuário e o X Window. Dependendo do gerenciador de janelas utilizado, o usuário poderá ter um ícone indicando as horas, outro para abrir um terminal de comandos etc. O Linux é um dos sistemas que mais possue gerenciadores de janela. Entre outros, podemos citar  <command>fvwm</command>, <command>olwm</command>, <command>mwm</command>, <command>Kde</command> e <command>gnome</command>.</para>

      <para>A finalização do X geralmente é feita através de alguma entrada de menu do tipo "Exit Window Manager", ou simplesmente "exit". Caso não seja encontrada alguma saída óbvia, basta digitar a combinação das teclas &lt;CTRL&gt;+&lt;ALT&gt;+&lt;BACKSPACE&gt;.</para>
    </sect1>

    <sect1>
      <title>Executando aplicativos</title>

      <para>Os aplicativos mais comuns podem ser encontrados nos menus que o gerenciador de janelas apresenta, tais como <command>shells</command>, <command>gerenciadores de arquivo</command> e <command>editores de texto</command>. Quando a aplicação procurada não se encontra no menu, a maneira mais rápida de executá-la é através de uma shell.</para>

      <para>A shell é na maioria das vezes o primeiro aplicativo procurado por um usuário Unix, pois agiliza a tarefa de interagir com o sistema. No X Window, o programa <prompt>xterm</prompt> disponibiliza a shell para o usuário. Praticamente todos aplicativos gráficos do sistema podem ser executados pelo usuário diretamente de um terminal. Recomenda-se fazer a execução do aplicativo em <foreignphrase>background</foreignphrase> para liberar a shell para outras atividades.</para>

    </sect1>

    <sect1>
      <title>Usando o mouse</title>

      <para>No X Window, as três teclas do mouse possuem uma função específica. Caso o mouse possua apenas dois botões, ou o botão do meio esteja desabilitado, o clique simultâneo dos botões esquerdo e direito simulam o efeito do botão central.</para>

      <para>A tecla da esquerda é utilizada para selecionar elementos na tela (botões, menu, barras de rolagem etc), maximizar, minimizar e fechar janelas, além de marcar texto nos programas que permitam esta operação.</para>

      <para>A tecla do meio é utilizada principalmente para colar objetos selecionado com o botão da esquerda, principalmente texto.</para>

      <para>A tecla da direita abre menus na tela do tipo "<foreignphrase>pop-up</foreignphrase>" para o usuário. Sua utilização é mais intensiva se dá no gerenciador de janelas olwm. Neste sistema, as aplicações são chamadas com o mouse a partir do menu <foreignphrase>pop-up</foreignphrase> apresentado quando o usuário clica com o botão direito no fundo da área de trabalho.</para>
    </sect1>

    <sect1>
      <title>A área de trabalho</title>

      <para>A área de trabalho do usuário, ou <foreignphrase>Desktop</foreignphrase>, é a região da tela onde todos os aplicativos gráficos são lançados. Os gerenciadores de janela geralmente executam um programa que disponibiliza várias áreas de trabalho para o usuário, ou <foreignphrase>Desktops</foreignphrase> virtuais. Com isto, a sobrecarga visual é dividida em diversos ambientes, tornando o uso da máquina mais agradável.</para>

      <para>A figura <xref linkend="fig-xwindow"/> mostra uma tela do X Window System utilizando o gerenciador de janelas fvwm95.</para>


      <figure xml:id="fig-xwindow">
	<title>O Ambiente X Window utilizando o gerenciador de janelas fvwm95.</title>
	<mediaobject>
	  <imageobject role="html">
	    <imagedata format="SVG" fileref="figuras/xwindow.svg"/>
	  </imageobject>
	</mediaobject>
      </figure>

<para>Alguns gerenciadores de <foreignphrase>Desktops</foreignphrase> possibilitam inclusive que o usuário desloque uma janela de um <foreignphrase>Desktop</foreignphrase> para outro.</para>
    </sect1>

    <sect1>
      <title>Definindo o Display</title>
   
      <para>Em se tratando de X Window, toda aplicação gráfica possui um display associado à mesma. O display é o nome da tela gráfica que o servidor X controla. No Unix, é uma combinação de três elementos:</para>

      <itemizedlist mark='opencircle'>
	<listitem override='bullet'>
	  <para>Nome da máquina onde será exibida a aplicação.</para>
	</listitem>
	<listitem override='bullet'>
	  <para>Número do servidor gráfico a ser utilizado (uma máquina pode ter mais de um servidor em funcionamento).</para>
	</listitem>
	<listitem override='bullet'>
	  <para>Número da tela gráfica (o servidor X pode controlar mais de uma tela ao mesmo tempo).</para>
	</listitem>
      </itemizedlist>

      <para>O display é geralmente definido pela variável de ambiente <command>DISPLAY</command>. Assim para definir que um aplicativo deverá ser apresentado na máquina <prompt>maquina.engcomp.ufrn.br</prompt>, pelo primeiro servidor na primeira tela, basta executar o seguinte comando:</para>

      <itemizedlist mark='opencircle'>
	<listitem override='bullet'>
	  <para>Para <prompt>tcsh</prompt>:</para>
	  <screen>
	    maquina:~$ setenv DISPLAY maquina.engcomp.ufrn.br:0.0
	  </screen>
	</listitem>
	<listitem override='bullet'>
	  <para>Para <prompt>bash</prompt>:</para>
	  <screen>
	    maquina:~$ export DISPLAY=maquina.engcomp.ufrn.br:0.0
	  </screen>
	</listitem>
      </itemizedlist>

    </sect1>

    <sect1>
      <title>Permitindo que máquinas remotas acessem o servidor X local</title>

      <para>A variável de ambiente apresentada na seção anterior serve para indicar que o local onde a aplicação gráfica será apresentada, não para garantir que o servidor especificado irá permitir esta operação. Por questões de segurança, o servido X não oferece a priori os seus serviços para todas as máquinas da sua rede. Assi, cada vez o usuário precise apresentar aplicações lançadas por máquinas remotas na tela gráfica local o servidor deverá ser informado através do comando <command>xhost</command>. </para>

      <para>O comando <command>xhost</command> quando executado sem argumentos exibe a lista de todas as máquinas autorizadas a lançar aplicações no servidor local. As máquinas que podem utilizar o servidor X são adicionadas ao sistema da forma:</para>

      <screen>
	maquina:~$ xhost + maquina_A
      </screen>

      <para>e retiradas da forma</para>

      <screen>
	maquina:~$ xhost - maquina_A
      </screen>

      <para>Se um determinado usuário utilizando o computador <command>A</command> deseja utilizar o poder computacional do computador <command>B</command> para executar um aplicativo gráfico (xpaint, por exemplo) e apresentar tela do programa no computador <command>A</command> o procedimento para realizar esta tarefa seria o seguinte:</para>

      <screen>
	maquina_A:~$ xhost +
	maquina_A:~$ telnet maquina_B
	Trying 10.0.0.1...
	Connected to maquina_B.
	Escape character is '^]'.
	
	Linux 2.0.34 (maquina_B) (ttyp1)
	
	maquina_B login: usuario
	Password: 
	maquina_B:~$ setenv DISPLAY maquina_A:0.0
	maquina_B:~$ xpaint &amp;
	maquina_B:~$ 
      </screen>
    </sect1>
<!--
\begin{thebibliography}{9}
\bibitem{1} GREENFIELD, L. {\bf The Linux users' guide}, 1994. Disponível via ftp anônimo em {\tt sunsite.unc.edu}, no diretório {\tt /pub/Linux/docs/LDP}.
\bibitem{2} WELSH, M. {\bf Linux instalation and getting started}, 1994. Disponível via ftp anônimo em {\tt sunsite.unc.edu}, no diretório {\tt /pub/Linux/docs/LDP}.
\end{thebibliography}

\end{document}
-->


  </chapter>
</book>

