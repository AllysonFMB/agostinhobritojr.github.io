<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="AsciiDoc 8.6.9">
<title>Introdução à computação gráfica com OpenGL</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

pre {
  padding: 0;
  margin: 0;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #777777;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }


/*
 * xhtml11 specific
 *
 * */

tt {
  font-family: monospace;
  font-size: inherit;
  color: navy;
}

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

.monospaced {
  font-family: monospace;
  font-size: inherit;
  color: navy;
}

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


/*
 * Theme specific overrides of the preceding (asciidoc.css) CSS.
 *
 */
body {
  font-family: Garamond, Georgia, serif;
  font-size: 17px;
  color: #3E4349;
  line-height: 1.3em;
}
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Garmond, Georgia, serif;
  font-weight: normal;
  border-bottom-width: 0;
  color: #3E4349;
}
div.title, caption.title { color: #596673; font-weight: bold; }
h1 { font-size: 240%; }
h2 { font-size: 180%; }
h3 { font-size: 150%; }
h4 { font-size: 130%; }
h5 { font-size: 115%; }
h6 { font-size: 100%; }
#header h1 { margin-top: 0; }
#toc {
  color: #444444;
  line-height: 1.5;
  padding-top: 1.5em;
}
#toctitle {
  font-size: 20px;
}
#toc a {
    border-bottom: 1px dotted #999999;
    color: #444444 !important;
    text-decoration: none !important;
}
#toc a:hover {
    border-bottom: 1px solid #6D4100;
    color: #6D4100 !important;
    text-decoration: none !important;
}
div.toclevel1 { margin-top: 0.2em; font-size: 16px; }
div.toclevel2 { margin-top: 0.15em; font-size: 14px; }
em, dt, td.hdlist1 { color: black; }
strong { color: #3E4349; }
a { color: #004B6B; text-decoration: none; border-bottom: 1px dotted #004B6B; }
a:visited { color: #615FA0; border-bottom: 1px dotted #615FA0; }
a:hover { color: #6D4100; border-bottom: 1px solid #6D4100; }
div.tableblock > table, table.tableblock { border: 3px solid #E8E8E8; }
th.tableblock, td.tableblock { border: 1px solid #E8E8E8; }
ul > li > * { color: #3E4349; }
pre, tt, .monospaced { font-family: Consolas,Menlo,'Deja Vu Sans Mono','Bitstream Vera Sans Mono',monospace; }
tt, .monospaced { font-size: 0.9em; color: black;
}
div.exampleblock > div.content, div.sidebarblock > div.content, div.listingblock > div.content { border-width: 0 0 0 3px; border-color: #E8E8E8; }
div.verseblock { border-left-width: 0; margin-left: 3em; }
div.quoteblock { border-left-width: 3px; margin-left: 0; margin-right: 0;}
div.admonitionblock td.content { border-left: 3px solid #E8E8E8; }


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      extensions: ["tex2jax.js"],
      jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
      },
      "HTML-CSS": { availableFonts: ["TeX"] }
    });
  </script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script>
</head>
<body class="book">
<div id="header">
<h1>Introdução à computação gráfica com OpenGL</h1>
<span id="author">Agostinho Brito</span><br>
<span id="revnumber">version 0.9,</span>
<span id="revdate">(c)2006-15</span>
</div>
<div id="content">
<div class="sect1">
<h2 id="_prefácio">Prefácio</h2>
<div class="sectionbody">
<div class="paragraph"><p>Este tutorial visa ensinar os conceitos de Computação gráfica
utilizando uma das APIs de progração gráfica mais populares, o
OpenGL. Foi concebido como material acessório para uma disciplina de
computação gráfica e, assim sendo, assume que o aluno possui os
fundamentos teóricos necessários para acompanhar cada
lição. Entretanto, grande parte destes fundamentos é bastante
intuitivo, encorajando àqueles interessados no assunto a acompanharem
as práticas e realizarem os exercícios.</p></div>
<div class="paragraph"><p>Toda e qualquer sugestão e/ou contribuição visando melhorar e evoluir
este tutorial será bemvinda. Pode mandá-la diretamente via e-mail para
ambj_at_dca.ufrn.br</p></div>
</div>
</div>
<h1 id="conceitos">Conceitos iniciais</h1>
<div class="sect1">
<h2 id="_o_que_é_opengl">O que é OpenGL</h2>
<div class="sectionbody">
<div class="paragraph"><p>OpenGL é uma interface de <em>software</em> para dispositivos de
<em>hardware</em>. É uma biblioteca gráfica de modelagem e exibição
tridimensional, bastante rápida e portável para vários sistemas
operacionais. Seus recursos permitem ao usuário criar objetos gráficos
com qualidade próxima à de um <em>raytracer</em>, de modo mais rápido que
este último, além de incluir recursos avançados de animação,
tratamento de imagens e texturas.</p></div>
<div class="paragraph"><p>A biblioteca OpenGL (<em>Open Graphics Library</em>) foi introduzida em 1992
pela Silicon Graphics (<a href="http://www.sgi.com">http://www.sgi.com</a>) no intuito de
conceber uma API (Interface de Programação de Aplicação) gráfica
independente de dispositivos de exibição. Com isto, seria estabelecida
uma ponte entre o processo de modelagem geométrica de objetos,
situadas em um nível de abstração mais elevado, e as rotinas de
exibição e de processamento de imagens implementadas em dispositivos
(<em>hardware</em>) e sistemas operacionais específicos. As função utilizada
pelo OpenGL para desenhar um ponto na tela, por exemplo, possui os
mesmos nome e parâmetros em todos os sistemas operacionais nos quais
OpenGL foi implementada, e produz o mesmo efeito de exibição em cada
um destes sistemas.</p></div>
<div class="paragraph"><p>Diante das funcionalidades providas pelo OpenGL, tal biblioteca tem se
tornado um padrão amplamente adotado na indústria de desenvolvimento
de aplicações. Este fato tem sido encorajado também pela facilidade de
aprendizado, pela estabilidade das rotinas, pela boa documentação
disponível <a href="#Neider2000">[Neider2000]</a> e pelos resultados visuais consistentes para
qualquer sistema de exibição concordante com este padrão. É possível
encontrar na Internet diversos <em>sites</em> que tratam sobre OpenGL; o mais
popular é a sua página oficial: <a href="http://www.opengl.org">http://www.opengl.org</a>. Neste
endereço encontram-se disponíveis diversos artigos e <em>links</em> sobre o
assunto, fóruns de discussão, informações sobre a evolução desse
padrão, além de uma série de programas utilitários.</p></div>
<div class="paragraph"><p>Diversos jogos, aplicações científicas e comerciais tem utilizado
OpenGL como ferramenta de apresentação de recursos visuais,
principalmente com a adoção deste padrão por parte dos fabricantes de
placas de vídeo destinadas aos consumidores domésticos.</p></div>
<div class="paragraph"><p>Todas as rotinas do OpenGL são implementadas em C, tornando fácil sua
utilização em qualquer programa escrito em C ou C++.</p></div>
<div class="paragraph"><p>Entre os recursos gráficos disponíveis pelo OpenGL, podem ser
destacados os seguintes:
- Modos de desenho de pontos (escrita/xor/transparência);
- Ajuste de largura de linhas;
- Aplicação de transparência;
- Ativação/desativação de serrilhamento (<em>aliasing</em>);
- Mapeamento de superfícies com textura;
- Seleção de janela de desenho;
- Manipulação de fontes/tipos de iluminação e sombreamento;
- Transformação de sistemas de coordenadas.
- Transformações em perspectiva
- Combinação de imagens (<em>blending</em>)</p></div>
<div class="paragraph"><p>Diversos desenvolvedores de software possuem suas próprias
implementações do OpenGL. Entre as implementações mais populares,
destacam-se aquelas providas pela Microsoft, a biblioteca
compartilhada dinâmica <em>opengl32.dll</em>, pela própria SGI, <em>opengl.dll</em>,
e o pacote Mesa3D <a href="http://www.mesa3d.org">http://www.mesa3d.org</a>. Esta última é uma
implementação <em>Opengl conformant</em>, ou seja, possui funcionalidades
semelhantes às do OpenGL, além de ser completamente gratuita e
funcionar nos sistemas operacionais Windows 9x/NT, MS-DOS e Unix,
facilitando ainda mais a portabilidade de aplicações.</p></div>
<div class="paragraph"><p>As implementações do OpenGL geralmente provêem bibliotecas auxiliares,
tais como a GLU (<em>OpenGL Utility library</em>), utilizada para realizar
tarefas comuns, tais como manipulação de matrizes, geração de
superfícies e construção de objetos por composição.</p></div>
<div class="paragraph"><p>As especificações do OpenGL não descrevem as interações entre OpenGL e
o sistema de janelas utilizado (Windows, X Window etc). Assim, tarefas
comuns em uma aplicação, tais como criar janelas gráficas, gerenciar
eventos provenientes de mouse e teclado, e apresentação de menus ficam
a cargo de bibliotecas próprias de cada sistema operacional. Neste
contexto, merece destaque a <em>OpenGL Utility Toolkit</em> (GLUT), uma
biblioteca que permite criar janelas, menus, manipular eventos, entre
outras coisas, independentemente do sistema operacional
utilizado. Aplicações escritas em OpenGL/GLUT podem ser compiladas em
Windows ou Unix, sem necessidade de alterações em seus códigos. GLUT
também foi desenvolvida pela SGI. No <em>site</em> oficial da GLUT
<a href="http://reality.sgi.com/mjk/glut3">http://reality.sgi.com/mjk/glut3</a> estão disponíveis o código fonte
dessa biblioteca, versões pré-compiladas para alguns sistemas
operacionais, e toda a documentação incluída.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_operação_normal_programas_criados_com_opengl_podem_se_tornar">Operação normal == Programas criados com OpenGL podem se tornar</h2>
<div class="sectionbody">
<div class="paragraph"><p>bastante complicados, diante do volume de operações que podem ser
realizadas. Entretanto, a estrutura básica de vários programas é
relativamente simples, geralmente possuindo a seguinte seqüência de
operações:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<strong>Abra uma janela gráfica</strong>
</dt>
<dd>
<p>
Lembre-se que as funções do OpenGL são
  independentes do sistema operacional utilizado. Logo, você terá que
  utilizar uma ou mais bibliotecas auxiliares que permitam abrir uma
  janelas na tela do computador, tais como GLUT, WGL (para Windows),
  glX (para o sistema XWindow), AGL (para Apple) ou PGL (para OS/2).
</p>
</dd>
<dt class="hdlist1">
<strong>Prepare OpenGL para desenhar na janela</strong>
</dt>
<dd>
<p>
Defina como OpenGL irá
  desenhar nesta janela, por exemplo, se será utilizado <em>double
  buffering</em> ou <em>single buffering</em>, e se as imagens serão geradas
  utilizando mapa de cores indexado ou diretamente no formato RGB.
</p>
</dd>
<dt class="hdlist1">
<strong>Defina o sistema de coordenadas e o estado inicial do OpenGL</strong>
</dt>
<dd>
<p>
  Indique as características do sistema de coordenadas a ser
  utilizado, por exemplo, os limites inferior e superior dos eixos
  coordenados. Defina as fontes de luz existentes, cores para desenho
  de polígonos, modos de preenchimento de superfícies etc.
</p>
</dd>
<dt class="hdlist1">
<strong>Loop</strong>
</dt>
<dd>
<div class="ulist"><ul>
<li>
<p>
Trate os eventos de mouse e teclado
</p>
</li>
<li>
<p>
Mude a cena com base nos eventos ocorridos;
</p>
</li>
<li>
<p>
Redesenhe a cena com OpenGL.
</p>
</li>
</ul></div>
</dd>
</dl></div>
</div>
</div>
<div class="sect1">
<h2 id="_compilando_programas_que_utilizam_opengl">Compilando programas que utilizam OpenGL</h2>
<div class="sectionbody">
<div class="paragraph"><p>Todos os programas deste curso foram criados e testados em um ambiente
Linux e utilizando FreeGLUT como biblioteca auxiliar para manipular
janelas e tratar eventos. Esta escolha pode ser justificada por duas
razões principais:
- O Linux é um sistema operacional confiável. Um programa escrito em C
  padrão, compilado e testado no Linux, também funcionará a contento
  em outros sistemas, principalmente se for compilado com a mesma
  ferramenta utilizada para compilar os exemplos deste curso, o <em>gcc</em>,
  da GNU (<a href="http://www.gnu.org">http://www.gnu.org</a>). Além de ser gratuito, este
  compilador é bastante otimizado e possui versões disponíveis para a
  maioria dos sistemas operacionais existentes.
- O GLUT está implementado em diversos sistemas operacionais,
  facilitando a portabilidade de programas.</p></div>
<div class="paragraph"><p>As tarefas de compilação foram automatizadas com o utilitário
<em>make</em>. O <em>make</em> determina automaticamente que partes de um grande
programa necessitam ser recompiladas e os comandos necessários para
recompilá-las, a partir da leitura das regras definidas em um arquivo
<em>Makefile</em>. Assim, para efetuar a compilação do programa, basta
executar o comando <em>make</em>, ao invés de digitar dezenas de comandos no
prompt do Unix.</p></div>
<div class="paragraph"><p>O <a href="exemplos/Makefile">Makefile</a> do <a href="#exemplo_Makefile">Exemplo</a> foi
utilizado para compilar os exemplos desse curso. Para obter uma cópia
deste arquivo clique <a href="exemplos/Makefile">aqui</a>.</p></div>
<div class="listingblock">
<a id="exemplo_makefile"></a>
<div class="title">Makefile</div>
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="font-style: italic"><span style="color: #9A1900"># Compila programas do curso de OpenGL</span></span>
<span style="font-style: italic"><span style="color: #9A1900"># digite: make programa.c</span></span>
<span style="font-style: italic"><span style="color: #9A1900">#</span></span>

<span style="color: #009900">CC =</span> g<span style="color: #990000">++</span>
<span style="color: #009900">CFLAGS =</span> -O<span style="color: #993399">2</span>
<span style="color: #009900">XLIBS =</span> -L/usr/X<span style="color: #993399">11</span>/lib -L/usr/X11R6/lib -lX<span style="color: #993399">11</span>

<span style="font-style: italic"><span style="color: #9A1900">##### MACROS #####</span></span>

<span style="color: #009900">INCDIR =</span> /usr/include
<span style="color: #009900">LIBDIR =</span> /usr/lib

<span style="color: #009900">GL_LIBS =</span> -L<span style="color: #009900">$(LIBDIR)</span> -lglut -lGLU -lGL -lm <span style="color: #009900">$(XLIBS)</span>

<span style="color: #009900">LIB_DEP =</span> <span style="color: #009900">$(LIBDIR)/$(GL_LIB)</span>

<span style="font-style: italic"><span style="color: #9A1900">##### RULES #####</span></span>

<span style="font-weight: bold"><span style="color: #000080">.SUFFIXES:</span></span>
<span style="font-weight: bold"><span style="color: #000080">.SUFFIXES:</span></span> .c .cpp

<span style="font-weight: bold"><span style="color: #000080">.c:</span></span> <span style="color: #009900">$(LIB_DEP)</span>
        <span style="color: #009900">$(CC)</span> -I<span style="color: #009900">$(INCDIR)</span> <span style="color: #009900">$(CFLAGS)</span> <span style="color: #009900">$&lt;</span> -o <span style="color: #009900">$@</span> <span style="color: #009900">$(GL_LIBS)</span>

<span style="font-style: italic"><span style="color: #9A1900">##### TARGETS ######</span></span>

<span style="color: #990000">clean:</span>
        -rm <span style="color: #990000">*</span>.o <span style="color: #990000">*~</span></tt></pre></div></div>
<div class="paragraph"><p>As regras contidas neste arquivo Makefile incluem opções de compilação
tais como <em>-lglut</em>, referente à biblioteca auxiliar GLUT, e <em>-lGLU
-lGL</em>, referentes às bibliotecas padrão do OpenGL para o Mesa3d,
possibilitando que programas simples possam ser fácilmente compilados.</p></div>
<div class="paragraph"><p>Para testar se esse arquivo funciona no seu sistema, copie-o para um
diretório, juntamente com o programa
<a href="exemplos/teste-make.c">teste-make.c</a>. Dentro deste diretório,
execute a seguinte seqüência de comandos:</p></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>$ make teste-make
$ <span style="color: #990000">.</span>/teste-make</tt></pre></div></div>
<div class="paragraph"><p>Caso apareça um quadrado com cores variáveis dentro de uma janela com
fundo branco, é sinal de que ocorreu tudo bem.</p></div>
<div class="listingblock">
<div class="title">teste-make.c</div>
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="font-style: italic"><span style="color: #9A1900">/* programa teste-make.c */</span></span>

<span style="font-weight: bold"><span style="color: #000080">#include</span></span> <span style="color: #FF0000">&lt;GL/glut.h&gt;</span>
<span style="font-weight: bold"><span style="color: #000080">#include</span></span> <span style="color: #FF0000">&lt;stdlib.h&gt;</span>
<span style="font-weight: bold"><span style="color: #000080">#include</span></span> <span style="color: #FF0000">&lt;stdio.h&gt;</span>

<span style="color: #009900">void</span> <span style="font-weight: bold"><span style="color: #000000">display</span></span><span style="color: #990000">(</span><span style="color: #009900">void</span><span style="color: #990000">);</span>
<span style="color: #009900">void</span> <span style="font-weight: bold"><span style="color: #000000">timer</span></span><span style="color: #990000">(</span><span style="color: #009900">int</span><span style="color: #990000">);</span>
<span style="color: #009900">void</span> <span style="font-weight: bold"><span style="color: #000000">keyboard</span></span><span style="color: #990000">(</span><span style="color: #009900">unsigned</span> <span style="color: #009900">char</span> key<span style="color: #990000">,</span> <span style="color: #009900">int</span> x<span style="color: #990000">,</span> <span style="color: #009900">int</span> y<span style="color: #990000">);</span>

<span style="font-style: italic"><span style="color: #9A1900">/* cores do quadrado */</span></span>
<span style="color: #008080">GLfloat</span> r<span style="color: #990000">=</span><span style="color: #993399">1.0</span><span style="color: #990000">,</span> g<span style="color: #990000">=</span><span style="color: #993399">0.5</span><span style="color: #990000">,</span> b<span style="color: #990000">=</span><span style="color: #993399">0.0</span><span style="color: #990000">;</span>

<span style="color: #009900">int</span> <span style="font-weight: bold"><span style="color: #000000">main</span></span><span style="color: #990000">(</span><span style="color: #009900">int</span> argc<span style="color: #990000">,</span> <span style="color: #009900">char</span><span style="color: #990000">**</span> argv<span style="color: #990000">)</span><span style="color: #FF0000">{</span>
  <span style="font-weight: bold"><span style="color: #000000">glutInit</span></span><span style="color: #990000">(&amp;</span>argc<span style="color: #990000">,</span> argv<span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glutInitDisplayMode</span></span> <span style="color: #990000">(</span>GLUT_SINGLE <span style="color: #990000">|</span> GLUT_RGB<span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glutInitWindowSize</span></span> <span style="color: #990000">(</span><span style="color: #993399">256</span><span style="color: #990000">,</span> <span style="color: #993399">256</span><span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glutInitWindowPosition</span></span> <span style="color: #990000">(</span><span style="color: #993399">100</span><span style="color: #990000">,</span> <span style="color: #993399">100</span><span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glutCreateWindow</span></span> <span style="color: #990000">(</span>argv<span style="color: #990000">[</span><span style="color: #993399">0</span><span style="color: #990000">]);</span>
  <span style="font-style: italic"><span style="color: #9A1900">// inicia um temporizador. após 33ms ativa a funcao timer</span></span>
  <span style="font-weight: bold"><span style="color: #000000">glutTimerFunc</span></span><span style="color: #990000">(</span><span style="color: #993399">33</span><span style="color: #990000">,</span> timer<span style="color: #990000">,</span> <span style="color: #993399">1</span><span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glClearColor</span></span><span style="color: #990000">(</span><span style="color: #993399">1.0</span><span style="color: #990000">,</span> <span style="color: #993399">1.0</span><span style="color: #990000">,</span> <span style="color: #993399">1.0</span><span style="color: #990000">,</span> <span style="color: #993399">0.0</span><span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glShadeModel</span></span> <span style="color: #990000">(</span>GL_FLAT<span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glOrtho</span></span> <span style="color: #990000">(</span><span style="color: #993399">0</span><span style="color: #990000">,</span> <span style="color: #993399">1</span><span style="color: #990000">,</span> <span style="color: #993399">0</span><span style="color: #990000">,</span> <span style="color: #993399">1</span><span style="color: #990000">,</span> <span style="color: #990000">-</span><span style="color: #993399">1</span> <span style="color: #990000">,</span><span style="color: #993399">1</span><span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glutDisplayFunc</span></span><span style="color: #990000">(</span>display<span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glutMainLoop</span></span><span style="color: #990000">();</span>
  <span style="font-weight: bold"><span style="color: #0000FF">return</span></span> <span style="color: #993399">0</span><span style="color: #990000">;</span>
<span style="color: #FF0000">}</span>

<span style="color: #009900">void</span> <span style="font-weight: bold"><span style="color: #000000">timer</span></span><span style="color: #990000">(</span><span style="color: #009900">int</span> value<span style="color: #990000">)</span><span style="color: #FF0000">{</span>
  r<span style="color: #990000">=</span>r<span style="color: #990000">+</span><span style="color: #993399">0.01</span><span style="color: #990000">;</span>
  g<span style="color: #990000">=</span>g<span style="color: #990000">+</span><span style="color: #993399">0.01</span><span style="color: #990000">;</span>
  b<span style="color: #990000">=</span>b<span style="color: #990000">+</span><span style="color: #993399">0.01</span><span style="color: #990000">;</span>
  <span style="font-weight: bold"><span style="color: #0000FF">if</span></span><span style="color: #990000">(</span>r<span style="color: #990000">&gt;</span><span style="color: #993399">1</span><span style="color: #990000">)</span> r<span style="color: #990000">=</span><span style="color: #993399">0</span><span style="color: #990000">;</span>
  <span style="font-weight: bold"><span style="color: #0000FF">if</span></span><span style="color: #990000">(</span>g<span style="color: #990000">&gt;</span><span style="color: #993399">1</span><span style="color: #990000">)</span> g<span style="color: #990000">=</span><span style="color: #993399">0</span><span style="color: #990000">;</span>
  <span style="font-weight: bold"><span style="color: #0000FF">if</span></span><span style="color: #990000">(</span>b<span style="color: #990000">&gt;</span><span style="color: #993399">1</span><span style="color: #990000">)</span> b<span style="color: #990000">=</span><span style="color: #993399">0</span><span style="color: #990000">;</span>
  <span style="font-weight: bold"><span style="color: #000000">glutPostRedisplay</span></span><span style="color: #990000">();</span>
  <span style="font-weight: bold"><span style="color: #000000">glutTimerFunc</span></span><span style="color: #990000">(</span><span style="color: #993399">33</span><span style="color: #990000">,</span> timer<span style="color: #990000">,</span> <span style="color: #993399">1</span><span style="color: #990000">);</span>
<span style="color: #FF0000">}</span>

<span style="color: #009900">void</span> <span style="font-weight: bold"><span style="color: #000000">display</span></span><span style="color: #990000">(</span><span style="color: #009900">void</span><span style="color: #990000">)</span><span style="color: #FF0000">{</span>
  <span style="color: #009900">int</span> i<span style="color: #990000">;</span>
  <span style="font-weight: bold"><span style="color: #000000">glClear</span></span><span style="color: #990000">(</span>GL_COLOR_BUFFER_BIT<span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glColor3f</span></span> <span style="color: #990000">(</span>r<span style="color: #990000">,</span> g<span style="color: #990000">,</span> b<span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glBegin</span></span><span style="color: #990000">(</span>GL_POLYGON<span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glVertex2f</span></span><span style="color: #990000">(</span><span style="color: #993399">0.25</span><span style="color: #990000">,</span><span style="color: #993399">0.25</span><span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glVertex2f</span></span><span style="color: #990000">(</span><span style="color: #993399">0.75</span><span style="color: #990000">,</span><span style="color: #993399">0.25</span><span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glVertex2f</span></span><span style="color: #990000">(</span><span style="color: #993399">0.75</span><span style="color: #990000">,</span><span style="color: #993399">0.75</span><span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glVertex2f</span></span><span style="color: #990000">(</span><span style="color: #993399">0.25</span><span style="color: #990000">,</span><span style="color: #993399">0.75</span><span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glEnd</span></span><span style="color: #990000">();</span>
  <span style="font-weight: bold"><span style="color: #000000">glFlush</span></span><span style="color: #990000">();</span>
<span style="color: #FF0000">}</span></tt></pre></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_exercícios">Exercícios</h2>
<div class="sectionbody">
<div class="ulist"><ul>
<li>
<p>
Utilizando o programa <a href="exemplos/teste-make.c">exemplos/teste-make.c</a> como referência,
  implemente um programa <em>quadrados4.c</em>. Este programa deverá desenhar
  numa janela com fundo branco, de dimensões 256x256 pixels, e quatro
  quadrados de cores diferentes arranjados na janela.
</p>
</li>
<li>
<p>
Utilizando o programa <a href="exemplos/teste-make.c">exemplos/teste-make.c</a> como referência,
      implemente um programa <em>quadradoscolor.c</em>. Este programa deverá
      desenhar numa janela com fundo branco, de dimensões 256x256
      pixels, um quadrado com as mesmas dimensões do quadrado
      original. Entretanto, cada uma das cores determinadas para os
      quatro vértices do quadrado deverão ser determinadas a partir de
      valores calculados via modelo HSI. Implemente um temporizador
      para os valores de H mudarem com o tempo para os vértices,
      produzindo uma pequena animação. Comente a linha
      <em>glShadeModel(GL_FLAT)</em> para que o feito de degradê possa ser
      visualizado.
</p>
</li>
</ul></div>
</div>
</div>
<h1 id="_desenhando_linhas_e_pontos">Desenhando linhas e pontos</h1>
<div class="paragraph"><p>O propósito desta lição é entender recursos fundamentais da biblioteca
    OpenGL e da biblioteca auxiliar GLUT, tais como abrir uma janela,
    definir sistemas de coordenadas, limpar a tela e especificar cores
    de desenho. Este propósito será alcançado através da análise do
    programa <a href="exemplos/linha.c">exemplos/linha.c</a> , mostrado no
    <a href="#exa_linha">Exemplo</a>, cuja única funcionalidade desenhar uma reta
    entre dois pontos de uma janela gráfica.</p></div>
<div class="listingblock">
<a id="exa_linha"></a>
<div class="title">linha.c</div>
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="font-weight: bold"><span style="color: #000080">#include</span></span> <span style="color: #FF0000">&lt;GL/glut.h&gt;</span>
<span style="font-weight: bold"><span style="color: #000080">#include</span></span> <span style="color: #FF0000">&lt;stdlib.h&gt;</span>

<span style="color: #009900">void</span> <span style="font-weight: bold"><span style="color: #000000">init</span></span><span style="color: #990000">(</span><span style="color: #009900">void</span><span style="color: #990000">);</span>
<span style="color: #009900">void</span> <span style="font-weight: bold"><span style="color: #000000">display</span></span><span style="color: #990000">(</span><span style="color: #009900">void</span><span style="color: #990000">);</span>
<span style="color: #009900">void</span> <span style="font-weight: bold"><span style="color: #000000">keyboard</span></span><span style="color: #990000">(</span><span style="color: #009900">unsigned</span> <span style="color: #009900">char</span> key<span style="color: #990000">,</span> <span style="color: #009900">int</span> x<span style="color: #990000">,</span> <span style="color: #009900">int</span> y<span style="color: #990000">);</span>

<span style="color: #009900">int</span> <span style="font-weight: bold"><span style="color: #000000">main</span></span><span style="color: #990000">(</span><span style="color: #009900">int</span> argc<span style="color: #990000">,</span> <span style="color: #009900">char</span><span style="color: #990000">**</span> argv<span style="color: #990000">)</span><span style="color: #FF0000">{</span>
  <span style="font-weight: bold"><span style="color: #000000">glutInit</span></span><span style="color: #990000">(&amp;</span>argc<span style="color: #990000">,</span> argv<span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glutInitDisplayMode</span></span> <span style="color: #990000">(</span>GLUT_SINGLE <span style="color: #990000">|</span> GLUT_RGB<span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glutInitWindowSize</span></span> <span style="color: #990000">(</span><span style="color: #993399">256</span><span style="color: #990000">,</span> <span style="color: #993399">256</span><span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glutInitWindowPosition</span></span> <span style="color: #990000">(</span><span style="color: #993399">100</span><span style="color: #990000">,</span> <span style="color: #993399">100</span><span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glutCreateWindow</span></span> <span style="color: #990000">(</span><span style="color: #FF0000">"Desenhando uma linha"</span><span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">init</span></span><span style="color: #990000">();</span>
  <span style="font-weight: bold"><span style="color: #000000">glutDisplayFunc</span></span><span style="color: #990000">(</span>display<span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glutKeyboardFunc</span></span><span style="color: #990000">(</span>keyboard<span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glutMainLoop</span></span><span style="color: #990000">();</span>
  <span style="font-weight: bold"><span style="color: #0000FF">return</span></span> <span style="color: #993399">0</span><span style="color: #990000">;</span>
<span style="color: #FF0000">}</span>

<span style="color: #009900">void</span> <span style="font-weight: bold"><span style="color: #000000">init</span></span><span style="color: #990000">(</span><span style="color: #009900">void</span><span style="color: #990000">)</span><span style="color: #FF0000">{</span>
  <span style="font-weight: bold"><span style="color: #000000">glClearColor</span></span><span style="color: #990000">(</span><span style="color: #993399">1.0</span><span style="color: #990000">,</span> <span style="color: #993399">1.0</span><span style="color: #990000">,</span> <span style="color: #993399">1.0</span><span style="color: #990000">,</span> <span style="color: #993399">1.0</span><span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glOrtho</span></span> <span style="color: #990000">(</span><span style="color: #993399">0</span><span style="color: #990000">,</span> <span style="color: #993399">256</span><span style="color: #990000">,</span> <span style="color: #993399">0</span><span style="color: #990000">,</span> <span style="color: #993399">256</span><span style="color: #990000">,</span> <span style="color: #990000">-</span><span style="color: #993399">1</span> <span style="color: #990000">,</span><span style="color: #993399">1</span><span style="color: #990000">);</span>
<span style="color: #FF0000">}</span>

<span style="color: #009900">void</span> <span style="font-weight: bold"><span style="color: #000000">display</span></span><span style="color: #990000">(</span><span style="color: #009900">void</span><span style="color: #990000">)</span><span style="color: #FF0000">{</span>
  <span style="color: #009900">int</span> i<span style="color: #990000">;</span>
  <span style="font-weight: bold"><span style="color: #000000">glClear</span></span><span style="color: #990000">(</span>GL_COLOR_BUFFER_BIT<span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glColor3f</span></span> <span style="color: #990000">(</span><span style="color: #993399">0.0</span><span style="color: #990000">,</span> <span style="color: #993399">0.0</span><span style="color: #990000">,</span> <span style="color: #993399">0.0</span><span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glBegin</span></span><span style="color: #990000">(</span>GL_LINES<span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glVertex2i</span></span><span style="color: #990000">(</span><span style="color: #993399">40</span><span style="color: #990000">,</span><span style="color: #993399">200</span><span style="color: #990000">);</span>  <span style="font-weight: bold"><span style="color: #000000">glVertex2i</span></span><span style="color: #990000">(</span><span style="color: #993399">200</span><span style="color: #990000">,</span><span style="color: #993399">10</span><span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glEnd</span></span><span style="color: #990000">();</span>
  <span style="font-weight: bold"><span style="color: #000000">glFlush</span></span><span style="color: #990000">();</span>
<span style="color: #FF0000">}</span>

<span style="color: #009900">void</span> <span style="font-weight: bold"><span style="color: #000000">keyboard</span></span><span style="color: #990000">(</span><span style="color: #009900">unsigned</span> <span style="color: #009900">char</span> key<span style="color: #990000">,</span> <span style="color: #009900">int</span> x<span style="color: #990000">,</span> <span style="color: #009900">int</span> y<span style="color: #990000">)</span><span style="color: #FF0000">{</span>
  <span style="font-weight: bold"><span style="color: #0000FF">switch</span></span> <span style="color: #990000">(</span>key<span style="color: #990000">)</span> <span style="color: #FF0000">{</span>
  <span style="font-weight: bold"><span style="color: #0000FF">case</span></span> <span style="color: #993399">27</span><span style="color: #990000">:</span>
        <span style="font-weight: bold"><span style="color: #000000">exit</span></span><span style="color: #990000">(</span><span style="color: #993399">0</span><span style="color: #990000">);</span>
        <span style="font-weight: bold"><span style="color: #0000FF">break</span></span><span style="color: #990000">;</span>
  <span style="color: #FF0000">}</span>
<span style="color: #FF0000">}</span></tt></pre></div></div>
<div class="paragraph"><p>Para compilar e executar o programa <a href="exemplos/linha.c">linha.c</a>,
salve-o juntamente com o arquivo <a href="exemplos/Makefile">Makefile</a>
em um diretório e execute a seguinte seqüência de comandos:</p></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>$ make linha
$ <span style="color: #990000">.</span>/linha</tt></pre></div></div>
<div class="paragraph"><p>A saída do programa <em>linha</em> é mostrado na figura <a href="#fig_linha">[fig_linha]</a></p></div>
<div class="paragraph" id="fig_linha"><div class="title">Saída do programa linha</div><p><span class="image">
<img alt="Saida do programa linha"
src="data:image/jpeg;base64,
/9j/4AAQSkZJRgABAQAAAQABAAD//gBIQ1JFQVRPUjogWFYgVmVyc2lvbiAzLjEwYSAgUmV2OiAx
Mi8yOS85NCAgUXVhbGl0eSA9IDc1LCBTbW9vdGhpbmcgPSAwCv/bAEMACAYGBwYFCAcHBwkJCAoM
FA0MCwsMGRITDxQdGh8eHRocHCAkLicgIiwjHBwoNyksMDE0NDQfJzk9ODI8LjM0Mv/bAEMBCQkJ
DAsMGA0NGDIhHCEyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIy
MjIyMv/AABEIARcBBgMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/
xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKC
CQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaH
iImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp
6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAME
BwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYn
KCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeY
mZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/
2gAMAwEAAhEDEQA/ALPxD+IeseEvEVppmmWemyxSWUM37+23uWbIPII9P1rk5fjR4shx5ul6RHnp
vsSM/wDj1R/G/wD5HWy/7BcH82rk7a6F7bR2N8U3uQUdj82Ox/3j29f/AEL2HCFKhTq+zUl9rvbu
u9up14HDU8VKVOU+WX2ezfZ9r9Gdb/wu3xPtDf2fou0nAP2I4z/3170n/C7/ABN/z4aJ/wCAZ/8A
iq4HUrWa1udkoGzGIyo+Xb6D/P55zXrt1pGhW/gOGaLRvtNlJ4XWZrmKzgEcV6W5ka8Z1fzBJ8ph
GeDgA/drrUMI6cKigmpdv63OTEUalCrKlO6ce/8AX9IwP+F3+Jv+fDRP/AM//FUf8Lv8Tf8APhon
/gGf/iq6rVNA0ZEc3Oi6RBePe6YniaBSI4tJiZlx9nYIoUSD75V225I5HzDTXw1oV34ustL1Hw5t
WbWb6GKSXT4LFHthbSfu0WN98qqwRlmK8ZGCp4ObeESv7P8Aq1/68tTL3u5wX/C7/E3/AD4aJ/4B
n/4qj/hd/ib/AJ8NE/8AAM//ABVdN4Y0/Tda/wCEB+3aRpb/ANvxalFqOywhj8xYd/lldqjy2Gfv
JtY4GScDBeaDpI8MrJPo2lxWR8ER3bXaxosn23K+UWYHKsxzjp5hLAl9uFprCqXK6f8AV2v0D3u5
g3vxh8Y6bdvaX2jaXa3MeN8M+nsjrkZGVJyOCD+NV/8Ahd/ib/nw0T/wDP8A8VXpHiDSba88Y389
rpVrqF+/ibT7e/Elol00dibWMklWVvLQnd84A6deOOd0fQdJvrTUbTTdG0uCxhutQ8nVLqNL60uo
1LgJNKp8202p5ZRw4BAZvmJGYi8K4qTproHvdzItfin48vtPm1C08OWVxZQbvNuItLd449o3NuYH
AwCCc9BUF78YfGOm3b2l9o2l2tzHjfDPp7I65GRlScjgg/jW34YE2k+C7jQ2t3tzceD9R1e4xOWW
dpnVImK9ARFGuP8AfPAOc72v6Noem6uFg8P6R+98YWViN1khCQvaQl1AxjBy3BBALFgAwDAaw6m4
umuoa23OGl+MPjGC0t7ubRtLjtrnd5Ez6ewSXacNtYnDYPBx0qv/AMLv8Tf8+Gif+AZ/+Kr0GPSN
KbUfBvhiXS7WfTJr3XrXZMpdo4klkwqMTlTkId4+cbRhhls87o3hi0u/BwguLCyuWu/Dks9j9i0w
EPdgsyr9rLGR7kbG3RKAoAYYwvLX1W13T/4a7X6B73cwP+F3+Jv+fDRP/AM//FUf8Lv8Tf8APhon
/gGf/iq81orv+o4f+RE8zPSv+F3+Jv8Anw0T/wAAz/8AFUf8Lv8AE3/Phon/AIBn/wCKrzWij6jh
/wCRBzM9K/4Xf4m/58NE/wDAM/8AxVH/AAu/xN/z4aJ/4Bn/AOKrzWij6jh/5EHMz0r/AIXf4m/5
8NE/8Az/APFUf8Lv8Tf8+Gif+AZ/+KrzWij6jh/5EHMz0r/hd/ib/nw0T/wDP/xVH/C7/E3/AD4a
J/4Bn/4qvNaKPqOH/kQczPSv+F3+Jv8Anw0T/wAAz/8AFVb0r4veLNX1iy0y3stBWa8uI7eNpLQh
QzsFBOCTjJ9K8qre8D/8j/4c/wCwpbf+jVqZ4LDxi2oIFJnu/mfEL/n68Ff+A1x/8RVS/wBT8fae
tuZJ/BrtcXUNrGqW0+S8jhF6oBgFsn2B6nirOt+M/D/h29S01W/+zzvGJVTyZHypJGcqpHUGm6td
Q31t4bu7Z98E+sadLG+CNytMhBweRwa+a9v/AHV9xtYo3XiXxPY3L2134i+HVvOmN0UxlRlyMjIK
5HBBqlq3jXxXpfh+bWo9R8E6haxSLERYRSykuSBgHaFyAQTkjj8Klb/hEv8AhIde/t7+xPtX2xNn
2/yt+z7NDjG/nGc+2c1zPiv+zf8AhB/EX9kfZPsP9sQeV9k2+V/qYM7dvHXOcd81cKylJJxX3A0d
xY33xBv9NtL1ZvBsaXVvHcIkltPuVXUMAcIRnBHQmpZLj4gQxPLJd+CgiKWY/ZrjgD/tnVLU4Ibj
4c6LFJp93eznT7H7KlplZUn8lNjrJjEW08lzwBnOc4NHQ7K/tDrP/CQwy3GutanOpAboJYMcJGQq
iPB+8mASfm5HQnWUZNKK+4SRwXjTxfqHjDwBY3t/HaxMmpvGEtovLUgRKQSMnJ+Y0VgXH/JL7T/s
Lyf+iUorPEJKo0hrY968WfCT/hPdWh1T+2/sPlWsVv5X2Tzc4XdnO9f7+MY7Vht+zgWYs3i0lick
nTuSf+/tez6R/wAerf8AAP8A0WlaFawx2IpxUYy0Xkv8g5UeGSfs7zzLtl8ZSOoOcNYEjP8A39qL
/hm7/qbP/Kd/9tr3iinHMMRBWjK3yX+Q53m7zd35ng//AAzd/wBTZ/5Tv/ttH/DN3/U2f+U7/wC2
17xRVf2liv5vwX+RPJE8H/4Zu/6mz/ynf/ba19d+B934h/sz7X4ngT+zrCKwi8rTCN0cedpbMxy3
JzjA9q9hopPMMS2m5beS/wAg5EeD/wDDN3/U2f8AlO/+20f8M3f9TZ/5Tv8A7bXvFFP+0sV/N+C/
yDkieD/8M3f9TZ/5Tv8A7bR/wzd/1Nn/AJTv/tte8UUf2liv5vwX+QckTwf/AIZu/wCps/8AKd/9
to/4Zu/6mz/ynf8A22veKKP7SxX834L/ACDkieD/APDN3/U2f+U7/wC20f8ADN3/AFNn/lO/+217
xRR/aWK/m/Bf5ByRPB/+Gbv+ps/8p3/22j/hm7/qbP8Aynf/AG2veKKP7SxX834L/IOSJ4P/AMM3
f9TZ/wCU7/7bR/wzd/1Nn/lO/wDtte8UUf2liv5vwX+QckTwf/hm7/qbP/Kd/wDbaP8Ahm7/AKmz
/wAp3/22veKKP7SxX834L/IOSJ4P/wAM3f8AU2f+U7/7bR/wzd/1Nn/lO/8Atte8UUf2liv5vwX+
QckTwf8A4Zu/6mz/AMp3/wBtqey/Z7uNOv7a+tPGHlXNtKs0Mn9mA7XUgqcGQg4IHWvcaKHmOJas
5fgv8g5EeUf8Kp8Vf9FIuv8AwXL/APF0x/hH4lkkgeT4iTuYJo549+mIwWRGDK2C/YgV61RXL7R+
X3L/ACHY8o/4VT4q/wCikXX/AILl/wDi6q6h8F9d1aza0v8A4gT3FuxDGN9NXGQcj/lpXsNFCqyT
urfcv8gseTp8JvFEcMMMfxFuEihiSGNF0xAFRFCqPv8AYAf1ob4TeKHQq3xHuWVhgg6apBH/AH3X
rFFDqybu7fcv8gsfLHxO8Ef8ID4R07Sv7Q+3ebfNceb5PlYzGFxjc39zOc96K679pL/jx0j/AK6f
0aipnNzfNLcZ7TpH/Hq3/AP/AEWlaFZ+kf8AHq3/AAD/ANFpWhUgFFFFABRRRQAUUUUAFFFFABRR
RQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAeDftJf8AHjpH/XT+jUUf
tJf8eOkf9dP6NRQB7TpH/Hq3/AP/AEWlaFZ+kf8AHq3/AAD/ANFpWhQAUUUUAFFFFABRRRQAUUUU
AFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB4N+0l/x46R/10/o1
FH7SX/HjpH/XT+jUUAe06R/x6t/wD/0WlaFZ+kf8erf8A/8ARaVoUAFFFFABRRWXqOpTaXe28lws
baZO8duZFB3wzO+1Cwz8yOzKvAypwTlWJjANSiiigAooooAKKKKACiiigAooooAKKKKACiiigAoo
ooAKKKKACiiigAooooAKKKKACiiigDwb9pL/AI8dI/66f0aij9pL/jx0j/rp/RqKAPadI/49W/4B
/wCi0rQrP0j/AI9W/wCAf+i0rQoAKKKKACo54Ibq3lt7iKOaCVCkkcihldSMEEHggjjFSUUAYdhP
NpWqf2NeSySW8iBtOuZ2JeT7xeBmOdzoqhgxO51J+8Y3c7lV76xt9Rs5LW6j8yF8EgMVIIIKsrDB
VgQCGBBBAIIIrP0a+uE2aRq0m7VYIgTNtCreIMAzIBwMkjcn8DMBypRnANiiiigAooooAKKKKACi
iigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAPBv2kv+PHSP+un9Goo/aS/48dI/wCu
n9GooA9p0j/j1b/gH/otK0Kz9I/49W/4B/6LStCgAooooAKKKKACs/WNM/tSzRI5vs91BKlxbThd
xjkU5HGQSpGUYAgsjsuRnNaFFAGfpmp/bvNt7iH7NqFvgXFsW3bc52urYG+NsHa2BnBBCsrKuhWX
qWmzPcLqWmtHFqUaBMSEiO5jBJ8qTAJxkkq4BKEkgEF0expWpQ6vpdvfwLIiTJkxygB4m6MjgE7X
VgVYdiCO1AFyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA8G/aS/
48dI/wCun9Goo/aS/wCPHSP+un9GooA9p0j/AI9W/wCAf+i0rQrP0j/j1b/gH/otK0KACiiigAoo
ooAKKKKACsPVIJtKuG1nTopJCzp9vtY1LefHkKZQo581F5+UEuq7ME+WU3KKAI4J4bq3iuLeWOaC
VA8ckbBldSMggjggjnNSVz83/FN6jcXp+XRLnD3AX7tnNli8xHaN8jeRgIy7yCHkdegoAKKKKACi
iigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAPBv2kv+PHSP+un9Goo/aS/48dI/wCu
n9GooA9p0j/j1b/gH/otK0Kz9I/49W/4B/6LStCgAooooAKKKKACiiigAooooAK5+w/4pj7NpM3/
ACCPkg0+4P8Ayw6KlvIfyVHP3uEb59pl6Cq99Y2+o2clrdR+ZC+CQGKkEEFWVhgqwIBDAgggEEEU
AWKKx9MvriHUZdF1GTzbqKITQXRUL9qiJKkkDA8xCAH2jb86MNu8IuxQAUUUUAFFFFABRRRQAUUU
UAFFFFABRRRQAUUUUAFFFFABRRRQB4N+0l/x46R/10/o1FH7SX/HjpH/AF0/o1FAHtOkf8erf8A/
9FpWhWfpH/Hq3/AP/RaVoUAFFFFABRRRQAUUUUAFFFFABRRRQBT1LTYdTt1jkaSKSNxJBcRECSCQ
AgOhIIzgkEEEEEqwKkg19E1Ka8t/s2oLHFq9siC8hQELuI+/HkkmJiGKn2IOGVlGpWXrWmzXiQ3V
g0cWp2jh4JHJAZdymSJiAfkkVdp4bB2uFLItAGpRVPTdSh1O3aSNZIpI3Mc9vKAJIJAASjgEjOCC
CCQQQykqQTcoAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigDwb9pL/jx0j/rp/RqKP2k
v+PHSP8Arp/RqKAPadI/49W/4B/6LStCs/SP+PVv+Af+i0rQoAKKKKACiiigAooooAKKKKACiiig
AooooAx9Qsbi21E61psfnXRiWG5tSwH2mJSzKFJ4WRS7lckK24q2Mq6aFhfW+p6dbX9nJ5lrdRJN
C+0jcjAFTg8jII61Yrn77/imZZNSh/5BUsoa9g6CBnYBrhD0VcndKDhcbpMhg4kAOgooooAKKKKA
CiiigAooooAKKKKACiiigAooooAKKKKAPBv2kv8Ajx0j/rp/RqKP2kv+PHSP+un9GooA9p0j/j1b
/gH/AKLStCs/SP8Aj1b/AIB/6LStCgAooooAKKKKACiiigAooooAKKKKACiiigAooooA5+2/4pvU
Vsm/d6JcbEsj1W1mJIMJP8MbfJ5Y5AbcmVBiSugqOeCG6t5be4ijmglQpJHIoZXUjBBB4II4xWPp
U82lPb6HqUskrhNlleysWN2qr0cn/luFBLD+MAuv8axgG5RRRQAUUUUAFFFFABRRRQAUUUUAFFFF
ABRRRQB4N+0l/wAeOkf9dP6NRR+0l/x46R/10/o1FAHtOkf8erf8A/8ARaVoVn6R/wAerf8AAP8A
0WlaFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAVT1TTYdWsGtJmkQF0kSSMgNHIjh0cZBG
VZVbBBBxggjIq5RQBl6VqU09xcabfrGupWiI8piB8uWNywSVMklQxRwUJJUqRlhtdtSs/U9M+3eV
cW832bULfJt7kLu25xuRlyN8bYG5cjOAQVZVZTRtT/tXTkmkh+zXaYju7Qtua2mwC0ZOBnGQQ2MM
pVhlWBIBoUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB4N+0l/x46R/10/o1FH7SX/HjpH/AF0/o1FA
HtOkf8erf8A/9FpWhWfpH/Hq3/AP/RaVoUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRR
QAVj6xY3CSpq2lx7tRh2LJGGAF1AGy0RzgFgC5jJI2ufvBWcNsUUAV7G+t9Rs47q1k8yF8gEqVII
JDKynBVgQQVIBBBBAIqxWHeQTaRqk+s2sUk9vcIi31tEpL/JkCeNR99wpCsuCzKibeUCPsQTw3Vv
FcW8sc0EqB45I2DK6kZBBHBBHOaAJKKKKACiiigAooooAKKKKACiiigDwb9pL/jx0j/rp/RqKP2k
v+PHSP8Arp/RqKAPadI/49W/4B/6LStCs/SP+PVv+Af+i0rQoAKKKKACiiigAooooAKKKKACiiig
AooooAKKKKACiiigAooooAK58f8AFLSwxDnQ5pUgiQdbKR2CIijvCzMqgDmMkAfuz+66Co54Ibq3
lt7iKOaCVCkkcihldSMEEHggjjFAElFYdhPNpWqf2NeSySW8iBtOuZ2JeT7xeBmOdzoqhgxO51J+
8Y3c7lABRRRQAUUUUAFFFFABRRRQB4N+0l/x46R/10/o1FH7SX/HjpH/AF0/o1FAHtOkf8erf8A/
9FpWhWfpH/Hq3/AP/RaVoUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFA
Fe+sbfUbOS1uo/MhfBIDFSCCCrKwwVYEAhgQQQCCCKz9GvrhNmkatJu1WCIEzbQq3iDAMyAcDJI3
J/AzAcqUZ9is/WNM/tSzRI5vs91BKlxbThdxjkU5HGQSpGUYAgsjsuRnNAGhRWfpmp/bvNt7iH7N
qFvgXFsW3bc52urYG+NsHa2BnBBCsrKuhQAUUUUAFFFFABRRRQB4N+0l/wAeOkf9dP6NRR+0l/x4
6R/10/o1FAHtOkf8erf8A/8ARaVoVn6R/wAerf8AAP8A0WlaFABRRRQAUUUUAFFFFABRRRQAUUUU
AFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAZepabM9wupaa0cWpRoExISI7mMEnypMAnGSSrgEoSSA
QXR7GlalDq+l29/AsiJMmTHKAHiboyOATtdWBVh2II7VcqvDY29veXN1FHsmudpmIY4cqMBivTdj
ALYyQqgkhVwAWKKKKACiiigAooooA8G/aS/48dI/66f0aij9pL/jx0j/AK6f0aigDat/jv4Qsg0S
SXEq/L8/lMucKq+nTipv+GgvCX925/74b/CiigA/4aC8Jf3bn/vhv8KP+GgvCX925/74b/CiigA/
4aC8Jf3bn/vhv8KP+GgvCX925/74b/CiigA/4aC8Jf3bn/vhv8KP+GgvCX925/74b/CiigA/4aC8
Jf3bn/vhv8KP+GgvCX925/74b/CiigA/4aC8Jf3bn/vhv8KP+GgvCX925/74b/CiigA/4aC8Jf3b
n/vhv8KP+GgvCX925/74b/CiigA/4aC8Jf3bn/vhv8KP+GgvCX925/74b/CiigA/4aC8Jf3bn/vh
v8KP+GgvCX925/74b/CiigA/4aC8Jf3bn/vhv8KP+GgvCX925/74b/CiigA/4aC8Jf3bn/vhv8KP
+GgvCX925/74b/CiigA/4aC8Jf3bn/vhv8KP+GgvCX925/74b/CiigA/4aC8Jf3bn/vhv8KP+Ggv
CX925/74b/CiigA/4aC8Jf3bn/vhv8KP+GgvCX925/74b/CiigA/4aC8Jf3bn/vhv8KP+GgvCX92
5/74b/CiigA/4aC8Jf3bn/vhv8KP+GgvCX925/74b/CiigDzP4v/ABC0XxxY2C6Y0gkglyyOhHGD
zkj3ooooA//Z">
</span></p></div>
<div class="sect1">
<h2 id="_descrição_do_programa_span_class_monospaced_linha_c_span">Descrição do programa <span class="monospaced">linha.c</span></h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="font-weight: bold"><span style="color: #000080">#include</span></span> <span style="color: #FF0000">&lt;GL/glut.h&gt;</span>
<span style="font-weight: bold"><span style="color: #000080">#include</span></span> <span style="color: #FF0000">&lt;stdlib.h&gt;</span></tt></pre></div></div>
<div class="paragraph"><p>Estes includes definem os protótipos das funções utilizadas pelo
programa. <span class="monospaced">stdlib.h</span> contém o protótipo da função <span class="monospaced">exit()</span>. O arquivo
de cabeçalho <span class="monospaced">glut.h</span> inclui, além dos protótipos das funções GLUT, os
arquivos <span class="monospaced">gl.h</span> e <span class="monospaced">glu.h</span>, que contém os protótipos das funções
principais e auxiliares do OpenGL.</p></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="color: #009900">void</span> <span style="font-weight: bold"><span style="color: #000000">init</span></span><span style="color: #990000">(</span><span style="color: #009900">void</span><span style="color: #990000">);</span>
<span style="color: #009900">void</span> <span style="font-weight: bold"><span style="color: #000000">display</span></span><span style="color: #990000">(</span><span style="color: #009900">void</span><span style="color: #990000">);</span>
<span style="color: #009900">void</span> <span style="font-weight: bold"><span style="color: #000000">keyboard</span></span><span style="color: #990000">(</span><span style="color: #009900">unsigned</span> <span style="color: #009900">char</span> key<span style="color: #990000">,</span> <span style="color: #009900">int</span> x<span style="color: #990000">,</span> <span style="color: #009900">int</span> y<span style="color: #990000">);</span></tt></pre></div></div>
<div class="paragraph"><p>Funções implementadas após a função <span class="monospaced">main()</span> devem ser prototipadas
aqui, de modo a evitar erros de compilação.</p></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="font-weight: bold"><span style="color: #000000">glutInit</span></span><span style="color: #990000">(&amp;</span>argc<span style="color: #990000">,</span> argv<span style="color: #990000">);</span></tt></pre></div></div>
<div class="paragraph"><p>Inicializa a biblioteca GLUT e negocia uma seção com o gerenciador de
janelas. É possível passar argumentos para a função glutInit
provenientes da linha de execução, tais como a variável de ambiente
<span class="monospaced">DISPLAY</span>, ou informações sobre a geometria da tela.</p></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="font-weight: bold"><span style="color: #000000">glutInitDisplayMode</span></span> <span style="color: #990000">(</span>GLUT_SINGLE <span style="color: #990000">|</span> GLUT_RGB<span style="color: #990000">);</span></tt></pre></div></div>
<div class="paragraph"><p>Informa à biblioteca GLUT o modo do display a ser utilizado quando a
janela gráfica for criada. O <em>flag</em> <span class="monospaced">GLUT_SINGLE</span> força o uso de uma
janela com <em>buffer</em> simples, significando que todos os desenhos serão
feitos diretamente nesta janela. O <em>flag</em> <span class="monospaced">GLUT_RGB</span> determina que o
modelo de cor utilizado será o modelo RGB.</p></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="font-weight: bold"><span style="color: #000000">glutInitWindowSize</span></span> <span style="color: #990000">(</span><span style="color: #993399">256</span><span style="color: #990000">,</span> <span style="color: #993399">256</span><span style="color: #990000">);</span>
<span style="font-weight: bold"><span style="color: #000000">glutInitWindowPosition</span></span> <span style="color: #990000">(</span><span style="color: #993399">100</span><span style="color: #990000">,</span> <span style="color: #993399">100</span><span style="color: #990000">);</span></tt></pre></div></div>
<div class="paragraph"><p>Define o tamanho inicial da janela, 256x256 pixels, e a posição
inicial do seu canto superior esquerdo na tela, (x, y)=(100, 100).</p></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="font-weight: bold"><span style="color: #000000">glutCreateWindow</span></span> <span style="color: #990000">(</span><span style="color: #FF0000">"Desenhando uma linha"</span><span style="color: #990000">);</span></tt></pre></div></div>
<div class="paragraph"><p>Cria uma janela e define seu título.</p></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="font-weight: bold"><span style="color: #000000">init</span></span><span style="color: #990000">();</span></tt></pre></div></div>
<div class="paragraph"><p>Nesta função é definido o estado inicial do OpenGL. Ajustes podem ser
feitos para o usuário nessa função.</p></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="font-weight: bold"><span style="color: #000000">glutDisplayFunc</span></span><span style="color: #990000">(</span>display<span style="color: #990000">);</span></tt></pre></div></div>
<div class="paragraph"><p>Define <span class="monospaced">display()</span> como a função de desenho (<em>display callback</em>) para
a janela corrente. Quando GLUT determina que esta janela deve ser
redesenhada, a função de desenho é chamada. A função de desenho deve
possuir o seguinte protótipo:</p></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="color: #009900">void</span> <span style="font-weight: bold"><span style="color: #000000">funcao</span></span><span style="color: #990000">(</span><span style="color: #009900">void</span><span style="color: #990000">);</span></tt></pre></div></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="font-weight: bold"><span style="color: #000000">glutKeyboardFunc</span></span><span style="color: #990000">(</span>keyboard<span style="color: #990000">);</span></tt></pre></div></div>
<div class="paragraph"><p>Indica que sempre que uma tecla for pressionada no teclado, GLUT
deverá chama a função &lt;function&gt;keyboard()&lt;/function&gt; para tratar
eventos de teclado (<em>keyboard callback</em>). A função de teclado deve
possuir o seguinte protótipo:</p></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="color: #009900">void</span> <span style="font-weight: bold"><span style="color: #000000">funcao</span></span><span style="color: #990000">(</span><span style="color: #009900">int</span> x<span style="color: #990000">,</span> <span style="color: #009900">int</span> y<span style="color: #990000">);</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="paragraph"><p>glutMainLoop();</p></div>
<div class="listingblock">
<div class="content monospaced">
<pre>Inicia o 'loop' de processamento de desenhos com GLUT. Esta rotina
deve ser chamada pelo menos uma vez em um programa que utilize a
biblioteca GLUT.

[source,c]</pre>
</div></div>
<div class="paragraph"><p>void init(void){
  glClearColor(1.0, 1.0, 1.0, 1.0);</p></div>
<div class="listingblock">
<div class="content monospaced">
<pre>Especifica as intensidade de vermelho ('RED'), verde ('GREEN') e azul
('BLUE') utilizadas para limpar a janela. Cada parâmetro pode varia de
0 a 1, o equivalente a uma variação de 0 a 255, usada convecionalmente
no sistema de janelas. O último argumento é o canal alfa, usado para
compor superfícies transparentes ou translucentes. Assume valores
entre 0 (totalmente transparente) e 1(totalmente opaco). Neste
exemplo, o canal alfa é mantido com valor igual a 1.

[source,c]</pre>
</div></div>
<div class="paragraph"><p>glOrtho (0, 256, 0, 256, -1 ,1);</p></div>
<div class="listingblock">
<div class="content monospaced">
<pre>A função glOrtho define as coordenadas do volume de recorte ('clipping
volume'), possuindo o seguinte protótipo:

[source,c]</pre>
</div></div>
<div class="paragraph"><p>void glOrtho(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);</p></div>
<div class="listingblock">
<div class="content monospaced">
<pre>Os parâmetros `left` e `right` especificam as coordenadas esquerda e
direita, respectivamente, dos planos de corte verticais. Os parâmetros
`bottom` e `top` especificam as coordenadas inferior e superior,
respectivamente, dos planos de corte horizontais. `zNear` e `zFar`,
por sua vez, especificam a coordenada mais próxima e mais distante do
observador, respectivamente, no eixo de profundidade. Assim, o volume
de recorte definido no exemplo será x~min~=0 e x~max~=256; y~min~=0 e
y~max~=256; z~min~=-1 e z~max~=1.

[source,c]</pre>
</div></div>
<div class="paragraph"><p>void display(void){
  int i;
  glClear(GL_COLOR_BUFFER_BIT);</p></div>
<div class="listingblock">
<div class="content monospaced">
<pre>A função `glClear()` serve para limpar 'buffers' utilizados pelo
OpenGL com valores pré-definidos. A máscara utilizada neste exemplo, o
parâmetro `GL_COLOR_BUFFER_BIT`, diz à função `glClear()` que apenas o
'buffer' de desenho deve ser limpo. Após a execução desta função, a
tela ficará branca, uma vez que a `init()` define (R, G, B)=(1.0, 1.0,
1.0) como cor de limpeza de tela.

[source,c]</pre>
</div></div>
<div class="paragraph"><p>glColor3f (0.0, 0.0, 0.0);</p></div>
<div class="listingblock">
<div class="content monospaced">
<pre>Especifica (R, G, B)=(0, 0, 0), preto, como a cor de desenho. Todos os
objetos desenhados a partir daqui terão cor preta.

[source,c]</pre>
</div></div>
<div class="paragraph"><p>glBegin(GL_LINES);
  glVertex2i(40,200);  glVertex2i(200,10);
  glEnd();</p></div>
<div class="listingblock">
<div class="content monospaced">
<pre>As funções `glBegin()` e `glEnd()` delimitam os vértices de uma
primitiva de desenho ou de um grupo de primitivas. O parâmetro passado
para a função especifica o tipo de primitiva a ser desenhado. Neste
exemplo, o parâmetro `GL_LINES` indica que os vértices especificados
devem ser tratados como pares de pontos que comporão segmentos de reta
independentes. A função `glVertex2i()` define as coordenadas de um
vértice.

[source,c]</pre>
</div></div>
<div class="paragraph"><p>void keyboard(unsigned char key, int x, int y){
  switch (key) {
  case 27:
        exit(0);
        break;
  }
}</p></div>
<div class="listingblock">
<div class="content monospaced">
<pre>Conforme mencionado, a função `keyboard()` serve para tratar eventos
de teclado. Sua implementação especifica que quando a tecla kbd:[ESC]
'keycode'=`27` for pressionada o programa deverá ser finalizado.

== Exercícios ==
- Utilizando o programa  link:exemplos/linha.c[] como
  referência, implemente um programa `quadrado.c`. Este programa deverá desenhar numa
  janela com fundo branco, de dimensões 256x256 pixels, um quadrado
  vermelho, com vértice superior esquerdo de coordenadas (x, y)= (30,
  226) e vértice inferior direito de coordenadas (x, y) = (226,
  30). Quando a tecla kbd:[a] for pressionada, o quadrado deverá
  ficar com a cor azul. Quando a tecla kbd:[v] for pressionada, o quadrado
  deverá voltar à cor vermelha.
- Implemente o algoritmo de Bresenham para traçado de linhas,
  utilizando `GL_POINTS` como parâmetro da função `glBegin()`. Este
  parâmetro indica que cada vértice deve ser tratado como um ponto
  simples. Utilizando o algoritmo implementado, desenhe uma reta verde
  do ponto (x, y)=(40, 200) ao ponto (x, y)=(200, 10).
- Implemente o algoritmo de Bresenham para traçado de circunferências,
      utilizando `GL_POINTS` como parâmetro da função
      `glBegin()`. Utilizando o algoritmo implementado, desenhe uma
      circunferência azul de raio r=50, centrada no ponto (x, y) =
      (128, 128).

[[preenchimento]]
= Preenchimento de regiões ==
    O propósito desta lição é aprender funções básicas do OpenGL que tratam do preenchimento de regiões. Será mostrado um programa de desenho de polígonos com preenchimento interno com cores sólidas, padrões e combinações de cores. O programa analisado, link:exemplos/preenchimento.c"&gt;&lt;filename&gt;preenchimento.c&lt;/filename&gt;&lt;/link&gt;, é mostrado no &lt;xref linkend="example-preenchimento"/&gt;.
    &lt;example xml:id="example-preenchimento"&gt;
      &lt;title&gt;programa link:exemplos/preenchimento.c"&gt;&lt;filename&gt;preenchimento.c&lt;/filename&gt;&lt;/link&gt;&lt;/title&gt;
      &lt;programlisting&gt;
        &lt;textobject&gt;&lt;textdata fileref="&amp;caminho;/exemplos/preenchimento.c" format="linespecific"/&gt;&lt;/textobject&gt;
      &lt;/programlisting&gt;
    &lt;/example&gt;
    Para compilar e executar o programa link:exemplos/preenchimento.c"&gt;&lt;filename&gt;preenchimento.c&lt;/filename&gt;&lt;/link&gt;, salve-o juntamente com o arquivo link:exemplos/Makefile"&gt;Makefile&lt;/link&gt; em um diretório e execute a seguinte seqüência de comandos:
    &lt;screen&gt;
&lt;prompt&gt;$&lt;/prompt&gt; &lt;command&gt;make&lt;/command&gt; &lt;option&gt;preenchimento&lt;/option&gt;
&lt;prompt&gt;$&lt;/prompt&gt; &lt;command&gt;preenchimento&lt;/command&gt;
&lt;/screen&gt;

    A saída do programa &lt;command&gt;preenchimento&lt;/command&gt; é mostrado na &lt;xref linkend="fig-preenchimento"/&gt;.
    &lt;figure xml:id="fig-preenchimento"&gt;
      &lt;title&gt;Saída do programa &lt;command&gt;preenchimento&lt;/command&gt;.&lt;/title&gt;
      &lt;mediaobject&gt;
        &lt;imageobject&gt;
          &lt;imagedata fileref="figs/preenchimento.jpg" format="JPG"/&gt;
        &lt;/imageobject&gt;
      &lt;/mediaobject&gt;
    &lt;/figure&gt;
    &lt;sect1&gt;
      &lt;title&gt;Descrição do programa &lt;filename&gt;preenchimento.c&lt;/filename&gt;&lt;/title&gt;
      Serão descritas aqui apenas as partes do programa que acrescentam conceitos novos em relação aos exemplos anteriores.
[source,c]</pre>
</div></div>
<div class="paragraph"><p>GLubyte tux[] = {
 0x0,  0x0,  0x0,  0x0,
 0x0,  0x0,  0x0,  0x0,
 0x0,  0x0,  0x0,  0x0,
 0x0,  0x0,  0x0,  0x0,
 0x0,  0x0,  0x0,  0x0,
 0x0,  0x0,  0x0,  0x0,
 0x0,  0x7f,  0xfe,  0x0,
 0x0,  0xc4,  0x23,  0x0,
 0x1,  0x83,  0x21,  0x80,
 0x1,  0x7,  0xe0,  0x80,
 0x1,  0x7,  0xf0,  0x80,
 0x1,  0x8f,  0xf9,  0x80,
 0x0,  0xff,  0xff,  0x0,
 0x0,  0x4f,  0xf1,  0x0,
 0x0,  0x6f,  0xf1,  0x0,
 0x0,  0x2f,  0xf3,  0x0,
 0x0,  0x27,  0xe2,  0x0,
 0x0,  0x30,  0x66,  0x0,
 0x0,  0x1b,  0x1c,  0x0,
 0x0,  0xb,  0x88,  0x0,
 0x0,  0xb,  0x98,  0x0,
 0x0,  0x8,  0x18,  0x0,
 0x0,  0xa,  0x90,  0x0,
 0x0,  0x8,  0x10,  0x0,
 0x0,  0xc,  0x30,  0x0,
 0x0,  0x6,  0x60,  0x0,
 0x0,  0x3,  0xc0,  0x0,
 0x0,  0x0,  0x0,  0x0,
 0x0,  0x0,  0x0,  0x0,
 0x0,  0x0,  0x0,  0x0,
 0x0,  0x0,  0x0,  0x0,
 0x0,  0x0,  0x0,  0x0
};
----      Define o vetor &lt;varname&gt;tux[]&lt;/varname&gt;, do tipo &lt;type&gt;GLubyte&lt;/type&gt;, para representar o padrão de preenchimento de polígonos utilizado neste exemplo.
      Existem dois métodos principais para preencher regiões utilizando padrões. O mais comum utiliza texturas, mas não será abordado nesta lição. O outro método consiste em definir um mapa de bits monocromático de 32x32 pixels, representando a máscara para o padrão que se deseja desenhar. O padrão utilizado neste exemplo é mostrado na &lt;xref linkend="fig-tuxfig"/&gt;.
      &lt;figure xml:id="fig-tuxfig"&gt;
        &lt;title&gt;Padrão de desenho "tux".&lt;/title&gt;
        &lt;mediaobject&gt;
          &lt;imageobject role="html"&gt;
            &lt;imagedata align="center" format="SVG" fileref="figs/tuxfig.jpg" scale="100"/&gt;
          &lt;/imageobject&gt;
        &lt;/mediaobject&gt;
      &lt;/figure&gt;
      A máscara de desenho (vetor &lt;varname&gt;tux[]&lt;/varname&gt;) é formada por um conjunto de números representados na forma hexadecimal. Para construir este vetor, toma-se cada linha do mapa de bits de baixo para cima. Cada 8 pixels de uma linha da figura equivalem aos bits componentes de um elemento do vetor. Os bits mais significativos ficam à esquerda e os menos significativos à direita. Seguindo esta receita, então a linha 8 da &lt;xref linkend="fig-tuxfig"/&gt;, representada pela seqüência de bits &lt;emphasis&gt;00000000110001000010001100000000&lt;/emphasis&gt;, equivalerá à seqüência "0x0,  0xc4,  0x23,  0x0" do array &lt;varname&gt;tux[]&lt;/varname&gt;.</p></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>  <span style="font-weight: bold"><span style="color: #000000">glutInitDisplayMode</span></span> <span style="color: #990000">(</span>GLUT_DOUBLE <span style="color: #990000">|</span> GLUT_RGB<span style="color: #990000">);</span>
<span style="color: #990000">----</span>       <span style="color: #008080">A</span> função `<span style="font-weight: bold"><span style="color: #000000">glutInitDisplayMode</span></span><span style="color: #990000">()</span>` avisa GLUT para <span style="color: #008080">utilizar</span> dois <span style="color: #FF0000">'buffers'</span> no desenho <span style="color: #008080">de</span> cenas<span style="color: #990000">:</span> um principal e <span style="color: #008080">outro</span> auxiliar<span style="color: #990000">.</span> Todos os objetos deverão desenhados no <span style="color: #008080">buffer</span> auxiliar<span style="color: #990000">.</span> Quando <span style="color: #008080">a</span> função `<span style="font-weight: bold"><span style="color: #000000">glutSwapBuffers</span></span><span style="color: #990000">()</span>` <span style="color: #008080">for</span> chamada<span style="color: #990000">,</span> o buffer auxiliar passa a ser <span style="color: #008080">o</span> principal<span style="color: #990000">,</span> e o principal toma o lugar <span style="color: #008080">do</span> auxiliar<span style="color: #990000">.</span> Assim<span style="color: #990000">,</span> a imagem gerada é apresentada de uma só vez <span style="color: #008080">na</span> tela<span style="color: #990000">,</span> evitando cintilações e a visualização <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> processo <span style="color: #008080">de</span> desenho<span style="color: #990000">,</span> efeitos indesejáveis principalmente <span style="color: #008080">em</span> animações<span style="color: #990000">.</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>  glutMouseFunc(mouse);
----      Define que função GLUT deverá chamar quando ocorrerem eventos de mouse. Quando o usuário pressiona ou solta uma dos botões do mouse, cada pressionamento ou soltura gera uma chamada de mouse. A função de chamada passada como argumento para `glutMouseFunc()` deve possuir o seguinte protótipo:
      &lt;funcsynopsis&gt;
        &lt;funcprototype&gt;
          &lt;funcdef&gt;void `funcao()`&lt;/funcdef&gt;
          &lt;paramdef&gt;int button&lt;/paramdef&gt;
          &lt;paramdef&gt;int state&lt;/paramdef&gt;
          &lt;paramdef&gt;int x&lt;/paramdef&gt;
          &lt;paramdef&gt;int y&lt;/paramdef&gt;
        &lt;/funcprototype&gt;
      &lt;/funcsynopsis&gt;</pre>
</div></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="color: #009900">void</span> <span style="font-weight: bold"><span style="color: #000000">display</span></span><span style="color: #990000">(</span><span style="color: #009900">void</span><span style="color: #990000">)</span><span style="color: #FF0000">{</span>
  <span style="color: #009900">int</span> i<span style="color: #990000">;</span>
  <span style="font-weight: bold"><span style="color: #000000">glClear</span></span><span style="color: #990000">(</span>GL_COLOR_BUFFER_BIT<span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glDisable</span></span><span style="color: #990000">(</span>GL_POLYGON_STIPPLE<span style="color: #990000">);</span>
<span style="color: #990000">----</span>      <span style="color: #008080">As</span> funções `<span style="font-weight: bold"><span style="color: #000000">glDisable</span></span><span style="color: #990000">()</span>` e `<span style="font-weight: bold"><span style="color: #000000">glEnable</span></span><span style="color: #990000">()</span>` permitem habilitar diversas habilidades <span style="color: #008080">do</span> OpenGL<span style="color: #990000">.</span> <span style="color: #008080">O</span> parâmetro <span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;</span>GL_POLYGON_STIPPLE` passado para essa função desabilita o desenho de polígonos utilizando padrões <span style="color: #008080">de</span> desenho<span style="color: #990000">.</span> Quando <span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;</span>GL_POLYGON_STIPPLE` é habilitado<span style="color: #990000">,</span> OpenGL usa o padrão corrente <span style="color: #008080">para</span> desenhar<span style="color: #990000">.</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>  glPolygonMode(GL_BACK, GL_LINE);
  glColor3f(1.0, 0.0, 0.0);
  glBegin(GL_POLYGON);
  glVertex2i(30,226);  glVertex2i(113,226);
  glVertex2i(113,143); glVertex2i(30,143);
  glEnd();
----      Neste trecho, a função `glPolygonMode()` indica que a parte de trás dos polígonos (&lt;parameter&gt;GL_BACK`) será desenhada apenas com a linha de contorno externo (&lt;parameter&gt;GL_LINE`), de cor vermelha, conforme especificado pela função `glColor3f()`. As funções `glBegin()`/`glEnd()` são usadas agora para iniciar o traçado de um polígono (&lt;parameter&gt;GL_POLYGON`) de coordenadas especificadas pela função `glVertex2i()`. O resultado é o contorno retangular vermelho mostrado na &lt;xref linkend="fig-tuxfig"/&gt;.</pre>
</div></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>  <span style="font-weight: bold"><span style="color: #000000">glPolygonMode</span></span><span style="color: #990000">(</span>GL_BACK<span style="color: #990000">,</span> GL_FILL<span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glColor3f</span></span><span style="color: #990000">(</span><span style="color: #993399">0.0</span><span style="color: #990000">,</span> <span style="color: #993399">1.0</span><span style="color: #990000">,</span> <span style="color: #993399">0.0</span><span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glBegin</span></span><span style="color: #990000">(</span>GL_POLYGON<span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glVertex2i</span></span><span style="color: #990000">(</span><span style="color: #993399">143</span><span style="color: #990000">,</span><span style="color: #993399">226</span><span style="color: #990000">);</span> <span style="font-weight: bold"><span style="color: #000000">glVertex2i</span></span><span style="color: #990000">(</span><span style="color: #993399">226</span><span style="color: #990000">,</span><span style="color: #993399">226</span><span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glVertex2i</span></span><span style="color: #990000">(</span><span style="color: #993399">226</span><span style="color: #990000">,</span><span style="color: #993399">143</span><span style="color: #990000">);</span> <span style="font-weight: bold"><span style="color: #000000">glVertex2i</span></span><span style="color: #990000">(</span><span style="color: #993399">143</span><span style="color: #990000">,</span><span style="color: #993399">143</span><span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glEnd</span></span><span style="color: #990000">();</span>
<span style="color: #990000">----</span>      <span style="color: #008080">A</span> função `<span style="font-weight: bold"><span style="color: #000000">glPolygonMode</span></span><span style="color: #990000">()</span>` indica agora que a parte de trás dos polígonos será desenhada apenas com <span style="color: #008080">preenchimento</span> só<span style="font-weight: bold"><span style="color: #000000">lido</span></span> <span style="color: #990000">(&lt;</span>parameter<span style="color: #990000">&gt;</span>GL_FULL`<span style="color: #990000">).</span> A cor de desenho agora é <span style="color: #990000">(</span>R<span style="color: #990000">,</span> G<span style="color: #990000">,</span> B<span style="color: #990000">)</span> <span style="color: #990000">=</span> <span style="color: #990000">(</span><span style="color: #993399">0</span><span style="color: #990000">,</span> <span style="color: #993399">1</span><span style="color: #990000">,</span> <span style="color: #993399">0</span><span style="color: #990000">),</span> de modo que o resultado da execução desse trecho de código é o retângulo verde <span style="color: #008080">mostrado</span> na <span style="color: #990000">&lt;</span><span style="color: #008080">xref</span> linkend<span style="color: #990000">=</span><span style="color: #FF0000">"fig-tuxfig"</span><span style="color: #990000">/&gt;.</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>  glBegin(GL_POLYGON);
  glColor3f(1.0, 0.0, 0.0);  glVertex2i(30,113);
  glColor3f(0.0, 1.0, 0.0);  glVertex2i(113,113);
  glColor3f(0.0, 0.0, 1.0);  glVertex2i(113,30);
  glColor3f(1.0, 1.0, 0.0);  glVertex2i(30,30);
  glEnd();
----      Este trecho de código demonstra uma característica peculiar de preenchimento. Como cada vértice é desenhado com uma cor diferente, OpenGL interpola estas cores para compor as tonalidades do interior do polígono, gerando um preenchimento bastante colorido.</pre>
</div></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>  <span style="font-weight: bold"><span style="color: #000000">glEnable</span></span><span style="color: #990000">(</span>GL_POLYGON_STIPPLE<span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glColor3f</span></span><span style="color: #990000">(</span><span style="color: #993399">1.0</span><span style="color: #990000">,</span> <span style="color: #993399">0.0</span><span style="color: #990000">,</span> <span style="color: #993399">1.0</span><span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glPolygonStipple</span></span><span style="color: #990000">(</span>tux<span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glBegin</span></span><span style="color: #990000">(</span>GL_POLYGON<span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glVertex2i</span></span><span style="color: #990000">(</span><span style="color: #993399">143</span><span style="color: #990000">,</span><span style="color: #993399">113</span><span style="color: #990000">);</span> <span style="font-weight: bold"><span style="color: #000000">glVertex2i</span></span><span style="color: #990000">(</span><span style="color: #993399">226</span><span style="color: #990000">,</span><span style="color: #993399">113</span><span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glVertex2i</span></span><span style="color: #990000">(</span><span style="color: #993399">226</span><span style="color: #990000">,</span><span style="color: #993399">30</span><span style="color: #990000">);</span> <span style="font-weight: bold"><span style="color: #000000">glVertex2i</span></span><span style="color: #990000">(</span><span style="color: #993399">143</span><span style="color: #990000">,</span><span style="color: #993399">30</span><span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glEnd</span></span><span style="color: #990000">();</span>
<span style="color: #990000">----</span>       O preenchimento com padrões é agora habilitado <span style="color: #008080">pela</span> função `<span style="font-weight: bold"><span style="color: #000000">glEnable</span></span><span style="color: #990000">()</span>`<span style="color: #990000">.</span> <span style="color: #008080">A</span> função `<span style="font-weight: bold"><span style="color: #000000">glColor3f</span></span><span style="color: #990000">()</span>` <span style="color: #008080">define</span> magenta<span style="color: #990000">,</span> combinação das tonalidades <span style="color: #008080">puras</span> <span style="font-weight: bold"><span style="color: #000000">vermelho</span></span> <span style="color: #990000">(</span>R<span style="color: #990000">=</span><span style="color: #993399">1</span><span style="color: #990000">)</span> <span style="color: #008080">e</span> <span style="font-weight: bold"><span style="color: #000000">azul</span></span> <span style="color: #990000">(</span>B<span style="color: #990000">=</span><span style="color: #993399">1</span><span style="color: #990000">),</span> como a nova cor <span style="color: #008080">de</span> desenho<span style="color: #990000">.</span> <span style="color: #008080">A</span> função `<span style="font-weight: bold"><span style="color: #000000">glPolygonStipple</span></span><span style="color: #990000">()</span>` define o novo padrão de preenchimento <span style="color: #008080">de</span> polígonos<span style="color: #990000">,</span> representado <span style="color: #008080">pelo</span> vetor <span style="color: #990000">&lt;</span>varname<span style="color: #990000">&gt;</span>tux<span style="color: #990000">[]&lt;/</span>varname<span style="color: #990000">&gt;.</span> <span style="color: #008080">Em</span> seguida<span style="color: #990000">,</span> <span style="color: #008080">o</span> par `<span style="font-weight: bold"><span style="color: #000000">glBegin</span></span><span style="color: #990000">()</span>`<span style="color: #990000">/</span>`<span style="font-weight: bold"><span style="color: #000000">glEnd</span></span><span style="color: #990000">()</span>` desenha o ú<span style="color: #008080">ltimo</span> polígono<span style="color: #990000">,</span> preenchindo com <span style="color: #008080">o</span> padrão <span style="color: #FF0000">"tux"</span><span style="color: #990000">.</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>  glFlush();
----       A função `glFlush()` faz com que qualquer comando OpenGL ainda não executado seja executado o mais rápido possível pelo mecanismo de exibição. OpenGL freqüentemente executa comandos aos lotes, de modo a tornar mais eficiente o processo de exibição, principalmente quando os programas são executados via rede. Neste caso, quando os comandos executados um a um, o programa pode se tornar ineficiente, considerando as sobrecargas existentes em um barramento de rede. Caso o programa desenvolvido seja destinado ao uso somente local, a função `glFlush()` torna-se desnecessária. Entretanto, se o programa é feito para funcionar bem tanto localmente quanto em rede, deve ser incluída uma chamada à função `glFlush()` no final de cada quadro ou cena.</pre>
</div></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="color: #009900">void</span> <span style="font-weight: bold"><span style="color: #000000">mouse</span></span><span style="color: #990000">(</span><span style="color: #009900">int</span> button<span style="color: #990000">,</span> <span style="color: #009900">int</span> state<span style="color: #990000">,</span> <span style="color: #009900">int</span> x<span style="color: #990000">,</span> <span style="color: #009900">int</span> y<span style="color: #990000">)</span><span style="color: #FF0000">{</span>
  <span style="font-weight: bold"><span style="color: #0000FF">switch</span></span> <span style="color: #990000">(</span>button<span style="color: #990000">)</span> <span style="color: #FF0000">{</span>
  <span style="font-weight: bold"><span style="color: #0000FF">case</span></span> GLUT_LEFT_BUTTON<span style="color: #990000">:</span>
        <span style="font-weight: bold"><span style="color: #0000FF">if</span></span> <span style="color: #990000">(</span>state <span style="color: #990000">==</span> GLUT_DOWN<span style="color: #990000">)</span> <span style="color: #FF0000">{</span>
          r<span style="color: #990000">=(</span>GLfloat<span style="color: #990000">)</span><span style="font-weight: bold"><span style="color: #000000">rand</span></span><span style="color: #990000">()/(</span>RAND_MAX<span style="color: #990000">+</span><span style="color: #993399">1.0</span><span style="color: #990000">);</span>
          g<span style="color: #990000">=(</span>GLfloat<span style="color: #990000">)</span><span style="font-weight: bold"><span style="color: #000000">rand</span></span><span style="color: #990000">()/(</span>RAND_MAX<span style="color: #990000">+</span><span style="color: #993399">1.0</span><span style="color: #990000">);</span>
          b<span style="color: #990000">=(</span>GLfloat<span style="color: #990000">)</span><span style="font-weight: bold"><span style="color: #000000">rand</span></span><span style="color: #990000">()/(</span>RAND_MAX<span style="color: #990000">+</span><span style="color: #993399">1.0</span><span style="color: #990000">);</span>
          <span style="font-weight: bold"><span style="color: #000000">glutPostRedisplay</span></span><span style="color: #990000">();</span>
        <span style="color: #FF0000">}</span>
        <span style="font-weight: bold"><span style="color: #0000FF">break</span></span><span style="color: #990000">;</span>
  <span style="color: #FF0000">}</span>
<span style="color: #FF0000">}</span>
<span style="color: #990000">----</span>       A função de tratamento de eventos de mouse verifica se algum botão é pressionado<span style="color: #990000">.</span> Caso o <span style="color: #008080">botão</span> <span style="font-weight: bold"><span style="color: #000000">esquerdo</span></span> <span style="color: #990000">(&lt;</span>parameter<span style="color: #990000">&gt;</span>GLUT_LEFT_BUTTON`<span style="color: #990000">)</span> <span style="color: #008080">seja</span> <span style="font-weight: bold"><span style="color: #000000">pressionado</span></span> <span style="color: #990000">(&lt;</span>parameter<span style="color: #990000">&gt;</span>GLUT_DOWN`<span style="color: #990000">),</span> serão gerados três valores aleatórios para <span style="color: #008080">as</span> variáveis <span style="color: #990000">&lt;</span>varname<span style="color: #990000">&gt;</span><span style="color: #008080">r&lt;/varname&gt;, &lt;varname&gt;g&lt;/varname&gt;</span> e <span style="color: #990000">&lt;</span>varname<span style="color: #990000">&gt;</span>b<span style="color: #990000">&lt;/</span>varname<span style="color: #990000">&gt;,</span> <span style="color: #008080">na</span> faixa <span style="color: #990000">[</span><span style="color: #993399">0</span><span style="color: #990000">,</span><span style="color: #993399">1</span><span style="color: #990000">].</span> Quando <span style="color: #008080">a</span> função `<span style="font-weight: bold"><span style="color: #000000">glutPostRedisplay</span></span><span style="color: #990000">()</span>` é executada<span style="color: #990000">,</span> <span style="color: #008080">a</span> função `display` é <span style="color: #008080">chamada</span> novamente<span style="color: #990000">,</span> fazendo com que a janela corrente seja redesenhada e o polígono no canto superior esquerdo dessa janela mude <span style="color: #008080">de</span> cor<span style="color: #990000">.</span>
    <span style="color: #990000">&lt;/</span>sect1<span style="color: #990000">&gt;</span>
    <span style="color: #990000">&lt;</span><span style="color: #008080">sect1</span> xml<span style="color: #990000">:</span>id<span style="color: #990000">=</span><span style="color: #FF0000">"preenchimento-exercicios"</span><span style="color: #990000">&gt;</span>
      <span style="color: #990000">&lt;</span>title<span style="color: #990000">&gt;</span>Exercícios<span style="color: #990000">&lt;/</span>title<span style="color: #990000">&gt;</span>
      <span style="color: #990000">&lt;</span>orderedlist<span style="color: #990000">&gt;</span>
        <span style="color: #990000">-</span>Utilizando o <span style="color: #008080">programa</span> link<span style="color: #990000">:</span>exemplos<span style="color: #990000">/</span>preenchimento<span style="color: #990000">.</span>c<span style="color: #FF0000">"&gt;&lt;filename&gt;preenchimento.c&lt;/filename&gt;&lt;/link&gt; como referência, implemente um programa &lt;filename&gt;selecao.c&lt;/filename&gt;. Este programa deverá desenhar numa janela com fundo branco, de dimensões 256x256 pixels, quatro polígonos com as mesmas coordenadas dos polígonos do programa de referência. Todos os polígonos devem estar inicialmente preenchidos de amarelo e com bordas pretas. Quando o usuário clicar com o botão esquerdo do mouse dentro de um dos polígonos, a cor de preechimento deste polígono deverá mudar para uma cor aleatória. Quando a tecla &lt;keycap&gt;b&lt;/keycap&gt; ('keycode'=&lt;keycode&gt;98&lt;/keycode&gt;) for pressionada, o programa passará a mudar as cores das bordas e não mais dos fundos dos polígonos. Quando a tecla &lt;keycap&gt;f&lt;/keycap&gt; ('keycode'=&lt;keycode&gt;102&lt;/keycode&gt;) for pressionada, o programa passará a mudar as cores dos fundos dos polígonos e não mais das bordas.</span>
<span style="color: #FF0000">        -Repita o item anterior utilizando 'buffer' simples e comente os resultados obtidos.</span>
<span style="color: #FF0000">        -Crie um padrão de preenchimento com as iniciais dos seu nome e sobre nome, por exemplo, AB, para Agostinho Brito. Implemente um programa que desenhe em uma janela de fundo branco de dimensões 300x300 pixels um hexágono com 'bounding box' de dimensões 200x200 pixels. O hexágono deve estar centrado na tela e preenchido com cor azul, utilize este padrão de preenchimento criado.</span>
<span style="color: #FF0000">      &lt;/orderedlist&gt;</span>
<span style="color: #FF0000">    &lt;/sect1&gt;</span>
<span style="color: #FF0000">  &lt;/chapter&gt;</span>
<span style="color: #FF0000">  &lt;chapter xml:id="</span>transformacoes<span style="color: #FF0000">"&gt;</span>
<span style="color: #FF0000">    &lt;title&gt;Transformações geométricas&lt;/title&gt;</span>
<span style="color: #FF0000">    O propósito desta lição é compreender como as transformações geométricas são realizadas sobre os objetos em relação a um determinado sistema de coordenadas. No OpenGL existem funções para realizar translação, rotação e escalamento, bastando apenas ao usuário ajustar os seus parâmetros para obter o efeito desejado. Será analisado um modelo simples de um braço robótico, constituído de braço e antebraço, como mostra a &lt;xref linkend="</span>fig<span style="color: #990000">-</span>braco<span style="color: #FF0000">"/&gt;</span>
<span style="color: #FF0000">    &lt;figure xml:id="</span>fig<span style="color: #990000">-</span>braco<span style="color: #FF0000">"&gt;</span>
<span style="color: #FF0000">      &lt;title&gt;Braço robótico&lt;/title&gt;</span>
<span style="color: #FF0000">      &lt;mediaobject&gt;</span>
<span style="color: #FF0000">        &lt;imageobject role="</span>html<span style="color: #FF0000">"&gt;</span>
<span style="color: #FF0000">          &lt;imagedata fileref="</span>figs<span style="color: #990000">/</span>braco<span style="color: #990000">.</span>jpg<span style="color: #FF0000">" format="</span>JPG<span style="color: #FF0000">"/&gt;</span>
<span style="color: #FF0000">        &lt;/imageobject&gt;</span>
<span style="color: #FF0000">        &lt;textobject&gt;&lt;phrase&gt;Braço robótico&lt;/phrase&gt;&lt;/textobject&gt;</span>
<span style="color: #FF0000">      &lt;/mediaobject&gt;</span>
<span style="color: #FF0000">    &lt;/figure&gt;</span>
<span style="color: #FF0000">     O programa que implementa o braço robótico é mostrado no &lt;xref linkend="</span>example<span style="color: #990000">-</span>braco<span style="color: #FF0000">"/&gt;. As teclas &lt;keycap&gt;s&lt;/keycap&gt; e &lt;keycap&gt;S&lt;/keycap&gt; servem para girar o ombro do braço robótico ('shoulder') para um lado e para o outro; as teclas &lt;keycap&gt;e&lt;/keycap&gt; e &lt;keycap&gt;E&lt;/keycap&gt;, por sua vez, controlam o giro do cotovelo ('elbow'). Para finalizar o programa, basta digitar &lt;keycap&gt;ESC&lt;/keycap&gt;. As teclas e suas respectivas ações estão definidas na função `keyboard()`.</span>
<span style="color: #FF0000">    &lt;example xml:id="</span>example<span style="color: #990000">-</span>braco<span style="color: #FF0000">"&gt;</span>
<span style="color: #FF0000">      &lt;title&gt;programa link:exemplos/braco.c"</span><span style="color: #990000">&gt;&lt;</span>filename<span style="color: #990000">&gt;</span>braco<span style="color: #990000">.</span>c<span style="color: #990000">&lt;/</span>filename<span style="color: #990000">&gt;&lt;/</span>link<span style="color: #990000">&gt;&lt;/</span>title<span style="color: #990000">&gt;</span>
      <span style="color: #990000">&lt;</span>programlisting<span style="color: #990000">&gt;</span>
        <span style="color: #990000">&lt;</span>textobject<span style="color: #990000">&gt;</span> <span style="color: #990000">&lt;</span><span style="color: #008080">textdata</span> fileref<span style="color: #990000">=</span><span style="color: #FF0000">"&amp;caminho;/exemplos/braco.c"</span> format<span style="color: #990000">=</span><span style="color: #FF0000">"linespecific"</span><span style="color: #990000">/&gt;&lt;/</span>textobject<span style="color: #990000">&gt;</span>
      <span style="color: #990000">&lt;/</span>programlisting<span style="color: #990000">&gt;</span>
    <span style="color: #990000">&lt;/</span>example<span style="color: #990000">&gt;</span>

    Para compilar e executar o <span style="color: #008080">programa</span> link<span style="color: #990000">:</span>exemplos<span style="color: #990000">/</span>braco<span style="color: #990000">.</span>c<span style="color: #FF0000">"&gt;&lt;filename&gt;braco.c&lt;/filename&gt;&lt;/link&gt;, salve-o juntamente com o arquivo link:exemplos/Makefile"</span><span style="color: #990000">&gt;</span>Makefile<span style="color: #990000">&lt;/</span>link<span style="color: #990000">&gt;</span> em um diretório e execute a seguinte seqüência <span style="color: #008080">de</span> comandos<span style="color: #990000">:</span>
    <span style="color: #990000">&lt;</span>screen<span style="color: #990000">&gt;</span>
<span style="color: #990000">&lt;</span>prompt<span style="color: #990000">&gt;</span>$<span style="color: #990000">&lt;/</span>prompt<span style="color: #990000">&gt;</span> <span style="color: #990000">&lt;</span>command<span style="color: #990000">&gt;</span>make<span style="color: #990000">&lt;/</span>command<span style="color: #990000">&gt;</span> <span style="color: #990000">&lt;</span>option<span style="color: #990000">&gt;</span>braco<span style="color: #990000">&lt;/</span>option<span style="color: #990000">&gt;</span>
<span style="color: #990000">&lt;</span>prompt<span style="color: #990000">&gt;</span>$<span style="color: #990000">&lt;/</span>prompt<span style="color: #990000">&gt;</span> <span style="color: #990000">&lt;</span>command<span style="color: #990000">&gt;</span>braco<span style="color: #990000">&lt;/</span>command<span style="color: #990000">&gt;</span>
<span style="color: #990000">&lt;/</span>screen<span style="color: #990000">&gt;</span>
    <span style="color: #990000">&lt;</span><span style="color: #008080">sect1</span> xml<span style="color: #990000">:</span>id<span style="color: #990000">=</span><span style="color: #FF0000">"transformacoes-descricao"</span><span style="color: #990000">&gt;</span>
      <span style="color: #990000">&lt;</span>title<span style="color: #990000">&gt;</span>Descrição <span style="color: #008080">do</span> programa <span style="color: #990000">&lt;</span>filename<span style="color: #990000">&gt;</span>braco<span style="color: #990000">.</span>c<span style="color: #990000">&lt;/</span>filename<span style="color: #990000">&gt;&lt;/</span>title<span style="color: #990000">&gt;</span>
<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="paragraph"><p>static int shoulder = 0, elbow = 0;
----      As variáveis &lt;varname&gt;shoulder&lt;/varname&gt; e  &lt;varname&gt;elbow&lt;/varname&gt; guardam o ângulo de rotação do ombro e o ângulo formado entre o braço e o antebraço do robô, respectivamente.</p></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="color: #009900">void</span> <span style="font-weight: bold"><span style="color: #000000">display</span></span><span style="color: #990000">(</span><span style="color: #009900">void</span><span style="color: #990000">)</span>
<span style="color: #FF0000">{</span>
  <span style="font-weight: bold"><span style="color: #000000">glClear</span></span> <span style="color: #990000">(</span>GL_COLOR_BUFFER_BIT<span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glPushMatrix</span></span><span style="color: #990000">();</span>
<span style="color: #990000">----</span>      Uma vez que as transformações geométricas no espaço são representadas <span style="color: #008080">por</span> matrizes<span style="color: #990000">,</span> o uso de uma pilha de matrizes de transformação ajuda a lembrar a seqüência de <span style="color: #008080">transformações</span> realizadas<span style="color: #990000">.</span> <span style="color: #008080">No</span> OpenGL<span style="color: #990000">,</span> esta facilidade é provida <span style="color: #008080">pelas</span> funções `<span style="font-weight: bold"><span style="color: #000000">glPushMatrix</span></span><span style="color: #990000">()</span>`<span style="color: #990000">,</span> que insere a matriz de transformação corrente <span style="color: #008080">na</span> pilha<span style="color: #990000">,</span> e `<span style="font-weight: bold"><span style="color: #000000">glPopMatrix</span></span><span style="color: #990000">()</span>`<span style="color: #990000">,</span> que retira a matriz <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> topo da pilha e torna esta última a matriz de <span style="color: #008080">transformação</span> corrente<span style="color: #990000">.</span> <span style="color: #008080">Neste</span> exemplo<span style="color: #990000">,</span> <span style="color: #008080">a</span> função `<span style="font-weight: bold"><span style="color: #000000">glPushMatrix</span></span><span style="color: #990000">()</span>` serve para lembrar os parâmetros <span style="color: #008080">de</span> translação<span style="color: #990000">,</span> rotação e escalamento no início das operações <span style="color: #008080">de</span> desenho<span style="color: #990000">.</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>  glTranslatef (-1.0, 0.0, 0.0);
  glRotatef ((GLfloat) shoulder, 0.0, 0.0, 1.0);
  glTranslatef (1.0, 0.0, 0.0);
----      A origem do sistema de coordenadas é levado para o ponto (x,y,z)=(-1,0,0) através da função `glTranslatef()`, definindo a coordenada de origem (pivô) para o ombro do braço robótico. Em seguida, usando a função `glRotatef()`, o sistema de coordenadas é rotacionado de modo, definindo a orientação do braço.
      A função `glRotate()` possui o seguinte protótipo:
      &lt;funcsynopsis&gt;
        &lt;funcprototype&gt;
          &lt;funcdef&gt;void `glRotate`&lt;/funcdef&gt;
          &lt;paramdef&gt;GLfloat &lt;parameter&gt;angle`&lt;/paramdef&gt;
          &lt;paramdef&gt;GLfloat &lt;parameter&gt;x`&lt;/paramdef&gt;
          &lt;paramdef&gt;GLfloat &lt;parameter&gt;y`&lt;/paramdef&gt;
          &lt;paramdef&gt;GLfloat &lt;parameter&gt;z`&lt;/paramdef&gt;
        &lt;/funcprototype&gt;
      &lt;/funcsynopsis&gt;
      Quando chamada, `glRotate()` efetua uma rotação de &lt;parameter&gt;angle` graus no sistema de coordenadas na direção contra o sentido do relógio em torno de um vetor que vai da origem ao ponto (x,y,z)
      A função `glTranslatef()`, por sua vez, retorna a origem do sistema de coordenadas para o centro do braço. As etapas desta transformação são mostradas na &lt;xref linkend="fig-braco-1"/&gt;.</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>&lt;figure xml:id="fig-braco-1"&gt;
  &lt;title&gt;Transformação para desenho do braço&lt;/title&gt;
&lt;mediaobject&gt;
  &lt;imageobject&gt;
    &lt;imagedata fileref="figs/braco-1.jpg" format="JPG"/&gt;
  &lt;/imageobject&gt;
&lt;/mediaobject&gt;
&lt;/figure&gt;</pre>
</div></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>  <span style="font-weight: bold"><span style="color: #000000">glPushMatrix</span></span><span style="color: #990000">();</span>
  <span style="font-weight: bold"><span style="color: #000000">glScalef</span></span> <span style="color: #990000">(</span><span style="color: #993399">2.0</span><span style="color: #990000">,</span> <span style="color: #993399">0.4</span><span style="color: #990000">,</span> <span style="color: #993399">1.0</span><span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glutWireCube</span></span> <span style="color: #990000">(</span><span style="color: #993399">1.0</span><span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glPopMatrix</span></span><span style="color: #990000">();</span>
<span style="color: #990000">----</span>      Mais <span style="color: #008080">uma</span> vez<span style="color: #990000">,</span> a matriz de transformação corrente é armazenada <span style="color: #008080">na</span> pilha<span style="color: #990000">,</span> agora para restringir o efeito <span style="color: #008080">da</span> função `<span style="font-weight: bold"><span style="color: #000000">glScale</span></span><span style="color: #990000">()</span>`<span style="color: #990000">.</span> <span style="color: #008080">A</span> função `<span style="font-weight: bold"><span style="color: #000000">glScale</span></span><span style="color: #990000">()</span>` altera a escala dos <span style="color: #008080">eixos</span> x<span style="color: #990000">,</span> y <span style="color: #008080">e</span> z<span style="color: #990000">.</span> <span style="color: #008080">A</span> função `<span style="font-weight: bold"><span style="color: #000000">glutWireCube</span></span><span style="color: #990000">()</span>` desenha um cubo centrado na origem <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> sistema de coordenadas com aresta de <span style="color: #008080">tamanho</span> unitário<span style="color: #990000">,</span> conforme o argumento que lhe <span style="color: #008080">foi</span> passado<span style="color: #990000">.</span> Quando <span style="color: #008080">a</span> função `<span style="font-weight: bold"><span style="color: #000000">glPopMatrix</span></span><span style="color: #990000">()</span>` é chamada<span style="color: #990000">,</span> a matriz de transformação <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> topo da pilha passa <span style="color: #008080">a</span> vigorar<span style="color: #990000">,</span> fazendo com que o cubo <span style="color: #008080">seja</span> distorcido<span style="color: #990000">,</span> assumindo a forma de <span style="color: #008080">um</span> parelepípedo<span style="color: #990000">.</span> A origem <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> sistema de coordenadas volta a ser o centro <span style="color: #008080">do</span> braço<span style="color: #990000">.</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>  glTranslatef (1.0, 0.0, 0.0);
  glRotatef ((GLfloat) elbow, 0.0, 0.0, 1.0);
  glTranslatef (1.0, 0.0, 0.0);
----      A origem do sistema de coordenadas é levada agora para a ponta do braço com a função `glTranslate()`, demarcando o novo pivõ para rotação: o cotovelo do robô. A rotação é realizada com a função `glRotate()` e em seguida a origem do sistema de coordenadas é levada para o centro do antebraço, via `glTranslate()`.</pre>
</div></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>  <span style="font-weight: bold"><span style="color: #000000">glPushMatrix</span></span><span style="color: #990000">();</span>
  <span style="font-weight: bold"><span style="color: #000000">glScalef</span></span> <span style="color: #990000">(</span><span style="color: #993399">2.0</span><span style="color: #990000">,</span> <span style="color: #993399">0.4</span><span style="color: #990000">,</span> <span style="color: #993399">1.0</span><span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glutWireCube</span></span> <span style="color: #990000">(</span><span style="color: #993399">1.0</span><span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glPopMatrix</span></span><span style="color: #990000">();</span>
<span style="color: #990000">----</span>      O antebraço é desenhado de forma semelhante <span style="color: #008080">ao</span> braço<span style="color: #990000">:</span> as escalas dos eixos coordenados são ajustadas e o cubo de aresta <span style="color: #993399">1</span> é desenhado<span style="color: #990000">,</span> sempre preservando as dimensões <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> sistema de <span style="color: #008080">coordenadas</span> original<span style="color: #990000">.</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>  glPopMatrix();
  glutSwapBuffers();
----      A função `glPopMatrix()` remove a matriz de transformação do topo da pilha, fazendo-a corrente, retornando assim o sistema de coordenadas original. Quando `glutSwapBuffers()` é chamada, os buffers de desenho e de apresentação são alternados e a nova imagem do braço robótico é apresentada.</pre>
</div></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="color: #009900">void</span> <span style="font-weight: bold"><span style="color: #000000">reshape</span></span> <span style="color: #990000">(</span><span style="color: #009900">int</span> w<span style="color: #990000">,</span> <span style="color: #009900">int</span> h<span style="color: #990000">)</span>
<span style="color: #FF0000">{</span>
  <span style="font-weight: bold"><span style="color: #000000">glViewport</span></span> <span style="color: #990000">(</span><span style="color: #993399">0</span><span style="color: #990000">,</span> <span style="color: #993399">0</span><span style="color: #990000">,</span> <span style="color: #990000">(</span>GLsizei<span style="color: #990000">)</span> w<span style="color: #990000">,</span> <span style="color: #990000">(</span>GLsizei<span style="color: #990000">)</span> h<span style="color: #990000">);</span>
<span style="color: #990000">----</span>      Define a área dentro da janela de desenho no sistema de <span style="color: #008080">coordenadas</span> atual<span style="color: #990000">,</span> <span style="font-weight: bold"><span style="color: #000000">origem</span></span> <span style="color: #990000">(</span>x<span style="color: #990000">,</span>y<span style="color: #990000">),</span> <span style="font-weight: bold"><span style="color: #000000">largura</span></span> <span style="color: #990000">(</span>w<span style="color: #990000">)</span> <span style="color: #008080">e</span> <span style="font-weight: bold"><span style="color: #000000">altura</span></span> <span style="color: #990000">(</span>h<span style="color: #990000">),</span> que OpenGL pode utilizar para <span style="color: #008080">efetuar</span> desenhos<span style="color: #990000">.</span> Este trecho de código permite que toda a área da janela possa ser utilizada quando a janela <span style="color: #008080">sofrer</span> redimensionamento<span style="color: #990000">.</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>  glMatrixMode (GL_PROJECTION);
  glLoadIdentity ();
  gluPerspective(65.0, (GLfloat) w/(GLfloat) h, 1.0, 20.0);
----      A função `glMatrixMode()` especifica a pilha de matrizes que será o alvo das operações matriciais subseqüentes; neste caso, a pilha de matrizes de projeção. A função `glLoadIdentity()` inicia a matriz de projeção corrente como a matriz identidade. A função `gluPerspective()` define a transformação de perspectiva usada no exemplo. Projeções geométricas não são alvo desta lição e por enquanto não serão estudadas.</pre>
</div></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>  <span style="font-weight: bold"><span style="color: #000000">glMatrixMode</span></span><span style="color: #990000">(</span>GL_MODELVIEW<span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glLoadIdentity</span></span><span style="color: #990000">();</span>
  <span style="font-weight: bold"><span style="color: #000000">glTranslatef</span></span> <span style="color: #990000">(</span><span style="color: #993399">0.0</span><span style="color: #990000">,</span> <span style="color: #993399">0.0</span><span style="color: #990000">,</span> <span style="color: #990000">-</span><span style="color: #993399">5.0</span><span style="color: #990000">);</span>
<span style="color: #990000">----</span>      <span style="color: #008080">A</span> função `<span style="font-weight: bold"><span style="color: #000000">glMatrixMode</span></span><span style="color: #990000">()</span>` especifica agora que a pilha de <span style="color: #008080">matrizes</span> de <span style="color: #FF0000">'modelview'</span><span style="color: #990000">,</span> usadas para <span style="color: #008080">definir</span> translação<span style="color: #990000">,</span> rotação <span style="color: #008080">e</span> escalamento<span style="color: #990000">,</span> será o alvo das <span style="color: #008080">transformações</span> subseqüentes<span style="color: #990000">.</span>  <span style="color: #008080">A</span> função `<span style="font-weight: bold"><span style="color: #000000">glLoadIdentity</span></span><span style="color: #990000">()</span>` inicia a <span style="color: #008080">matriz</span> de  <span style="color: #FF0000">'modelview'</span> corrente como a <span style="color: #008080">matriz</span> identidade<span style="color: #990000">.</span> Finalmente<span style="color: #990000">,</span> o objeto é deslocado <span style="color: #990000">-</span><span style="color: #993399">5</span> unidades para o fundo <span style="color: #008080">da</span> tela<span style="color: #990000">,</span> melhorando a <span style="color: #008080">sua</span> visualização<span style="color: #990000">.</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>  glutReshapeFunc(reshape);
----      Especifica a função de retorno para redimensionamento de janela, possuindo o seguinte protótipo:
      &lt;funcsynopsis&gt;
        &lt;funcprototype&gt;
          &lt;funcdef&gt;funcao&lt;/funcdef&gt;
          &lt;paramdef&gt;int &lt;parameter&gt;width`&lt;/paramdef&gt;
          &lt;paramdef&gt;int &lt;parameter&gt;height`&lt;/paramdef&gt;
        &lt;/funcprototype&gt;
      &lt;/funcsynopsis&gt;
    &lt;/sect1&gt;
    &lt;sect1 xml:id="transformacoes-exercicios"&gt;
      &lt;title&gt;Exercícios&lt;/title&gt;
      &lt;orderedlist&gt;
        -Utilizando o programa link:exemplos/braco.c"&gt;&lt;filename&gt;braco.c&lt;/filename&gt;&lt;/link&gt; como referência, implemente um programa &lt;filename&gt;braco-garra.c&lt;/filename&gt;. Este programa deverá acrescente ao braço robótico uma garra com três dedos, sendo um indicador, um médio e um polegar, como mostra a &lt;xref linkend="fig-braco-garra"/&gt;. O usuário deverá poder rotacionar o dedo indicador com as teclas &lt;keycap&gt;i&lt;/keycap&gt; e &lt;keycap&gt;I&lt;/keycap&gt;, nos sentidos horário e anti-horário. Da mesma forma, as teclas &lt;keycap&gt;p&lt;/keycap&gt; &lt;keycap&gt;P&lt;/keycap&gt; deverão rotacionar o polegar, e teclas &lt;keycap&gt;m&lt;/keycap&gt; &lt;keycap&gt;M&lt;/keycap&gt;, o dedo médio do robô.
          &lt;figure xml:id="fig-braco-garra"&gt;
            &lt;title&gt;Braço robótico com garra&lt;/title&gt;
                  &lt;mediaobject&gt;
        &lt;imageobject&gt;
          &lt;imagedata fileref="figs/braco-garra.jpg" format="JPG"/&gt;
        &lt;/imageobject&gt;
      &lt;/mediaobject&gt;</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>  &lt;/figure&gt;
-Copie o programa &lt;filename&gt;braco-garra.c&lt;/filename&gt; que você criou com o nome &lt;filename&gt;braco-garra-3d.c&lt;/filename&gt;. Neste novo programa, modifique o trecho da função `main()` que define o modo de apresentação no GLUT. Use a seguinte chamada para a função de inicialização: `glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH)`, pois inclui o tratamento de profundidade e de superfícies escondidas no OpenGL . Além disso, ao invés de utilizar chamadas à função `glutWireCube()`, inclua chamadas apenas à função  `glutSolidCube()`, que contém os mesmos argumentos. Acrescente à função `init()` as chamadas de função `glEnable(GL_DEPTH_TEST);` e `glEnable(GL_CULL_FACE);`, de modo que o tratamento de superfícies escondidas seja feito pelo OpenGL. Utilize cores diferentes para cada uma das partes do braço, de modo a obter um modelo semelhante ao da &lt;xref linkend="fig-braco-3d"/&gt;. Possibilite também que a base do robô seja rotacionada em torno do eixo y, usando as teclas &lt;keycap&gt;b&lt;/keycap&gt; e &lt;keycap&gt;B&lt;/keycap&gt;, para girar nos sentidos horário e anti-horário.</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>    &lt;figure xml:id="fig-braco-3d"&gt;
      &lt;title&gt;Braço robótico 3D&lt;/title&gt;
            &lt;mediaobject&gt;
  &lt;imageobject&gt;
    &lt;imagedata fileref="figs/braco-3d.jpg" format="JPG"/&gt;
  &lt;/imageobject&gt;
&lt;/mediaobject&gt;</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>        &lt;/figure&gt;
    &lt;/orderedlist&gt;
  &lt;/sect1&gt;
&lt;/chapter&gt;</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>&lt;!-- projeçoes geométricas --&gt;
&lt;chapter xml:id="projecoes-geometricas"&gt;
  &lt;title&gt;Projeções geométricas&lt;/title&gt;
  O propósito desta lição é entender o funcionamento dos principais tipos de projeções geométricas: paralelas e de perspectiva. O objeto utilizado nesta lição será um cubo com um dos cantos cortado, como mostra a &lt;xref linkend="fig-projecoes-cubo"/&gt;.
  &lt;figure xml:id="fig-projecoes-cubo"&gt;
    &lt;title&gt;Cubo sem canto&lt;/title&gt;
          &lt;mediaobject&gt;
    &lt;imageobject&gt;
      &lt;imagedata fileref="figs/cubo-sem-canto.svg" format="SVG"/&gt;
    &lt;/imageobject&gt;
    &lt;/mediaobject&gt;</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>&lt;/figure&gt;</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre> O programa que apresenta este cubo é mostrado no &lt;xref linkend="example-braco"/&gt;. As teclas &lt;keycap&gt;y&lt;/keycap&gt; e &lt;keycap&gt;Y&lt;/keycap&gt; servem para girar o cubo em torno do eixo y contra e a favor do sentido dos ponteiros do relógio, respectivamente; as teclas &lt;keycap&gt;x&lt;/keycap&gt; e &lt;keycap&gt;X&lt;/keycap&gt;, controlam o giro em torno do eixo x. As teclas &lt;keycap&gt;o&lt;/keycap&gt; e &lt;keycap&gt;p&lt;/keycap&gt; define que os tipos de projeções serão ortográficas ou de perspectiva, respectivamente. Para finalizar o programa, basta digitar &lt;keycap&gt;ESC&lt;/keycap&gt;. As teclas e suas respectivas ações estão definidas na função `keyboard()`.
&lt;example xml:id="example-projecoes"&gt;
  &lt;title&gt;programa link:exemplos/projecoes.c"&gt;&lt;filename&gt;projecoes.c&lt;/filename&gt;&lt;/link&gt;&lt;/title&gt;
  &lt;programlisting&gt;
    &lt;textobject&gt;&lt;textdata fileref="&amp;caminho;/exemplos/projecoes.c" format="linespecific"/&gt;&lt;/textobject&gt;
  &lt;/programlisting&gt;
&lt;/example&gt;</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>    Para compilar e executar o programa link:exemplos/projecoes.c"&gt;&lt;filename&gt;projecoes.c&lt;/filename&gt;&lt;/link&gt;, salve-o juntamente com o arquivo link:exemplos/Makefile"&gt;Makefile&lt;/link&gt; em um diretório e execute a seguinte seqüência de comandos:
    &lt;screen&gt;
&lt;prompt&gt;$&lt;/prompt&gt; &lt;command&gt;make&lt;/command&gt; &lt;option&gt;projecoes&lt;/option&gt;
&lt;prompt&gt;$&lt;/prompt&gt; &lt;command&gt;projecoes&lt;/command&gt;
&lt;/screen&gt;
    &lt;sect1 xml:id="projecoes-descricao"&gt;
      &lt;title&gt;Descrição do programa &lt;filename&gt;projecoes.c&lt;/filename&gt;&lt;/title&gt;</pre>
</div></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="font-weight: bold"><span style="color: #000080">#define</span></span> AZUL     <span style="color: #993399">0.0</span><span style="color: #990000">,</span> <span style="color: #993399">0.0</span><span style="color: #990000">,</span> <span style="color: #993399">1.0</span>
<span style="font-weight: bold"><span style="color: #000080">#define</span></span> VERMELHO <span style="color: #993399">1.0</span><span style="color: #990000">,</span> <span style="color: #993399">0.0</span><span style="color: #990000">,</span> <span style="color: #993399">0.0</span>
<span style="font-weight: bold"><span style="color: #000080">#define</span></span> AMARELO  <span style="color: #993399">1.0</span><span style="color: #990000">,</span> <span style="color: #993399">1.0</span><span style="color: #990000">,</span> <span style="color: #993399">0.0</span>
<span style="font-weight: bold"><span style="color: #000080">#define</span></span> VERDE    <span style="color: #993399">0.0</span><span style="color: #990000">,</span> <span style="color: #993399">1.0</span><span style="color: #990000">,</span> <span style="color: #993399">0.0</span>
<span style="font-weight: bold"><span style="color: #000080">#define</span></span> CYAN     <span style="color: #993399">1.0</span><span style="color: #990000">,</span> <span style="color: #993399">0.0</span><span style="color: #990000">,</span> <span style="color: #993399">1.0</span>
<span style="font-weight: bold"><span style="color: #000080">#define</span></span> LARANJA  <span style="color: #993399">0.8</span><span style="color: #990000">,</span> <span style="color: #993399">0.6</span><span style="color: #990000">,</span> <span style="color: #993399">0.1</span>
<span style="font-weight: bold"><span style="color: #000080">#define</span></span> ROSEO    <span style="color: #993399">0.7</span><span style="color: #990000">,</span> <span style="color: #993399">0.1</span><span style="color: #990000">,</span> <span style="color: #993399">0.6</span>
<span style="font-weight: bold"><span style="color: #000080">#define</span></span> CINZA    <span style="color: #993399">0.6</span><span style="color: #990000">,</span> <span style="color: #993399">0.6</span><span style="color: #990000">,</span> <span style="color: #993399">0.6</span>
<span style="color: #990000">----</span>       Define nomes para as tonalidades de cor utilizadas nas faces <span style="color: #008080">do</span> cubo<span style="color: #990000">.</span> Cada linha contém o nome da cor e as respectivas <span style="color: #008080">componentes</span> R<span style="color: #990000">,</span> G <span style="color: #008080">e</span> B<span style="color: #990000">.</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="paragraph"><p>static GLfloat vertices[30]={
  0.0,  30.0, 30.0, /* 0 <strong>/
  20.0, 30.0, 30.0, /</strong> 1 <strong>/
  30.0, 20.0, 30.0, /</strong> 2 <strong>/
  30.0,  0.0, 30.0, /</strong> 3 <strong>/
  0.0,   0.0, 30.0, /</strong> 4 <strong>/
  0.0,  30.0,  0.0, /</strong> 5 <strong>/
  30.0, 30.0,  0.0, /</strong> 6 <strong>/
  30.0,  0.0,  0.0, /</strong> 7 <strong>/
  0.0,   0.0,  0.0, /</strong> 8 <strong>/
  30.0, 30.0, 20.0  /</strong> 9 */
};
----       Armazena em um vetor as posições de cada um dos vértices do cubo. Serão tomados posteriormente grupos de três elementos para compor as coordenadas x, y e z dos vértices. Os comentários que aparecem ao lado de cada linha referenciam as coordenadas correspondentes dos vértices da &lt;xref linkend="fig-projecoes-cubo"/&gt;.</p></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="font-weight: bold"><span style="color: #0000FF">static</span></span> <span style="color: #008080">GLubyte</span> frenteIndices<span style="color: #990000">[]</span>    <span style="color: #990000">=</span> <span style="color: #FF0000">{</span><span style="color: #993399">0</span><span style="color: #990000">,</span><span style="color: #993399">4</span><span style="color: #990000">,</span><span style="color: #993399">3</span><span style="color: #990000">,</span><span style="color: #993399">2</span><span style="color: #990000">,</span><span style="color: #993399">1</span><span style="color: #FF0000">}</span><span style="color: #990000">;</span>
<span style="font-weight: bold"><span style="color: #0000FF">static</span></span> <span style="color: #008080">GLubyte</span> trasIndices<span style="color: #990000">[]</span>      <span style="color: #990000">=</span> <span style="color: #FF0000">{</span><span style="color: #993399">5</span><span style="color: #990000">,</span><span style="color: #993399">6</span><span style="color: #990000">,</span><span style="color: #993399">7</span><span style="color: #990000">,</span><span style="color: #993399">8</span><span style="color: #FF0000">}</span><span style="color: #990000">;</span>
<span style="font-weight: bold"><span style="color: #0000FF">static</span></span> <span style="color: #008080">GLubyte</span> esquerdaIndices<span style="color: #990000">[]</span>  <span style="color: #990000">=</span> <span style="color: #FF0000">{</span><span style="color: #993399">0</span><span style="color: #990000">,</span><span style="color: #993399">5</span><span style="color: #990000">,</span><span style="color: #993399">8</span><span style="color: #990000">,</span><span style="color: #993399">4</span><span style="color: #FF0000">}</span><span style="color: #990000">;</span>
<span style="font-weight: bold"><span style="color: #0000FF">static</span></span> <span style="color: #008080">GLubyte</span> direitaIndices<span style="color: #990000">[]</span>   <span style="color: #990000">=</span> <span style="color: #FF0000">{</span><span style="color: #993399">2</span><span style="color: #990000">,</span><span style="color: #993399">3</span><span style="color: #990000">,</span><span style="color: #993399">7</span><span style="color: #990000">,</span><span style="color: #993399">6</span><span style="color: #990000">,</span><span style="color: #993399">9</span><span style="color: #FF0000">}</span><span style="color: #990000">;</span>
<span style="font-weight: bold"><span style="color: #0000FF">static</span></span> <span style="color: #008080">GLubyte</span> topoIndices<span style="color: #990000">[]</span>      <span style="color: #990000">=</span> <span style="color: #FF0000">{</span><span style="color: #993399">0</span><span style="color: #990000">,</span><span style="color: #993399">1</span><span style="color: #990000">,</span><span style="color: #993399">9</span><span style="color: #990000">,</span><span style="color: #993399">6</span><span style="color: #990000">,</span><span style="color: #993399">5</span><span style="color: #FF0000">}</span><span style="color: #990000">;</span>
<span style="font-weight: bold"><span style="color: #0000FF">static</span></span> <span style="color: #008080">GLubyte</span> fundoIndices<span style="color: #990000">[]</span>     <span style="color: #990000">=</span> <span style="color: #FF0000">{</span><span style="color: #993399">3</span><span style="color: #990000">,</span><span style="color: #993399">4</span><span style="color: #990000">,</span><span style="color: #993399">8</span><span style="color: #990000">,</span><span style="color: #993399">7</span><span style="color: #FF0000">}</span><span style="color: #990000">;</span>
<span style="font-weight: bold"><span style="color: #0000FF">static</span></span> <span style="color: #008080">GLubyte</span> trianguloIndices<span style="color: #990000">[]</span> <span style="color: #990000">=</span> <span style="color: #FF0000">{</span><span style="color: #993399">1</span><span style="color: #990000">,</span><span style="color: #993399">2</span><span style="color: #990000">,</span><span style="color: #993399">9</span><span style="color: #FF0000">}</span><span style="color: #990000">;</span>
<span style="color: #990000">----</span>       Define vetores com índices para cada uma das faces <span style="color: #008080">do</span> cubo<span style="color: #990000">,</span> especificando os vértices que <span style="color: #008080">irão</span> construí<span style="color: #990000">-</span>las<span style="color: #990000">.</span> A ordem em que os í<span style="font-weight: bold"><span style="color: #000000">ndices</span></span> <span style="color: #990000">(</span>números <span style="color: #008080">dos</span> vértices<span style="color: #990000">)</span> é incluída em cada vetor é importante<span style="color: #990000">,</span> pois será esta a utilizada para introduzir cada vértice no desenho dos polígonos que formarão <span style="color: #008080">cada</span> face<span style="color: #990000">.</span> A parte frontal <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> polígono fica saindo <span style="color: #008080">do</span> polígono<span style="color: #990000">,</span> quando a seqüência de índices é especificada no <span style="color: #008080">sentido</span> anti<span style="color: #990000">-</span>horário<span style="color: #990000">,</span> como <span style="color: #008080">mostra</span> a <span style="color: #990000">&lt;</span><span style="color: #008080">xref</span> linkend<span style="color: #990000">=</span><span style="color: #FF0000">"fig-projecoes-indices"</span><span style="color: #990000">/&gt;</span> para o polígono <span style="color: #008080">do</span> <span style="font-weight: bold"><span style="color: #000000">topo</span></span> <span style="color: #990000">(&lt;</span>varname<span style="color: #990000">&gt;</span>topoIndices<span style="color: #990000">[]&lt;/</span>varname<span style="color: #990000">&gt;).</span>

      <span style="color: #990000">&lt;</span><span style="color: #008080">figure</span> xml<span style="color: #990000">:</span>id<span style="color: #990000">=</span><span style="color: #FF0000">"fig-projecoes-indices"</span><span style="color: #990000">&gt;</span>
        <span style="color: #990000">&lt;</span>title<span style="color: #990000">&gt;</span>Seqüência de vértices defininindo a frente <span style="color: #008080">do</span> polígono<span style="color: #990000">.&lt;/</span>title<span style="color: #990000">&gt;</span>
      <span style="color: #990000">&lt;</span>mediaobject<span style="color: #990000">&gt;</span>
        <span style="color: #990000">&lt;</span>imageobject<span style="color: #990000">&gt;</span>
          <span style="color: #990000">&lt;</span><span style="color: #008080">imagedata</span> fileref<span style="color: #990000">=</span><span style="color: #FF0000">"figs/projecoes-indices.svg"</span> format<span style="color: #990000">=</span><span style="color: #FF0000">"SVG"</span><span style="color: #990000">/&gt;</span>
        <span style="color: #990000">&lt;/</span>imageobject<span style="color: #990000">&gt;</span>
      <span style="color: #990000">&lt;/</span>mediaobject<span style="color: #990000">&gt;</span>
      <span style="color: #990000">&lt;/</span>figure<span style="color: #990000">&gt;</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="paragraph"><p>static int eixoy, eixox;
int largura, altura;
----       Define as duas variáveis &lt;varname&gt;eixoy&lt;/varname&gt; e &lt;varname&gt;eixox&lt;/varname&gt;, para armazenar as rotações em torno dos eixos y e x, respectivamente, e outras duas para armazenar a altura e a largura da tela de desenho.</p></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="color: #009900">void</span> <span style="font-weight: bold"><span style="color: #000000">init</span></span><span style="color: #990000">(</span><span style="color: #009900">void</span><span style="color: #990000">)</span><span style="color: #FF0000">{</span>
  <span style="font-weight: bold"><span style="color: #000000">glClearColor</span></span><span style="color: #990000">(</span><span style="color: #993399">0.0</span><span style="color: #990000">,</span> <span style="color: #993399">0.0</span><span style="color: #990000">,</span> <span style="color: #993399">0.0</span><span style="color: #990000">,</span> <span style="color: #993399">0.0</span><span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glOrtho</span></span> <span style="color: #990000">(-</span><span style="color: #993399">50</span><span style="color: #990000">,</span> <span style="color: #993399">50</span><span style="color: #990000">,</span> <span style="color: #990000">-</span><span style="color: #993399">50</span><span style="color: #990000">,</span> <span style="color: #993399">50</span><span style="color: #990000">,</span> <span style="color: #990000">-</span><span style="color: #993399">50</span> <span style="color: #990000">,</span> <span style="color: #993399">50</span><span style="color: #990000">);</span>
<span style="color: #990000">----</span>      <span style="color: #008080">Na</span> função `<span style="font-weight: bold"><span style="color: #000000">init</span></span><span style="color: #990000">()</span>`<span style="color: #990000">,</span> `<span style="font-weight: bold"><span style="color: #000000">glClearColor</span></span><span style="color: #990000">()</span>` <span style="color: #008080">define</span> <span style="font-weight: bold"><span style="color: #000000">PRETO</span></span> <span style="color: #990000">(</span>R<span style="color: #990000">,</span>G<span style="color: #990000">,</span>B<span style="color: #990000">)=(</span><span style="color: #993399">0</span><span style="color: #990000">,</span><span style="color: #993399">0</span><span style="color: #990000">,</span><span style="color: #993399">0</span><span style="color: #990000">)</span> como a cor de limpeza da área <span style="color: #008080">de</span> desenho<span style="color: #990000">.</span> A chamada à função `<span style="font-weight: bold"><span style="color: #000000">glOrtho</span></span><span style="color: #990000">()</span>` decide inicialmente que os objetos serão desenhados utilizando <span style="color: #008080">projeções</span> ortográficas<span style="color: #990000">.</span> De acordo com os parâmetros passados para <span style="color: #008080">esta</span> função<span style="color: #990000">,</span> os planos de <span style="color: #008080">recorte</span> serão<span style="color: #990000">:</span>
      <span style="color: #990000">&lt;</span>itemizedlist<span style="color: #990000">&gt;</span>
        <span style="color: #990000">-</span>esqueda <span style="color: #990000">=</span> <span style="color: #990000">-</span><span style="color: #993399">50</span><span style="color: #990000">;</span> direita<span style="color: #990000">=</span> <span style="color: #990000">+</span><span style="color: #993399">50</span>
        <span style="color: #990000">-</span>fundo <span style="color: #990000">=</span> <span style="color: #990000">-</span><span style="color: #993399">50</span><span style="color: #990000">;</span> topo<span style="color: #990000">=</span> <span style="color: #990000">+</span><span style="color: #993399">50</span>
        <span style="color: #990000">-</span>frente <span style="color: #990000">=</span> <span style="color: #990000">-</span><span style="color: #993399">50</span><span style="color: #990000">;</span> trás<span style="color: #990000">=</span> <span style="color: #990000">+</span><span style="color: #993399">50</span>
      <span style="color: #990000">&lt;/</span>itemizedlist<span style="color: #990000">&gt;</span>

      Este volume de recorte garante que todo o objeto ficará sempre visível quando as transformações forem efetuadas sobre <span style="color: #008080">o</span> mesmo<span style="color: #990000">.</span>
<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="paragraph"><p>void reshape (int w, int h){
  glViewport (0, 0, (GLsizei) w, (GLsizei) h);
  largura=w;
  altura=h;
}
----      A função <span class="monospaced">reshape()</span> é chamada cada vez que o tamanho da tela é alterado pelo usuário, atribuindo às variáveis &lt;varname&gt;largura&lt;/varname&gt; e &lt;varname&gt;altura&lt;/varname&gt; as novas dimensões da janela. Estas duas variáveis são utilizadas juntamente com a função <span class="monospaced">glViewport()</span> para tornar o cubo proporcional ao tamanho da janela.</p></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>  <span style="font-weight: bold"><span style="color: #000000">glPushMatrix</span></span><span style="color: #990000">();</span>
  <span style="font-weight: bold"><span style="color: #000000">glRotatef</span></span> <span style="color: #990000">((</span>GLfloat<span style="color: #990000">)</span> eixoy<span style="color: #990000">,</span> <span style="color: #993399">0.0</span><span style="color: #990000">,</span> <span style="color: #993399">1.0</span><span style="color: #990000">,</span> <span style="color: #993399">0.0</span><span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glRotatef</span></span> <span style="color: #990000">((</span>GLfloat<span style="color: #990000">)</span> eixox<span style="color: #990000">,</span> <span style="color: #993399">1.0</span><span style="color: #990000">,</span> <span style="color: #993399">0.0</span><span style="color: #990000">,</span> <span style="color: #993399">0.0</span><span style="color: #990000">);</span>
<span style="color: #990000">----</span>      Utilizando <span style="color: #008080">a</span> função `<span style="font-weight: bold"><span style="color: #000000">glPushMatrix</span></span><span style="color: #990000">()</span>`<span style="color: #990000">,</span> a posição e orientação <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> sistema de coordenadas original é guardado <span style="color: #008080">na</span> pilha<span style="color: #990000">.</span> Com <span style="color: #008080">as</span> funções `<span style="font-weight: bold"><span style="color: #000000">glRotatef</span></span><span style="color: #990000">()</span>` são realizadas rotações no objeto em torno dos eixos y <span style="color: #008080">e</span> x<span style="color: #990000">,</span> de modo possibilitar a visualização de <span style="color: #008080">outras</span> faces<span style="color: #990000">.</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="paragraph"><p>glEnableClientState(GL_VERTEX_ARRAY);
glVertexPointer(3, GL_FLOAT, 0, vertices);
----      Aqui entra uma característica nova do OpenGL: a possibilidade de desenhar objetos utilizando índices para referenciar as coordenadas dos seus vértices. Entretanto, esta característica deve ser habilitada com a chamada à função <span class="monospaced">glEnableClientState()</span>, caso contrário nada será desenhado. Os vértices do cubo são indexados através da chamada à função <span class="monospaced">glVertexPointer()</span>, que possui o seguinte protótipo:
      &lt;funcsynopsis&gt;
        &lt;funcprototype&gt;
          &lt;funcdef&gt;void <span class="monospaced">glVertexPointer</span>&lt;/funcdef&gt;
          &lt;paramdef&gt;GLint &lt;parameter&gt;size`&lt;/paramdef&gt;
          &lt;paramdef&gt;GLenum &lt;parameter&gt;type`&lt;/paramdef&gt;
          &lt;paramdef&gt;GLsizei &lt;parameter&gt;stride`&lt;/paramdef&gt;
          &lt;paramdef&gt;const GLvoid &lt;parameter&gt;*pointer`&lt;/paramdef&gt;
        &lt;/funcprototype&gt;
      &lt;/funcsynopsis&gt;
      O parâmetro &lt;parameter&gt;size` especifica o número de elementos que devem ser tomados do vetor &lt;parameter&gt;pointer` de cada vez para forma um vértice - neste caso, 3 elementos, uma para cada eixo coordenado. &lt;parameter&gt;type` especifica o tipo de dado contido no vetor e &lt;parameter&gt;stride` o deslocamento que deve ser realizado dentro do vetor entre vértices consecutivos. Como os elementos estão colados uns aos outros, &lt;parameter&gt;stride = 0`.</p></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="font-weight: bold"><span style="color: #000000">glDrawElements</span></span><span style="color: #990000">(</span>GL_POLYGON<span style="color: #990000">,</span> <span style="color: #993399">5</span><span style="color: #990000">,</span> GL_UNSIGNED_BYTE<span style="color: #990000">,</span> frenteIndices<span style="color: #990000">);</span></tt></pre></div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>A função `glDrawElements()` realiza o traçado deprimitivas com base em um vetor de dados. Neste exemplo, A primitiva a ser traçada é um polígono (&lt;parameter&gt;GL_POLYGON`) com 5 vértices, indexados pelo vetor &lt;parameter&gt;frenteIndices`, que é do tipo &lt;parameter&gt;GL_)UNSIGNED_BYTE`. As chamadas seguintes para esta função desenham o restante das faces do cubo.</pre>
</div></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="color: #009900">void</span> <span style="font-weight: bold"><span style="color: #000000">keyboard</span></span><span style="color: #990000">(</span><span style="color: #009900">unsigned</span> <span style="color: #009900">char</span> key<span style="color: #990000">,</span> <span style="color: #009900">int</span> x<span style="color: #990000">,</span> <span style="color: #009900">int</span> y<span style="color: #990000">)</span><span style="color: #FF0000">{</span>
  <span style="font-weight: bold"><span style="color: #0000FF">case</span></span> <span style="color: #FF0000">'p'</span><span style="color: #990000">:</span>
    <span style="font-weight: bold"><span style="color: #000000">glLoadIdentity</span></span><span style="color: #990000">();</span>
    <span style="font-weight: bold"><span style="color: #000000">gluPerspective</span></span><span style="color: #990000">(</span><span style="color: #993399">65.0</span><span style="color: #990000">,</span> <span style="color: #990000">(</span>GLfloat<span style="color: #990000">)</span> largura<span style="color: #990000">/(</span>GLfloat<span style="color: #990000">)</span> altura<span style="color: #990000">,</span> <span style="color: #993399">20.0</span><span style="color: #990000">,</span> <span style="color: #993399">120.0</span><span style="color: #990000">);</span>
    <span style="font-weight: bold"><span style="color: #000000">gluLookAt</span></span><span style="color: #990000">(</span><span style="color: #993399">0</span><span style="color: #990000">,</span> <span style="color: #993399">0</span><span style="color: #990000">,</span> <span style="color: #990000">-</span><span style="color: #993399">90</span><span style="color: #990000">,</span> <span style="color: #993399">0</span><span style="color: #990000">,</span> <span style="color: #993399">0</span><span style="color: #990000">,</span> <span style="color: #993399">0</span><span style="color: #990000">,</span> <span style="color: #993399">0</span><span style="color: #990000">,</span> <span style="color: #993399">1</span><span style="color: #990000">,</span> <span style="color: #993399">0</span><span style="color: #990000">);</span>
    <span style="font-weight: bold"><span style="color: #000000">glutPostRedisplay</span></span><span style="color: #990000">();</span>
    <span style="font-weight: bold"><span style="color: #0000FF">break</span></span><span style="color: #990000">;</span>
<span style="color: #990000">----</span>      <span style="color: #008080">Na</span> função `<span style="font-weight: bold"><span style="color: #000000">keyboard</span></span><span style="color: #990000">()</span>` é introduzida uma chamada à função `<span style="font-weight: bold"><span style="color: #000000">gluPerspective</span></span><span style="color: #990000">()</span>`<span style="color: #990000">.</span> Esta chamada faz com que todas as projeções efetuadas daí em diante sejam projeções <span style="color: #008080">de</span> perspectiva<span style="color: #990000">.</span> Esta função possui o <span style="color: #008080">seguinte</span> protótipo<span style="color: #990000">:</span>
      <span style="color: #990000">&lt;</span>funcsynopsis<span style="color: #990000">&gt;</span>
        <span style="color: #990000">&lt;</span>funcprototype<span style="color: #990000">&gt;</span>
          <span style="color: #990000">&lt;</span>funcdef<span style="color: #990000">&gt;</span><span style="color: #009900">void</span> `gluPerspective`<span style="color: #990000">&lt;/</span>funcdef<span style="color: #990000">&gt;</span>
          <span style="color: #990000">&lt;</span>paramdef<span style="color: #990000">&gt;</span>GLdouble <span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;</span>fovy`<span style="color: #990000">&lt;/</span>paramdef<span style="color: #990000">&gt;</span>
          <span style="color: #990000">&lt;</span>paramdef<span style="color: #990000">&gt;</span>GLdouble <span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;</span>aspect`<span style="color: #990000">&lt;/</span>paramdef<span style="color: #990000">&gt;</span>
          <span style="color: #990000">&lt;</span>paramdef<span style="color: #990000">&gt;</span>GLdouble <span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;</span>zNear`<span style="color: #990000">&lt;/</span>paramdef<span style="color: #990000">&gt;</span>
          <span style="color: #990000">&lt;</span>paramdef<span style="color: #990000">&gt;</span>GLdouble <span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;</span>zFar`<span style="color: #990000">&lt;/</span>paramdef<span style="color: #990000">&gt;</span>
        <span style="color: #990000">&lt;/</span>funcprototype<span style="color: #990000">&gt;</span>
      <span style="color: #990000">&lt;/</span>funcsynopsis<span style="color: #990000">&gt;</span>
      <span style="color: #008080">O</span> parâmetro <span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;</span>fovy` especifica o campo <span style="color: #008080">de</span> visão<span style="color: #990000">,</span> <span style="color: #008080">em</span> graus<span style="color: #990000">,</span> na <span style="color: #008080">direção</span> <span style="font-weight: bold"><span style="color: #000000">y</span></span> <span style="color: #990000">(</span><span style="color: #993399">65</span> graus<span style="color: #990000">).</span> <span style="color: #008080">O</span> parâmetro <span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;</span>aspect` define a relação de aspecto entre largura <span style="color: #008080">e</span> altura<span style="color: #990000">,</span> determinando o campo de visão na <span style="color: #008080">direção</span> <span style="font-weight: bold"><span style="color: #000000">x</span></span> <span style="color: #990000">(</span>largura<span style="color: #990000">/</span>altura<span style="color: #990000">).</span> <span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;</span>zNear` e <span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;</span>zFar` especificam as distâncias entre o observador e o planos de recorte mais próximo e <span style="color: #008080">mais</span> distante<span style="color: #990000">,</span> <span style="font-weight: bold"><span style="color: #000000">respectivamente</span></span> <span style="color: #990000">(</span><span style="color: #993399">20</span> e <span style="color: #993399">120</span><span style="color: #990000">).</span> A escolha deste valor assegura que o cubo não será recortado durante <span style="color: #008080">as</span> transformações<span style="color: #990000">.</span> Estas variáveis são <span style="color: #008080">ilustradas</span> na <span style="color: #990000">&lt;</span><span style="color: #008080">xref</span> linkend<span style="color: #990000">=</span><span style="color: #FF0000">"fig-projecoes-vista-perspectiva"</span><span style="color: #990000">/&gt;.</span>
      <span style="color: #990000">&lt;</span><span style="color: #008080">figure</span> xml<span style="color: #990000">:</span>id<span style="color: #990000">=</span><span style="color: #FF0000">"fig-projecoes-vista-perspectiva"</span><span style="color: #990000">&gt;</span>
        <span style="color: #990000">&lt;</span>title<span style="color: #990000">&gt;</span>Vista <span style="color: #008080">em</span> perspectiva<span style="color: #990000">.&lt;/</span>title<span style="color: #990000">&gt;</span>
      <span style="color: #990000">&lt;</span>mediaobject<span style="color: #990000">&gt;</span>
        <span style="color: #990000">&lt;</span>imageobject<span style="color: #990000">&gt;</span>
          <span style="color: #990000">&lt;</span><span style="color: #008080">imagedata</span> fileref<span style="color: #990000">=</span><span style="color: #FF0000">"figs/projecoes-vista-perspectiva.jpg"</span> format<span style="color: #990000">=</span><span style="color: #FF0000">"JPG"</span><span style="color: #990000">/&gt;</span>
        <span style="color: #990000">&lt;/</span>imageobject<span style="color: #990000">&gt;</span>
      <span style="color: #990000">&lt;/</span>mediaobject<span style="color: #990000">&gt;</span>
      <span style="color: #990000">&lt;/</span>figure<span style="color: #990000">&gt;</span>

      A chamada à função `<span style="font-weight: bold"><span style="color: #000000">gluLookAt</span></span><span style="color: #990000">()</span>` permite definir o ponto <span style="color: #008080">de</span> observação<span style="color: #990000">,</span> um ponto <span style="color: #008080">de</span> referência<span style="color: #990000">,</span> para onde o observador está olhando e a direção <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> vetor que aponta <span style="color: #008080">para</span> cima<span style="color: #990000">.</span> <span style="color: #008080">A</span> função `<span style="font-weight: bold"><span style="color: #000000">gluLookAt</span></span><span style="color: #990000">()</span>` possui o <span style="color: #008080">seguinte</span> protótipo<span style="color: #990000">:</span>
      <span style="color: #990000">&lt;</span>funcsynopsis<span style="color: #990000">&gt;</span>
        <span style="color: #990000">&lt;</span>funcprototype<span style="color: #990000">&gt;</span>
          <span style="color: #990000">&lt;</span>funcdef<span style="color: #990000">&gt;</span><span style="color: #009900">void</span> `gluLookAt`<span style="color: #990000">&lt;/</span>funcdef<span style="color: #990000">&gt;</span>
          <span style="color: #990000">&lt;</span>paramdef<span style="color: #990000">&gt;</span> GLdouble <span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;</span>eyex`<span style="color: #990000">&lt;/</span>paramdef<span style="color: #990000">&gt;</span>
          <span style="color: #990000">&lt;</span>paramdef<span style="color: #990000">&gt;</span> GLdouble <span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;</span>eyey`<span style="color: #990000">&lt;/</span>paramdef<span style="color: #990000">&gt;</span>
          <span style="color: #990000">&lt;</span>paramdef<span style="color: #990000">&gt;</span> GLdouble <span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;</span>eyez`<span style="color: #990000">&lt;/</span>paramdef<span style="color: #990000">&gt;</span>
          <span style="color: #990000">&lt;</span>paramdef<span style="color: #990000">&gt;</span> GLdouble <span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;</span>centerx`<span style="color: #990000">&lt;/</span>paramdef<span style="color: #990000">&gt;</span>
          <span style="color: #990000">&lt;</span>paramdef<span style="color: #990000">&gt;</span> GLdouble <span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;</span>centery`<span style="color: #990000">&lt;/</span>paramdef<span style="color: #990000">&gt;</span>
          <span style="color: #990000">&lt;</span>paramdef<span style="color: #990000">&gt;</span> GLdouble <span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;</span>centerz`<span style="color: #990000">&lt;/</span>paramdef<span style="color: #990000">&gt;</span>
          <span style="color: #990000">&lt;</span>paramdef<span style="color: #990000">&gt;</span> GLdouble <span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;</span>upx`<span style="color: #990000">&lt;/</span>paramdef<span style="color: #990000">&gt;</span>
          <span style="color: #990000">&lt;</span>paramdef<span style="color: #990000">&gt;</span> GLdouble <span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;</span>upy`<span style="color: #990000">&lt;/</span>paramdef<span style="color: #990000">&gt;</span>
          <span style="color: #990000">&lt;</span>paramdef<span style="color: #990000">&gt;</span> GLdouble <span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;</span>upz`<span style="color: #990000">&lt;/</span>paramdef<span style="color: #990000">&gt;</span>
        <span style="color: #990000">&lt;/</span>funcprototype<span style="color: #990000">&gt;</span>
      <span style="color: #990000">&lt;/</span>funcsynopsis<span style="color: #990000">&gt;</span>
      <span style="color: #008080">Neste</span> exemplo<span style="color: #990000">,</span> o <span style="color: #008080">observador</span> encontra<span style="color: #990000">-</span>se sobre o <span style="color: #008080">eixo</span> z<span style="color: #990000">,</span> <span style="color: #008080">em</span> z<span style="color: #990000">=-</span><span style="color: #993399">90</span><span style="color: #990000">,</span> <span style="color: #990000">(</span>eixox<span style="color: #990000">,</span> eixoy<span style="color: #990000">,</span> eixoz<span style="color: #990000">)</span> <span style="color: #990000">=</span> <span style="color: #990000">(</span><span style="color: #993399">0</span><span style="color: #990000">,</span> <span style="color: #993399">0</span><span style="color: #990000">,</span> <span style="color: #990000">-</span><span style="color: #993399">90</span><span style="color: #990000">),</span> está olhando para <span style="color: #008080">a</span> origem<span style="color: #990000">,</span> <span style="color: #990000">(</span>centerx<span style="color: #990000">,</span> centery<span style="color: #990000">,</span> centerz<span style="color: #990000">)</span> <span style="color: #990000">=</span> <span style="color: #990000">(</span><span style="color: #993399">0</span><span style="color: #990000">,</span> <span style="color: #993399">0</span><span style="color: #990000">,</span> <span style="color: #993399">0</span><span style="color: #990000">)</span> e a direção <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> vetor que aponta para cima é <span style="color: #990000">(</span>upx<span style="color: #990000">,</span> upy<span style="color: #990000">,</span> upz<span style="color: #990000">)</span> <span style="color: #990000">=</span> <span style="color: #990000">(</span> <span style="color: #993399">0</span><span style="color: #990000">,</span> <span style="color: #993399">1</span><span style="color: #990000">,</span> <span style="color: #993399">0</span><span style="color: #990000">),</span> alinhado com o <span style="color: #008080">eixo</span> y<span style="color: #990000">.</span>
      Antes de chamar as funções de projeção de perspectiva <span style="color: #008080">ou</span> ortográfica<span style="color: #990000">,</span> deve<span style="color: #990000">-</span>se tomar cuidado para antes reiniciar a localização e orientação <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> sistema de coordenadas usando <span style="color: #008080">a</span> função `<span style="font-weight: bold"><span style="color: #000000">glLoadIdentity</span></span><span style="color: #990000">()</span>`<span style="color: #990000">,</span> caso contrário a projeção será feita no sistema de <span style="color: #008080">coordenadas</span> corrente<span style="color: #990000">,</span> levando a <span style="color: #008080">resultados</span> indesejados<span style="color: #990000">.</span>
    <span style="color: #990000">&lt;/</span>sect1<span style="color: #990000">&gt;</span>
    <span style="color: #990000">&lt;</span><span style="color: #008080">sect1</span> xml<span style="color: #990000">:</span>id<span style="color: #990000">=</span><span style="color: #FF0000">"projecoes-exercicios"</span><span style="color: #990000">&gt;</span>
      <span style="color: #990000">&lt;</span>title<span style="color: #990000">&gt;</span>Exercícios<span style="color: #990000">&lt;/</span>title<span style="color: #990000">&gt;</span>
      <span style="color: #990000">&lt;</span>orderedlist<span style="color: #990000">&gt;</span>
        <span style="color: #990000">-</span>Utilizando o <span style="color: #008080">programa</span> link<span style="color: #990000">:</span>exemplos<span style="color: #990000">/</span>projecoes<span style="color: #990000">.</span>c<span style="color: #FF0000">"&gt;&lt;filename&gt;projecoes.c&lt;/filename&gt;&lt;/link&gt; como referência, implemente um programa &lt;filename&gt;tiposdeprojecoes.c&lt;/filename&gt;. Este programa deverá conter mais sete opções de teclado: &lt;keycap&gt;t&lt;/keycap&gt; e &lt;keycap&gt;f&lt;/keycap&gt;, para exibir o topo e o fundo do objeto, &lt;keycap&gt;F&lt;/keycap&gt; e &lt;keycap&gt;T&lt;/keycap&gt;, para mostrar a frente e a face traseira, &lt;keycap&gt;e&lt;/keycap&gt; e &lt;keycap&gt;d&lt;/keycap&gt;, para mostrar a faces esquerda e direita, respectivamente, e a tecla &lt;keycap&gt;c&lt;/keycap&gt;, para mostrar o triângulo do canto.</span>
<span style="color: #FF0000">        -A função `glutIdleFunc()` é usada pelo GLUT para realizar operações em segundo plano ou animações, enquanto não recebe eventos de sistema. O seu protótipo é:</span>
<span style="color: #FF0000">          &lt;funcsynopsis&gt;</span>
<span style="color: #FF0000">            &lt;funcprototype&gt;</span>
<span style="color: #FF0000">              &lt;funcdef&gt;void `glutIdleFunc`&lt;/funcdef&gt;</span>
<span style="color: #FF0000">              &lt;paramdef&gt;void &lt;parameter&gt;*func`&lt;funcparams&gt;void&lt;/funcparams&gt;&lt;/paramdef&gt;</span>
<span style="color: #FF0000">            &lt;/funcprototype&gt;</span>
<span style="color: #FF0000">          &lt;/funcsynopsis&gt;</span>
<span style="color: #FF0000">          Tomando como base o programa link:exemplos/projecoes.c"</span><span style="color: #990000">&gt;&lt;</span>filename<span style="color: #990000">&gt;</span>projecoes<span style="color: #990000">.</span><span style="color: #008080">c&lt;/filename&gt;&lt;/link&gt;, utilizando a função `glutIdleFunc()` e crie uma função de retorno `idle()`. Nesta função, os valores dos ângulos &lt;varname&gt;eixox&lt;/varname&gt; e &lt;varname&gt;eixoy&lt;/varname&gt; devem ser incrementados de valores constantes pequenos e diferentes, de modo a possibilitar uma animação. Utilize a função `usleep()` para introduzir retardos entre as apresentações dos quadros da animação, tornando mais agradável a visualização. Mantenhas as teclas &lt;keycap&gt;o&lt;/keycap&gt;</span> e <span style="color: #990000">&lt;</span>keycap<span style="color: #990000">&gt;</span>p<span style="color: #990000">&lt;/</span>keycap<span style="color: #990000">&gt;</span> para chavear entre projeções ortogonais e <span style="color: #008080">de</span> perspectiva<span style="color: #990000">.</span>
      <span style="color: #990000">&lt;/</span>orderedlist<span style="color: #990000">&gt;</span>
    <span style="color: #990000">&lt;/</span>sect1<span style="color: #990000">&gt;</span>
  <span style="color: #990000">&lt;/</span>chapter<span style="color: #990000">&gt;</span>

  <span style="color: #990000">&lt;!--</span> curvas <span style="color: #008080">no</span> plano <span style="color: #990000">--&gt;</span>

  <span style="color: #990000">&lt;</span><span style="color: #008080">chapter</span> xml<span style="color: #990000">:</span>id<span style="color: #990000">=</span><span style="color: #FF0000">"curvas-plano"</span><span style="color: #990000">&gt;</span>
    <span style="color: #990000">&lt;</span>title<span style="color: #990000">&gt;</span>Curvas <span style="color: #008080">no</span> plano<span style="color: #990000">&lt;/</span>title<span style="color: #990000">&gt;</span>
    O propósito desta lição é mostrar como gerar em um plano as curvas paramétricas mais comuns <span style="color: #008080">no</span> OpenGL<span style="color: #990000">:</span> as curvas de Bézier e <span style="color: #008080">as</span> <span style="font-weight: bold"><span style="color: #000000">NURBS</span></span> <span style="color: #990000">(</span><span style="color: #FF0000">'Non Uniform Rational B-Splines'</span><span style="color: #990000">).</span> A forma destas curvas é controlada pelo posicionamento dos vértices de um <span style="color: #008080">polígono</span> característico<span style="color: #990000">,</span> cuja influência será estudada de forma interativa no <span style="color: #008080">programa</span> exemplo<span style="color: #990000">.</span> Será estudada também a influência dos vetores de nós sobre <span style="color: #008080">as</span> NURBS<span style="color: #990000">,</span> vetores estes que servem para definir a região de influência de cada vértice <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> polígono característico na forma <span style="color: #008080">da</span> curva<span style="color: #990000">.</span>
    É introduzido também o uso de uma nova função <span style="color: #008080">do</span> GLUT<span style="color: #990000">:</span> `<span style="font-weight: bold"><span style="color: #000000">glutMotionFunc</span></span><span style="color: #990000">()</span>`<span style="color: #990000">,</span> ativada quando o mouse é movimentado pela janela enquanto um ou mais botões <span style="color: #008080">são</span> pressionados<span style="color: #990000">.</span>
    O programa utilizado nesta lição permite que o usuário controle a forma de uma curva através da seleção e movimentação <span style="color: #008080">dos</span> vé<span style="font-weight: bold"><span style="color: #000000">rtices</span></span> <span style="color: #990000">(</span>destacados <span style="color: #008080">em</span> vermelho<span style="color: #990000">)</span> de <span style="color: #008080">um</span> polí<span style="font-weight: bold"><span style="color: #000000">gono</span></span> <span style="color: #990000">(</span><span style="color: #008080">em</span> amarelo<span style="color: #990000">),</span> como <span style="color: #008080">mostra</span> a <span style="color: #990000">&lt;</span><span style="color: #008080">xref</span> linkend<span style="color: #990000">=</span><span style="color: #FF0000">"fig-curvas-plano-splines"</span><span style="color: #990000">/&gt;.</span>
    <span style="color: #990000">&lt;</span><span style="color: #008080">figure</span> xml<span style="color: #990000">:</span>id<span style="color: #990000">=</span><span style="color: #FF0000">"fig-curvas-plano-splines"</span><span style="color: #990000">&gt;</span>
      <span style="color: #990000">&lt;</span>title<span style="color: #990000">&gt;</span>Traçado interativo <span style="color: #008080">de</span> splines<span style="color: #990000">.&lt;/</span>title<span style="color: #990000">&gt;</span>
      <span style="color: #990000">&lt;</span>mediaobject<span style="color: #990000">&gt;</span>
        <span style="color: #990000">&lt;</span>imageobject<span style="color: #990000">&gt;</span>
          <span style="color: #990000">&lt;</span><span style="color: #008080">imagedata</span> fileref<span style="color: #990000">=</span><span style="color: #FF0000">"figs/curvas-plano-splines.jpg"</span> format<span style="color: #990000">=</span><span style="color: #FF0000">"JPG"</span><span style="color: #990000">/&gt;</span>
        <span style="color: #990000">&lt;/</span>imageobject<span style="color: #990000">&gt;</span>
      <span style="color: #990000">&lt;/</span>mediaobject<span style="color: #990000">&gt;</span>
    <span style="color: #990000">&lt;/</span>figure<span style="color: #990000">&gt;</span>
     O programa usado para modelar as splines é <span style="color: #008080">mostrado</span> no <span style="color: #990000">&lt;</span><span style="color: #008080">xref</span> linkend<span style="color: #990000">=</span><span style="color: #FF0000">"example-curvas-plano"</span><span style="color: #990000">/&gt;.</span> <span style="color: #008080">As</span> teclas <span style="color: #990000">&lt;</span>keycap<span style="color: #990000">&gt;</span><span style="color: #008080">b&lt;/keycap&gt;</span> e <span style="color: #990000">&lt;</span>keycap<span style="color: #990000">&gt;</span>n<span style="color: #990000">&lt;/</span>keycap<span style="color: #990000">&gt;</span> definem o tipo de curva que <span style="color: #008080">será</span> desenhada<span style="color: #990000">:</span> Bézier <span style="color: #008080">ou</span> NURBS<span style="color: #990000">,</span> respectivamente<span style="color: #990000">.</span>

    <span style="color: #990000">&lt;</span><span style="color: #008080">example</span> xml<span style="color: #990000">:</span>id<span style="color: #990000">=</span><span style="color: #FF0000">"example-curvas-plano"</span><span style="color: #990000">&gt;</span>
      <span style="color: #990000">&lt;</span>title<span style="color: #990000">&gt;</span><span style="color: #008080">programa</span> link<span style="color: #990000">:</span>exemplos<span style="color: #990000">/</span>splines2d<span style="color: #990000">.</span>c<span style="color: #FF0000">"&gt;&lt;filename&gt;splines2d.c&lt;/filename&gt;&lt;/link&gt;&lt;/title&gt;</span>
<span style="color: #FF0000">      &lt;programlisting&gt;</span>
<span style="color: #FF0000">        &lt;textobject&gt;&lt;textdata fileref="</span><span style="color: #990000">&amp;</span>caminho<span style="color: #990000">;/</span>exemplos<span style="color: #990000">/</span>splines2d<span style="color: #990000">.</span>c<span style="color: #FF0000">" format="</span>linespecific<span style="color: #FF0000">"/&gt;&lt;/textobject&gt;</span>
<span style="color: #FF0000">      &lt;/programlisting&gt;</span>
<span style="color: #FF0000">    &lt;/example&gt;</span>

<span style="color: #FF0000">    Para compilar e executar o programa link:exemplos/splines2d.c"</span><span style="color: #990000">&gt;&lt;</span>filename<span style="color: #990000">&gt;</span>splines2d<span style="color: #990000">.</span>c<span style="color: #990000">&lt;/</span>filename<span style="color: #990000">&gt;&lt;/</span>link<span style="color: #990000">&gt;,</span> salve<span style="color: #990000">-</span>o juntamente com o <span style="color: #008080">arquivo</span> link<span style="color: #990000">:</span>exemplos<span style="color: #990000">/</span>Makefile<span style="color: #FF0000">"&gt;Makefile&lt;/link&gt; em um diretório e execute a seguinte seqüência de comandos:</span>
<span style="color: #FF0000">    &lt;screen&gt;</span>
<span style="color: #FF0000">&lt;prompt&gt;$&lt;/prompt&gt; &lt;command&gt;make&lt;/command&gt; &lt;option&gt;splines2d&lt;/option&gt;</span>
<span style="color: #FF0000">&lt;prompt&gt;$&lt;/prompt&gt; &lt;command&gt;splines2d&lt;/command&gt;</span>
<span style="color: #FF0000">&lt;/screen&gt;</span>
<span style="color: #FF0000">    &lt;sect1 xml:id="</span>curvas<span style="color: #990000">-</span>plano<span style="color: #990000">-</span>descricao<span style="color: #FF0000">"&gt;</span>
<span style="color: #FF0000">      &lt;title&gt;Descrição do programa &lt;filename&gt;splines2d.c&lt;/filename&gt;&lt;/title&gt;</span>

<span style="color: #FF0000">[source,c]</span></tt></pre></div></div>
<div class="paragraph"><p>GLint nVertices=6;
GLfloat vertices[6][3] = {
  {-4.0,  0.0, 0.0},
  {-4.0, +4.0, 0.0},
  {+4.0, -4.0, 0.0},
  {-4.0, -4.0, 0.0},
  {+4.0, +4.0, 0.0},
  {+4.0,  0.0, 0.0}
};
----      Define o número de vértices do polígono característico (variável &lt;varname&gt;nVertices&lt;/varname&gt;) e as posições no espaço dos seus respectivos vértices (vetor &lt;varname&gt;vertices&lt;/varname&gt;).</p></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="color: #008080">GLint</span> largura<span style="color: #990000">,</span> altura<span style="color: #990000">;</span>
<span style="color: #008080">GLint</span> mudaCurva<span style="color: #990000">=</span><span style="color: #993399">0</span><span style="color: #990000">;</span>
<span style="color: #008080">GLint</span> verticeCorrente<span style="color: #990000">=</span><span style="color: #993399">0</span><span style="color: #990000">;</span>
<span style="color: #990000">----</span>      <span style="color: #008080">As</span> variáveis <span style="color: #990000">&lt;</span>varname<span style="color: #990000">&gt;</span><span style="color: #008080">largura&lt;/varname&gt;</span> e <span style="color: #990000">&lt;</span>varname<span style="color: #990000">&gt;</span>altura<span style="color: #990000">&lt;/</span>varname<span style="color: #990000">&gt;</span> armazenam a largura e a altura da <span style="color: #008080">janela</span> corrente<span style="color: #990000">,</span> <span style="color: #008080">em</span> pixels<span style="color: #990000">.</span> <span style="color: #990000">&lt;</span>varname<span style="color: #990000">&gt;</span>mudaCurva<span style="color: #990000">&lt;/</span>varname<span style="color: #990000">&gt;</span> grava o estado <span style="color: #008080">da</span> curva<span style="color: #990000">;</span> quando <span style="color: #990000">&lt;</span>varname<span style="color: #990000">&gt;</span>mudaCurva<span style="color: #990000">&lt;/</span>varname<span style="color: #990000">&gt;=</span><span style="color: #993399">1</span><span style="color: #990000">,</span> a posição dos vértices pode <span style="color: #008080">ser</span> alterada<span style="color: #990000">;</span> quando <span style="color: #990000">&lt;</span>varname<span style="color: #990000">&gt;</span>mudaCurva<span style="color: #990000">&lt;/</span>varname<span style="color: #990000">&gt;=</span><span style="color: #993399">0</span><span style="color: #990000">,</span> a curva permanece inalterada com o movimento <span style="color: #008080">do</span> mouse<span style="color: #990000">.</span> <span style="color: #008080">A</span> variável <span style="color: #990000">&lt;</span>varname<span style="color: #990000">&gt;</span>verticeCorrente<span style="color: #990000">&lt;/</span>varname<span style="color: #990000">&gt;</span> indica o vértice cuja posição poderá ser alterada através da movimentação <span style="color: #008080">do</span> mouse<span style="color: #990000">.</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="paragraph"><p>GLfloat esquerda=-5;
GLfloat direita =+5;
GLfloat fundo   =-5;
GLfloat topo    =+5;
GLfloat longe   =+5;
GLfloat perto   =-5;
----      Define as coordenadas do volume de recorte a ser utilizado na projeção ortográfica.</p></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="color: #008080">GLUnurbsObj</span> <span style="color: #990000">*</span>nc<span style="color: #990000">;</span>
<span style="color: #008080">GLfloat</span> nos<span style="color: #990000">[</span><span style="color: #993399">10</span><span style="color: #990000">]=</span><span style="color: #FF0000">{</span><span style="color: #993399">0.0</span><span style="color: #990000">,</span> <span style="color: #993399">0.0</span><span style="color: #990000">,</span> <span style="color: #993399">0.0</span><span style="color: #990000">,</span> <span style="color: #993399">0.0</span><span style="color: #990000">,</span> <span style="color: #993399">1.0</span><span style="color: #990000">,</span> <span style="color: #993399">2.5</span><span style="color: #990000">,</span> <span style="color: #993399">3.0</span><span style="color: #990000">,</span> <span style="color: #993399">3.0</span><span style="color: #990000">,</span> <span style="color: #993399">3.0</span><span style="color: #990000">,</span> <span style="color: #993399">6.0</span><span style="color: #FF0000">}</span><span style="color: #990000">;</span>
<span style="color: #008080">GLint</span> nNos<span style="color: #990000">=</span><span style="color: #993399">10</span><span style="color: #990000">;</span>
<span style="color: #990000">----</span>      <span style="color: #008080">A</span> variável <span style="color: #990000">&lt;</span>varname<span style="color: #990000">&gt;</span><span style="color: #008080">nc&lt;/varname&gt; contém a referência para a spline que irá modelar a curva usando NURBS. &lt;varname&gt;nos&lt;/varname&gt;</span> e <span style="color: #990000">&lt;</span>varname<span style="color: #990000">&gt;</span>nNos<span style="color: #990000">&lt;/</span>varname<span style="color: #990000">&gt;</span> são o vetor de nós e o número de nós <span style="color: #008080">neste</span> vetor<span style="color: #990000">,</span> respectivamente<span style="color: #990000">.</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="paragraph"><p>GLint matrizViewport[4];
GLdouble matrizModelview[16], matrizProjecao[16];
----      Define as matrizes de viewport, de modelo e de projeção para a cena. Estas matrizes serão usadas no cálculo da posição do mouse no mundo real.</p></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>    <span style="font-weight: bold"><span style="color: #000000">glMap1f</span></span><span style="color: #990000">(</span>GL_MAP1_VERTEX_3<span style="color: #990000">,</span> <span style="color: #993399">0.0</span><span style="color: #990000">,</span> <span style="color: #993399">1.0</span><span style="color: #990000">,</span> <span style="color: #993399">3</span><span style="color: #990000">,</span> nVertices<span style="color: #990000">,</span> <span style="color: #990000">&amp;</span>vertices<span style="color: #990000">[</span><span style="color: #993399">0</span><span style="color: #990000">][</span><span style="color: #993399">0</span><span style="color: #990000">]);</span>
<span style="color: #990000">----</span>      Caso a spline seja <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> <span style="color: #008080">tipo</span> Bézier<span style="color: #990000">,</span> o traçado da curva se com o uso <span style="color: #008080">de</span> avaliadores<span style="color: #990000">.</span> Tais <span style="color: #FF0000">'evaluators'</span> proporcionam uma forma de utilizar o mapeamento de polinômios para <span style="color: #008080">produzir</span> vértices<span style="color: #990000">,</span> coordenadas de texturas <span style="color: #008080">e</span> cores<span style="color: #990000">,</span> baseados em funções de base <span style="color: #008080">de</span> Bernstein<span style="color: #990000">,</span> ou <span style="color: #008080">de</span> Bézier<span style="color: #990000">.</span>
      <span style="color: #008080">A</span> função `<span style="font-weight: bold"><span style="color: #000000">glMap1f</span></span><span style="color: #990000">()</span>` define <span style="color: #008080">um</span> <span style="font-weight: bold"><span style="color: #000000">avaliador</span></span> <span style="color: #990000">(</span><span style="color: #FF0000">'evaluator'</span><span style="color: #990000">)</span> unidimesional<span style="color: #990000">.</span> <span style="color: #008080">Neste</span> caso<span style="color: #990000">,</span> os valores gerados por esta função são utilizados pelos estágios posteriores <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> processamento como se houvessem sido gerados utilizando <span style="color: #008080">a</span> função `glVertex<span style="color: #990000">*()</span>`<span style="color: #990000">.</span>
      <span style="color: #008080">A</span> função `<span style="font-weight: bold"><span style="color: #000000">glMap1f</span></span><span style="color: #990000">()</span>` possui o <span style="color: #008080">seguinte</span> protótipo<span style="color: #990000">:</span>
      <span style="color: #990000">&lt;</span>funcsynopsis<span style="color: #990000">&gt;</span>
        <span style="color: #990000">&lt;</span>funcprototype<span style="color: #990000">&gt;</span>
          <span style="color: #990000">&lt;</span>funcdef<span style="color: #990000">&gt;</span><span style="color: #009900">void</span> `glMap1f`<span style="color: #990000">&lt;/</span>funcdef<span style="color: #990000">&gt;</span>
          <span style="color: #990000">&lt;</span>paramdef<span style="color: #990000">&gt;</span>GLenum <span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;</span>target`<span style="color: #990000">&lt;/</span>paramdef<span style="color: #990000">&gt;</span>
          <span style="color: #990000">&lt;</span>paramdef<span style="color: #990000">&gt;</span>GLfloat<span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;</span>u1`<span style="color: #990000">&lt;/</span>paramdef<span style="color: #990000">&gt;</span>
          <span style="color: #990000">&lt;</span>paramdef<span style="color: #990000">&gt;</span>GLfloat<span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;</span>u2`<span style="color: #990000">&lt;/</span>paramdef<span style="color: #990000">&gt;</span>
          <span style="color: #990000">&lt;</span>paramdef<span style="color: #990000">&gt;</span>GLint <span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;</span>stride`<span style="color: #990000">&lt;/</span>paramdef<span style="color: #990000">&gt;</span>
          <span style="color: #990000">&lt;</span>paramdef<span style="color: #990000">&gt;</span>GLint <span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;</span>order`<span style="color: #990000">&lt;/</span>paramdef<span style="color: #990000">&gt;</span>
          <span style="color: #990000">&lt;</span>paramdef<span style="color: #990000">&gt;</span><span style="font-weight: bold"><span style="color: #0000FF">const</span></span> GLfloat <span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;*</span>points`<span style="color: #990000">&lt;/</span>paramdef<span style="color: #990000">&gt;</span>
        <span style="color: #990000">&lt;/</span>funcprototype<span style="color: #990000">&gt;</span>
      <span style="color: #990000">&lt;/</span>funcsynopsis<span style="color: #990000">&gt;</span>
      <span style="color: #008080">O</span> parâmetro <span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;</span>target` especifica o tipo de valores <span style="color: #008080">gerados</span> pelo <span style="color: #FF0000">'evaluator'</span><span style="color: #990000">;</span> <span style="color: #008080">neste</span> caso<span style="color: #990000">,</span> especifica que cada ponto de controle é usado para mapear três <span style="color: #008080">valores</span> x<span style="color: #990000">,</span> y <span style="color: #008080">e</span> z<span style="color: #990000">.</span> <span style="color: #008080">Comandos</span> internos `glVertex<span style="color: #990000">*()</span>` são gerados quando este mapeamento é realizado<span style="color: #990000">.</span> <span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;</span>u1` e <span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;</span>u2` especificam a faixa de mapeamento linear <span style="color: #008080">para</span> u<span style="color: #990000">,</span> <span style="color: #008080">ou</span> seja<span style="color: #990000">,</span> a faixa de variação <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> parâmetro que define <span style="color: #008080">a</span> curva<span style="color: #990000">;</span> <span style="color: #008080">neste</span> caso <span style="color: #990000">[</span><span style="color: #993399">0</span><span style="color: #990000">,</span><span style="color: #993399">1</span><span style="color: #990000">].</span> <span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;</span>stride` especifica o número de elementos entre o início de um ponto de controle e o início <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> ponto de <span style="color: #008080">controle</span> seguinte<span style="color: #990000">;</span> como cada ponto de controle possui <span style="color: #008080">três</span> coordenadas<span style="color: #990000">,</span> <span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;</span>stride<span style="color: #990000">=</span>`<span style="color: #993399">3</span> para <span style="color: #008080">este</span> exemplo<span style="color: #990000">.</span> <span style="color: #008080">O</span> parâmetro <span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;</span>order` especifica o número de pontos de controle para <span style="color: #008080">a</span> <span style="font-weight: bold"><span style="color: #000000">curva</span></span> <span style="color: #990000">(</span><span style="color: #993399">6</span> pontos<span style="color: #990000">).</span> Finalmente<span style="color: #990000">,</span> <span style="color: #008080">o</span> parâmetro <span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;*</span>points` deve conter a posição <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> primeiro ponto <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> polígono <span style="color: #008080">de</span> controle<span style="color: #990000">.</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>    glBegin(GL_LINE_STRIP);
    for (i = 0; i &lt;= 30; i++){
      glEvalCoord1f((GLfloat) i/30.0);
    }
    glEnd();
----      Neste laço, quando a função `glEvalCoord1f()` é chamada, o valor do ponto a ser traçado na spline é calculado (ou avaliado) para o valor passado como referência para esta função. Quando o laço terminar, um conjunto de pontos interligados (via &lt;parameter&gt;GL_LINE_STRIP`) irá compor a forma da curva de Bézier, usando o polígono de controle especificado a priorio com a função `glMap1f()`.</pre>
</div></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>    <span style="font-weight: bold"><span style="color: #000000">gluBeginCurve</span></span><span style="color: #990000">(</span>nc<span style="color: #990000">);</span>
    <span style="font-weight: bold"><span style="color: #000000">gluNurbsCurve</span></span><span style="color: #990000">(</span>nc<span style="color: #990000">,</span> nNos<span style="color: #990000">,</span> nos<span style="color: #990000">,</span> <span style="color: #993399">3</span><span style="color: #990000">,</span> <span style="color: #990000">&amp;</span>vertices<span style="color: #990000">[</span><span style="color: #993399">0</span><span style="color: #990000">][</span><span style="color: #993399">0</span><span style="color: #990000">],</span> <span style="color: #993399">4</span><span style="color: #990000">,</span> GL_MAP1_VERTEX_3<span style="color: #990000">);</span>
    <span style="font-weight: bold"><span style="color: #000000">gluEndCurve</span></span><span style="color: #990000">(</span>nc<span style="color: #990000">);</span>
<span style="color: #990000">----</span>      Se a curva a ser desenhada <span style="font-weight: bold"><span style="color: #0000FF">for</span></span> <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> <span style="color: #008080">tipo</span> NURBS<span style="color: #990000">,</span> então <span style="color: #008080">as</span> funções `<span style="font-weight: bold"><span style="color: #000000">gluBeginCurve</span></span><span style="color: #990000">()</span>` e `<span style="font-weight: bold"><span style="color: #000000">gluEndCurve</span></span><span style="color: #990000">()</span>` serão utilizadas para demarcar o início e o fim <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> <span style="color: #008080">seu</span> traçado<span style="color: #990000">.</span> A função usada para desenhar esta classe de curvas é `gluNurbsCurve`<span style="color: #990000">,</span> cujos parâmetros são bastante semelhantes aos <span style="color: #008080">da</span> função `<span style="font-weight: bold"><span style="color: #000000">glMap1f</span></span><span style="color: #990000">()</span>`<span style="color: #990000">,</span> acrescentando apenas a referência para <span style="color: #008080">a</span> curva<span style="color: #990000">,</span> <span style="color: #990000">&lt;</span>varname<span style="color: #990000">&gt;</span><span style="color: #008080">nc&lt;/varname&gt; e os dados do vetor de nós (&lt;varname&gt;nos&lt;/varname&gt;</span> e <span style="color: #990000">&lt;</span>varname<span style="color: #990000">&gt;</span>nNos<span style="color: #990000">&lt;/</span>varname<span style="color: #990000">&gt;).</span> <span style="color: #008080">A</span> variável <span style="color: #990000">&lt;</span>varname<span style="color: #990000">&gt;</span>nc<span style="color: #990000">&lt;/</span>varname<span style="color: #990000">&gt;</span> é iniciada <span style="color: #008080">na</span> função `<span style="font-weight: bold"><span style="color: #000000">init</span></span><span style="color: #990000">()</span>`<span style="color: #990000">.</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>  glPointSize(5.0);
----      O diâmetro dos pontos rasterizados é mudado para facilitar a visualização dos vértices do polígono de controle (5 pixels).</pre>
</div></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>  nc<span style="color: #990000">=</span> <span style="font-weight: bold"><span style="color: #000000">gluNewNurbsRenderer</span></span><span style="color: #990000">();</span>
  <span style="font-weight: bold"><span style="color: #000000">gluNurbsProperty</span></span><span style="color: #990000">(</span>nc<span style="color: #990000">,</span> GLU_SAMPLING_TOLERANCE<span style="color: #990000">,</span> <span style="color: #993399">5.0</span><span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glEnable</span></span><span style="color: #990000">(</span>GL_MAP1_VERTEX_3<span style="color: #990000">);</span>
<span style="color: #990000">----</span>      <span style="color: #008080">A</span> função `<span style="font-weight: bold"><span style="color: #000000">gluNewNurbsRenderer</span></span><span style="color: #990000">()</span>` cria um <span style="color: #008080">objeto</span> NURBS<span style="color: #990000">,</span> que pode ser referenciado durante a chamada para o traçado de curvas <span style="color: #008080">desta</span> caterogia<span style="color: #990000">.</span> <span style="color: #008080">A</span> função `<span style="font-weight: bold"><span style="color: #000000">gluNurbsProperty</span></span><span style="color: #990000">()</span>` aqui colocada define o <span style="color: #008080">espaçamento</span> máximo<span style="color: #990000">,</span> <span style="color: #008080">em</span> pixels<span style="color: #990000">,</span> usado na amostragem <span style="color: #008080">de</span> pontos<span style="color: #990000">,</span> durante o traçado <span style="color: #008080">da</span> curva<span style="color: #990000">,</span> geralmente traçada por <span style="color: #008080">aproximação</span> poligonal<span style="color: #990000">.</span> <span style="color: #008080">Neste</span> exemplo<span style="color: #990000">,</span> pontos adjacentes <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> polígono que aproxima a curva têm espacamento máximo de <span style="color: #993399">5</span> pixels<span style="color: #990000">.</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>  glGetIntegerv(GL_VIEWPORT, matrizViewport);
  glGetDoublev(GL_MODELVIEW_MATRIX, matrizModelview);
  glGetDoublev(GL_PROJECTION_MATRIX, matrizProjecao);
----      As chamadas às funções `glGetIntergerv` e `glGetDoublev` gravam em &lt;varname&gt;matrizViewport&lt;/varname&gt;, &lt;varname&gt;matrizModelview&lt;/varname&gt; e &lt;varname&gt;matrizProjecao&lt;/varname&gt; as matrizes de viewport, de modelo e de projeção. Na matriz de viewport ficam armazenadas as coordenadas da origem da janela, seguidas pela sua altura e largura.</pre>
</div></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="color: #009900">void</span> <span style="font-weight: bold"><span style="color: #000000">proximidade</span></span><span style="color: #990000">()</span><span style="color: #FF0000">{</span>
  <span style="color: #009900">int</span> i<span style="color: #990000">;</span>
  <span style="color: #009900">double</span> tam<span style="color: #990000">=</span><span style="color: #993399">0</span><span style="color: #990000">,</span> tamin<span style="color: #990000">=</span><span style="color: #993399">32000</span><span style="color: #990000">;</span>
  verticeCorrente<span style="color: #990000">=</span><span style="color: #993399">0</span><span style="color: #990000">;</span>
  <span style="font-weight: bold"><span style="color: #0000FF">for</span></span><span style="color: #990000">(</span>i<span style="color: #990000">=</span><span style="color: #993399">0</span><span style="color: #990000">;</span> i<span style="color: #990000">&lt;</span>nVertices<span style="color: #990000">;</span> i<span style="color: #990000">++)</span><span style="color: #FF0000">{</span>
    tam <span style="color: #990000">=</span> <span style="color: #990000">(</span>wx<span style="color: #990000">-</span>vertices<span style="color: #990000">[</span>i<span style="color: #990000">][</span><span style="color: #993399">0</span><span style="color: #990000">])*(</span>wx<span style="color: #990000">-</span>vertices<span style="color: #990000">[</span>i<span style="color: #990000">][</span><span style="color: #993399">0</span><span style="color: #990000">])+</span>
      <span style="color: #990000">(</span>wy<span style="color: #990000">-</span>vertices<span style="color: #990000">[</span>i<span style="color: #990000">][</span><span style="color: #993399">1</span><span style="color: #990000">])*(</span>wy<span style="color: #990000">-</span>vertices<span style="color: #990000">[</span>i<span style="color: #990000">][</span><span style="color: #993399">1</span><span style="color: #990000">]);</span>
    <span style="font-weight: bold"><span style="color: #0000FF">if</span></span><span style="color: #990000">(</span>tam <span style="color: #990000">&lt;</span> tamin<span style="color: #990000">)</span><span style="color: #FF0000">{</span>
      tamin<span style="color: #990000">=</span>tam<span style="color: #990000">;</span>
      verticeCorrente<span style="color: #990000">=</span>i<span style="color: #990000">;</span>
    <span style="color: #FF0000">}</span>
  <span style="color: #FF0000">}</span>
  tamin<span style="color: #990000">=</span><span style="font-weight: bold"><span style="color: #000000">sqrt</span></span><span style="color: #990000">(</span>tamin<span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #0000FF">if</span></span><span style="color: #990000">(</span>tamin <span style="color: #990000">&gt;</span> <span style="color: #993399">0.5</span><span style="color: #990000">)</span><span style="color: #FF0000">{</span>
    mudaCurva<span style="color: #990000">=</span><span style="color: #993399">0</span><span style="color: #990000">;</span>
  <span style="color: #FF0000">}</span>
<span style="color: #FF0000">}</span>
<span style="color: #990000">----</span>      <span style="color: #008080">A</span> função `<span style="font-weight: bold"><span style="color: #000000">proximidade</span></span><span style="color: #990000">()</span>` compara os valores das distâncias entre a posição <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> mouse em coordenadas <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> <span style="color: #008080">mundo</span> real<span style="color: #990000">,</span> <span style="color: #990000">(</span>wx<span style="color: #990000">,</span> wy<span style="color: #990000">),</span> com as coordenadas de cada vértice <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> polígono <span style="color: #008080">de</span> controle<span style="color: #990000">,</span> em busca <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> vértice <span style="color: #008080">mais</span> próximo<span style="color: #990000">.</span> Caso a distância entre a posição <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> mouse e o vértice mais próximo seja maior que uma <span style="color: #008080">dada</span> tolerância<span style="color: #990000">,</span> o vértice não será selecionado <span style="color: #008080">para</span> alteração<span style="color: #990000">.</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>      yreal = matrizViewport[3] - (GLint) y - 1;
      gluUnProject ((GLdouble) x, (GLdouble) yreal, 0.0,
                    matrizModelview, matrizProjecao, matrizViewport,
                    &amp;wx, &amp;wy, &amp;wz);
----       A variável &lt;varname&gt;yreal&lt;/varname&gt; armazena a coordenada y (em pixels) da posição do cursor, assumindo origem na parte inferior esquerda da janela.
      A função `gluUnProject()` serve para mapear as coordenadas da janela para as coordenadas do mundo real. Com base nas coordenadas do mouse na janela, &lt;varname&gt;x&lt;/varname&gt; e &lt;varname&gt;yreal&lt;/varname&gt;, nas matrizes de modelo, de projeção e de viewport, e assumindo a posição z=0, a função `gluUnProject()` calcula as respectivas coordenadas wx, wy e wz da posição do mouse no mundo real, possibilitando a comparação das distâncias para cada vértice do polígono característico.</pre>
</div></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="color: #009900">void</span> <span style="font-weight: bold"><span style="color: #000000">motion</span></span><span style="color: #990000">(</span><span style="color: #009900">int</span> x<span style="color: #990000">,</span> <span style="color: #009900">int</span> y<span style="color: #990000">)</span><span style="color: #FF0000">{</span>
  <span style="font-weight: bold"><span style="color: #0000FF">if</span></span><span style="color: #990000">(</span>mudaCurva<span style="color: #990000">)</span><span style="color: #FF0000">{</span>
    yreal <span style="color: #990000">=</span> matrizViewport<span style="color: #990000">[</span><span style="color: #993399">3</span><span style="color: #990000">]</span> <span style="color: #990000">-</span> <span style="color: #990000">(</span>GLint<span style="color: #990000">)</span> y <span style="color: #990000">-</span> <span style="color: #993399">1</span><span style="color: #990000">;</span>
    <span style="font-weight: bold"><span style="color: #000000">gluUnProject</span></span> <span style="color: #990000">((</span>GLdouble<span style="color: #990000">)</span> x<span style="color: #990000">,</span> <span style="color: #990000">(</span>GLdouble<span style="color: #990000">)</span> yreal<span style="color: #990000">,</span> <span style="color: #993399">0.0</span><span style="color: #990000">,</span>
                  matrizModelview<span style="color: #990000">,</span> matrizProjecao<span style="color: #990000">,</span> matrizViewport<span style="color: #990000">,</span>
                  <span style="color: #990000">&amp;</span>wx<span style="color: #990000">,</span> <span style="color: #990000">&amp;</span>wy<span style="color: #990000">,</span> <span style="color: #990000">&amp;</span>wz<span style="color: #990000">);</span>
    vertices<span style="color: #990000">[</span>verticeCorrente<span style="color: #990000">][</span><span style="color: #993399">0</span><span style="color: #990000">]=</span>wx<span style="color: #990000">;</span>
    vertices<span style="color: #990000">[</span>verticeCorrente<span style="color: #990000">][</span><span style="color: #993399">1</span><span style="color: #990000">]=</span>wy<span style="color: #990000">;</span>
    <span style="font-weight: bold"><span style="color: #000000">glutPostRedisplay</span></span><span style="color: #990000">();</span>
  <span style="color: #FF0000">}</span>
<span style="color: #FF0000">}</span>
<span style="color: #990000">----</span>      <span style="color: #008080">A</span> função `<span style="font-weight: bold"><span style="color: #000000">motion</span></span><span style="color: #990000">()</span>` é chamada cada vez que o mouse é movimentado na janela e um ou mais <span style="color: #008080">botões</span> encontra<span style="color: #990000">-</span><span style="color: #008080">se</span> pressionado<span style="color: #990000">.</span> Caso a alteração dos vértices <span style="color: #008080">esteja</span> habilitada<span style="color: #990000">,</span> as coordenadas da posição <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> mouse são mapeadas para o mundo real e atribuídas ao vértice a <span style="color: #008080">ser</span> modificado<span style="color: #990000">.</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>  glutMotionFunc(motion);
----      Define a função de movimentação do mouse para a janela corrente. A função passada como parâmetro deve possuir o seguinte protótipo:
      &lt;funcsynopsis&gt;
        &lt;funcprototype&gt;
          &lt;funcdef&gt;void `funcao()`&lt;/funcdef&gt;
          &lt;paramdef&gt;int &lt;parameter&gt;x`&lt;/paramdef&gt;
          &lt;paramdef&gt;int &lt;parameter&gt;y`&lt;/paramdef&gt;
        &lt;/funcprototype&gt;
      &lt;/funcsynopsis&gt;
      Os parâmetros &lt;parameter&gt;x` e &lt;parameter&gt;y` passados para esta função indicam a posição do mouse em coordenadas relativas à janela.
      Caso seja necessário, a função `glutPassiveMotionFunc` pode ser utilizada para monitorar o movimento do mouse quando não há botões pressionados, e possui o mesmo protótipo da função `glutMotionFunc`
    &lt;/sect1&gt;
    &lt;sect1 xml:id="curvas-plano-exercicios"&gt;
      &lt;title&gt;Exercícios&lt;/title&gt;
      &lt;orderedlist&gt;
        - Comente as funcionalidades das curvas de Bézier e NURBS utilizadas neste exemplo.
        - Utilizando o programa link:exemplos/splines2d.c"&gt;&lt;filename&gt;splines2d.c&lt;/filename&gt;&lt;/link&gt; como referência, implemente um programa &lt;filename&gt;splinesnurbs.c&lt;/filename&gt;. Quando a tecla &lt;keycap&gt;u&lt;/keycap&gt; for pressionada, a NURBS deverá ser desenhada utilizando um vetor de nós uniforme. Quando a tecla &lt;keycap&gt;o&lt;/keycap&gt; for pressionada, a NURBS deverá ser desenhada utilizando um vetor de nós uniforme aberto. Quando a tecla &lt;keycap&gt;n&lt;/keycap&gt; for pressionada, a NURBS deverá ser desenhada utilizando um vetor de nós não uniforme.
        -Qual a influência do vetor de nós foi utilizado sobre o comportamento das curvas tipo NURBS? Comente o resultado que obteve para curvas de ordens 3 e 5.
        -Compare curvas de Beziér com NURBS considerando ordens iguais para ambas as curvas.
      &lt;/orderedlist&gt;
    &lt;/sect1&gt;
  &lt;/chapter&gt;</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>&lt;!-- superfícies no espaço --&gt;</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>&lt;chapter xml:id="superficies-espaco"&gt;
  &lt;title&gt;Superfícies no espaço&lt;/title&gt;
  O propósito desta lição é mostrar como gerar no espaço as superfícies paramétricas de Bézier e NURBS utilizando OpenGL. De modo semelhante às curvas descritas no &lt;xref linkend="curvas-plano"/&gt;, a forma destas superfícies é controlada pelo posicionamento de vértices, desta vez componentes de um malha característica. Com a resolução dos exercícios propostos no final da lição, o aluno poderá notar a utilidade das superfícies apresentadas, associando-as a uma situação prática, através da modelagem interativa de uma superfície.
  Será mostrado também como introduzir iluminação na cena, de modo a tornar a apresentação da superfície mais realística.
  A superfície gerada pelo programa utilizado nesta lição é mostrado na &lt;xref linkend="fig-superficies-espaco-splines"/&gt;.
  &lt;figure xml:id="fig-superficies-espaco-splines"&gt;
    &lt;title&gt;Traçado de superfícies.&lt;/title&gt;
    &lt;mediaobject&gt;
      &lt;imageobject&gt;
        &lt;imagedata fileref="figs/superficies-espaco-splines.jpg" format="JPG"/&gt;
      &lt;/imageobject&gt;
    &lt;/mediaobject&gt;
  &lt;/figure&gt;
   O programa usado para modelar as splines é mostrado no &lt;xref linkend="example-superficies-espaco"/&gt;. As teclas &lt;keycap&gt;b&lt;/keycap&gt; e &lt;keycap&gt;n&lt;/keycap&gt; definem o tipo de curva que será desenhada: Bézier ou NURBS, respectivamente. As teclas &lt;keycap&gt;x&lt;/keycap&gt; e &lt;keycap&gt;X&lt;/keycap&gt;, rotacionam a superfície em torno do eixo x. As teclas &lt;keycap&gt;y&lt;/keycap&gt; e &lt;keycap&gt;Y&lt;/keycap&gt;, rotacionam a superfície em torno do eixo y. As teclas &lt;keycap&gt;z&lt;/keycap&gt; e &lt;keycap&gt;Z&lt;/keycap&gt;, rotacionam a superfície em torno do eixo z.</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>&lt;example xml:id="example-superficies-espaco"&gt;
  &lt;title&gt;programa link:exemplos/splines3d.c"&gt;&lt;filename&gt;splines3d.c&lt;/filename&gt;&lt;/link&gt;&lt;/title&gt;
  &lt;programlisting&gt;
    &lt;textobject&gt; &lt;textdata fileref="&amp;caminho;/exemplos/splines3d.c" format="linespecific"/&gt;&lt;/textobject&gt;
  &lt;/programlisting&gt;
&lt;/example&gt;</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>    Para compilar e executar o programa link:exemplos/splines3d.c"&gt;&lt;filename&gt;splines3d.c&lt;/filename&gt;&lt;/link&gt;, salve-o juntamente com o arquivo link:exemplos/Makefile"&gt;Makefile&lt;/link&gt; em um diretório e execute a seguinte seqüência de comandos:
    &lt;screen&gt;
&lt;prompt&gt;$&lt;/prompt&gt; &lt;command&gt;make&lt;/command&gt; &lt;option&gt;splines3d&lt;/option&gt;
&lt;prompt&gt;$&lt;/prompt&gt; &lt;command&gt;splines3d&lt;/command&gt;
&lt;/screen&gt;
    &lt;sect1 xml:id="superficies-espaco-descricao"&gt;
      &lt;title&gt;Descrição do programa &lt;filename&gt;splines3d.c&lt;/filename&gt;&lt;/title&gt;</pre>
</div></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="color: #008080">GLint</span> nVertices<span style="color: #990000">=</span><span style="color: #993399">4</span><span style="color: #990000">;</span>
<span style="color: #008080">GLfloat</span> vertices<span style="color: #990000">[</span><span style="color: #993399">4</span><span style="color: #990000">][</span><span style="color: #993399">4</span><span style="color: #990000">][</span><span style="color: #993399">3</span><span style="color: #990000">];</span>
<span style="color: #990000">----</span>      Define o número de vértices da <span style="color: #008080">malha</span> caracterí<span style="font-weight: bold"><span style="color: #000000">stica</span></span> <span style="color: #990000">(</span>variável <span style="color: #990000">&lt;</span>varname<span style="color: #990000">&gt;</span>nVertices<span style="color: #990000">&lt;/</span>varname<span style="color: #990000">&gt;)</span> e as posições no espaço dos seus <span style="color: #008080">respectivos</span> vé<span style="font-weight: bold"><span style="color: #000000">rtices</span></span> <span style="color: #990000">(</span>matriz <span style="color: #990000">&lt;</span>varname<span style="color: #990000">&gt;</span>vertices<span style="color: #990000">&lt;/</span>varname<span style="color: #990000">&gt;).</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="paragraph"><p>GLint largura, altura;
----      As variáveis &lt;varname&gt;largura&lt;/varname&gt; e &lt;varname&gt;altura&lt;/varname&gt; armazenam a largura e a altura da janela corrente, em pixels.</p></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="color: #008080">GLUnurbsObj</span> <span style="color: #990000">*</span>nc<span style="color: #990000">;</span>
<span style="color: #008080">GLfloat</span> nos<span style="color: #990000">[</span><span style="color: #993399">8</span><span style="color: #990000">]=</span><span style="color: #FF0000">{</span><span style="color: #993399">0.0</span><span style="color: #990000">,</span> <span style="color: #993399">0.0</span><span style="color: #990000">,</span> <span style="color: #993399">0.0</span><span style="color: #990000">,</span> <span style="color: #993399">0.0</span><span style="color: #990000">,</span> <span style="color: #993399">1.0</span><span style="color: #990000">,</span> <span style="color: #993399">1.0</span><span style="color: #990000">,</span> <span style="color: #993399">1.0</span><span style="color: #990000">,</span> <span style="color: #993399">1.0</span><span style="color: #FF0000">}</span><span style="color: #990000">;</span>
<span style="color: #008080">GLint</span> nNos<span style="color: #990000">=</span><span style="color: #993399">8</span><span style="color: #990000">;</span>
<span style="color: #990000">----</span>      <span style="color: #008080">A</span> variável <span style="color: #990000">&lt;</span>varname<span style="color: #990000">&gt;</span><span style="color: #008080">nc&lt;/varname&gt; contém a referência para a spline que irá modelar a superfície tipo NURBS. &lt;varname&gt;nos&lt;/varname&gt;</span> e <span style="color: #990000">&lt;</span>varname<span style="color: #990000">&gt;</span>nNos<span style="color: #990000">&lt;/</span>varname<span style="color: #990000">&gt;</span> são o vetor de nós e o número de nós <span style="color: #008080">neste</span> vetor<span style="color: #990000">,</span> respectivamente<span style="color: #990000">.</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="paragraph"><p>void gera_superficie(void);
----      Cria as coordenadas x, y e z dos pontos da malha de controle.</p></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>  <span style="font-weight: bold"><span style="color: #000000">glBegin</span></span><span style="color: #990000">(</span>GL_LINES<span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glVertex3f</span></span><span style="color: #990000">(</span><span style="color: #993399">0</span><span style="color: #990000">,</span><span style="color: #993399">0</span><span style="color: #990000">,</span><span style="color: #993399">0</span><span style="color: #990000">);</span>  <span style="font-weight: bold"><span style="color: #000000">glVertex3f</span></span><span style="color: #990000">(</span><span style="color: #993399">1</span><span style="color: #990000">,</span><span style="color: #993399">0</span><span style="color: #990000">,</span><span style="color: #993399">0</span><span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glEnd</span></span><span style="color: #990000">();</span>
  <span style="font-weight: bold"><span style="color: #000000">glRasterPos3f</span></span><span style="color: #990000">(</span><span style="color: #993399">1.5</span><span style="color: #990000">,</span><span style="color: #993399">0</span><span style="color: #990000">,</span><span style="color: #993399">0</span><span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glutBitmapCharacter</span></span><span style="color: #990000">(</span>GLUT_BITMAP_TIMES_ROMAN_10<span style="color: #990000">,</span> <span style="color: #FF0000">'x'</span><span style="color: #990000">);</span>
<span style="color: #990000">----</span>      Cria um segmento de reta representando o <span style="color: #008080">eixo</span> x<span style="color: #990000">.</span> <span style="color: #008080">A</span> função ` <span style="font-weight: bold"><span style="color: #000000">glRasterPos3f</span></span><span style="color: #990000">()</span>` define a posição <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> rasterizador para operações <span style="color: #008080">com</span> <span style="font-weight: bold"><span style="color: #000000">pixels</span></span> <span style="color: #990000">(</span>desenho <span style="color: #008080">de</span> bitmaps<span style="color: #990000">).</span> <span style="color: #008080">Neste</span> caso<span style="color: #990000">,</span> o rasterizador é posicionado na ponta <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> <span style="color: #008080">eixo</span> x<span style="color: #990000">.</span> <span style="color: #008080">Em</span> seguida<span style="color: #990000">,</span> <span style="color: #008080">a</span> função `<span style="font-weight: bold"><span style="color: #000000">glutBitmapCharacter</span></span><span style="color: #990000">()</span>` é utilizada para desenhar um mapa de bits <span style="color: #008080">do</span> caracter <span style="color: #FF0000">'x'</span> com a <span style="color: #008080">fonte</span> especificada<span style="color: #990000">.</span> Outras duas operações semelhantes são realizadas para os eixos y <span style="color: #008080">e</span> z<span style="color: #990000">.</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>glMap2f(GL_MAP2_VERTEX_3, 0.0, 1.0, 3, 4, 0, 1, 3*nVertices, 4, &amp;vertices[0][0][0]);</pre>
</div></div>
<div class="listingblock">
<div class="content monospaced">
<pre>      Caso a superfície seja do tipo Bézier, o seu traçado também se com o uso de avaliadores (semelhante ao caso bidimensional). A função `glMap2f()` define um avaliador bididimesional.
      A função `glMap2f()` possui o seguinte protótipo:
      &lt;funcsynopsis&gt;
        &lt;funcprototype&gt;
          &lt;funcdef&gt;void `glMap1f`&lt;/funcdef&gt;
          &lt;paramdef&gt;GLenum &lt;parameter&gt;target`&lt;/paramdef&gt;
          &lt;paramdef&gt;GLfloat&lt;parameter&gt;u1`&lt;/paramdef&gt;
          &lt;paramdef&gt;GLfloat&lt;parameter&gt;u2`&lt;/paramdef&gt;
          &lt;paramdef&gt;GLint &lt;parameter&gt;ustride`&lt;/paramdef&gt;
          &lt;paramdef&gt;GLint &lt;parameter&gt;uorder`&lt;/paramdef&gt;
          &lt;paramdef&gt;GLfloat&lt;parameter&gt;v1`&lt;/paramdef&gt;
          &lt;paramdef&gt;GLfloat&lt;parameter&gt;v2`&lt;/paramdef&gt;
          &lt;paramdef&gt;GLint &lt;parameter&gt;vstride`&lt;/paramdef&gt;
          &lt;paramdef&gt;GLint &lt;parameter&gt;vorder`&lt;/paramdef&gt;
          &lt;paramdef&gt;const GLfloat &lt;parameter&gt;*points`&lt;/paramdef&gt;
        &lt;/funcprototype&gt;
      &lt;/funcsynopsis&gt;
      O parâmetro &lt;parameter&gt;target` especifica o tipo de valores gerados pelo 'evaluator'; neste caso, especifica que cada ponto de controle é usado para mapear três valores x, y e z. Comandos internos `glVertex*()` são gerados quando este mapeamento é realizado. &lt;parameter&gt;u1` e &lt;parameter&gt;u2` especificam a faixa de mapeamento linear para u (direção x), ou seja, a faixa de variação do parâmetro que define a curva; neste caso [0,1]. &lt;parameter&gt;ustride` especifica o número de elementos entre o início de um ponto de controle e o início do ponto de controle seguinte; como cada ponto de controle possui três coordenadas, &lt;parameter&gt;ustride=`3 para este exemplo. O parâmetro &lt;parameter&gt;order` especifica o número de pontos de controle para a curva (6 pontos). Estes quatro parâmetros repetem-se para o mapeamento de 'v', relativo à direção y da superfície. Finalmente, o parâmetro &lt;parameter&gt;*points` deve conter a posição do primeiro ponto da malha de controle.

[source,c]</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>    glEnable(GL_AUTO_NORMAL);
    glMapGrid2f(20, 0, 1.0, 20, 0, 1.0);
    glEvalMesh2(GL_FILL, 0, 20, 0, 20);
----      As funções `glMapGrid2f()` e `glEvalMesh2()` são utilizadas em conjunto para gerar uma série valores de 'u' e 'v' e avaliar as coordenadas x, y e z do pontos da superfície, para cada um dos pares de parâmetros (u,v). Foi definido 20 subdivisões para as faixas de cada parâmetro, [0,1].
      Na função `glEvalMesh2()` foi especificado que a superfície deveria ser preenchida (GL_FILL), mas poderia também ser traçada utilizando linhas (GL_LINES) ou pontos (GL_POINTS). Os parâmetros seguintes passados para essa função indicam os primeiros e últimos valores inteiros utilizados para as posições do grid de desenho.
      Foi habilitado, através do parâmetro &lt;parameter&gt;GL_AUTO_NORMAL`, o cálculo automático dos vetores normais aos pontos da superfície, utilizados no processo de iluminação da cena.</pre>
</div></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>    <span style="font-weight: bold"><span style="color: #000000">gluBeginSurface</span></span><span style="color: #990000">(</span>nc<span style="color: #990000">);</span>
    <span style="font-weight: bold"><span style="color: #000000">gluNurbsSurface</span></span><span style="color: #990000">(</span>nc<span style="color: #990000">,</span> nNos<span style="color: #990000">,</span> nos<span style="color: #990000">,</span> nNos<span style="color: #990000">,</span> nos<span style="color: #990000">,</span> <span style="color: #993399">4</span><span style="color: #990000">*</span><span style="color: #993399">3</span><span style="color: #990000">,</span> <span style="color: #993399">3</span><span style="color: #990000">,</span> <span style="color: #990000">&amp;</span>vertices<span style="color: #990000">[</span><span style="color: #993399">0</span><span style="color: #990000">][</span><span style="color: #993399">0</span><span style="color: #990000">][</span><span style="color: #993399">0</span><span style="color: #990000">],</span> <span style="color: #993399">4</span><span style="color: #990000">,</span> <span style="color: #993399">4</span><span style="color: #990000">,</span> GL_MAP2_VERTEX_3<span style="color: #990000">);</span>
    <span style="font-weight: bold"><span style="color: #000000">gluEndSurface</span></span><span style="color: #990000">(</span>nc<span style="color: #990000">);</span>
<span style="color: #990000">----</span>      Se a curva a ser desenhada <span style="font-weight: bold"><span style="color: #0000FF">for</span></span> <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> <span style="color: #008080">tipo</span> NURBS<span style="color: #990000">,</span> então <span style="color: #008080">as</span> funções `<span style="font-weight: bold"><span style="color: #000000">gluBeginSurface</span></span><span style="color: #990000">()</span>` e `<span style="font-weight: bold"><span style="color: #000000">gluEndSurface</span></span><span style="color: #990000">()</span>` serão utilizadas para demarcar o início e o fim <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> <span style="color: #008080">seu</span> traçado<span style="color: #990000">.</span> A função usada para desenhar esta classe de superfícies é `gluNurbsSurface`<span style="color: #990000">,</span> cujos parâmetros são semelhantes aos <span style="color: #008080">da</span> função `<span style="font-weight: bold"><span style="color: #000000">gluNurbsCurve</span></span><span style="color: #990000">()</span>`<span style="color: #990000">,</span> acrescentando o vetor de nós e o número de nós na <span style="color: #008080">direção</span> <span style="font-weight: bold"><span style="color: #000000">y</span></span> <span style="color: #990000">(&lt;</span>varname<span style="color: #990000">&gt;</span><span style="color: #008080">nos&lt;/varname&gt;</span> e <span style="color: #990000">&lt;</span>varname<span style="color: #990000">&gt;</span>nNos<span style="color: #990000">&lt;/</span>varname<span style="color: #990000">&gt;),</span> os deslocamentos entre sucessivos pontos <span style="color: #008080">de</span> <span style="font-weight: bold"><span style="color: #000000">controle</span></span> <span style="color: #990000">(</span><span style="color: #FF0000">'stride'</span><span style="color: #990000">)</span> nas <span style="color: #008080">duas</span> direçõ<span style="font-weight: bold"><span style="color: #000000">es</span></span> <span style="color: #990000">(</span><span style="color: #993399">4</span><span style="color: #990000">*</span><span style="color: #993399">3</span> e <span style="color: #993399">3</span><span style="color: #990000">),</span> e as ordens da superfície em ambas <span style="color: #008080">as</span> direçõ<span style="font-weight: bold"><span style="color: #000000">es</span></span> <span style="color: #990000">(</span><span style="color: #993399">4</span> e <span style="color: #993399">4</span><span style="color: #990000">).</span> <span style="color: #008080">A</span> variável <span style="color: #990000">&lt;</span>varname<span style="color: #990000">&gt;</span>nc<span style="color: #990000">&lt;/</span>varname<span style="color: #990000">&gt;</span> é iniciada <span style="color: #008080">na</span> função `<span style="font-weight: bold"><span style="color: #000000">init</span></span><span style="color: #990000">()</span>`<span style="color: #990000">.</span>
      Neste exemplo o valor <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> deslocamento na direção x é <span style="color: #993399">12</span> <span style="color: #990000">(</span><span style="color: #993399">4</span><span style="color: #990000">*</span><span style="color: #993399">3</span><span style="color: #990000">)</span> porque existem três coordenadas para <span style="color: #008080">cada</span> vé<span style="font-weight: bold"><span style="color: #000000">rtice</span></span> <span style="color: #990000">(&lt;</span>parameter<span style="color: #990000">&gt;</span>GL_MAP2_VERTEX_3`<span style="color: #990000">)</span> e quatro pontos de controle na <span style="color: #008080">direção</span> v<span style="color: #990000">.</span> O valor <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> deslocamento na direção v é <span style="color: #993399">3</span> porque cada vértice tem <span style="color: #008080">três</span> coordenadas<span style="color: #990000">,</span> e os pontos de controle v são adjacentes uns aos outros <span style="color: #008080">na</span> memória<span style="color: #990000">.</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>GLfloat mat_diffuse[] = { 0.7, 0.7, 0.7, 1.0 };
GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };
GLfloat mat_shininess[] = { 100.0 };</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>  glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
  glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
  glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);
----      Define as características do material que serão utilizadas pelo modelo de iluminação, através da função `glMaterialfv()`. Por enquanto estes recursos são apenas ilustrativos, pois serão abordados em uma lição posterior.</pre>
</div></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>  <span style="font-weight: bold"><span style="color: #000000">glShadeModel</span></span><span style="color: #990000">(</span>GL_SMOOTH<span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glEnable</span></span><span style="color: #990000">(</span>GL_MAP2_VERTEX_3<span style="color: #990000">);</span>
<span style="color: #990000">----</span>      <span style="color: #008080">A</span> função `<span style="font-weight: bold"><span style="color: #000000">glShadeModel</span></span><span style="color: #990000">()</span>` define o modelo de sombreamento usado <span style="color: #008080">na</span> superfície<span style="color: #990000">.</span> <span style="color: #008080">O</span> parâmetro <span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;</span>GL_SMOOTH` torna a <span style="color: #008080">superfície</span> suave<span style="color: #990000">,</span> <span style="color: #008080">mais</span> realística<span style="color: #990000">.</span> Da mesma forma que <span style="color: #008080">a</span> função `<span style="font-weight: bold"><span style="color: #000000">glMaterialfv</span></span><span style="color: #990000">()</span>`<span style="color: #990000">,</span> a presença desta também é ilustrativa<span style="color: #990000">,</span> pois também será abordada em uma <span style="color: #008080">lição</span> posterior<span style="color: #990000">.</span>
      Se <span style="color: #008080">o</span> parâmetro <span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;</span>GL_MAP2_VERTEX_3` <span style="color: #008080">for</span> hatilitado<span style="color: #990000">,</span> chamadas à<span style="color: #008080">s</span> funções `<span style="font-weight: bold"><span style="color: #000000">glEvalCoord2</span></span><span style="color: #990000">()</span>`<span style="color: #990000">,</span> `glEvalMesh2` e `glEvalPoint2` irão gerar vértices com <span style="color: #008080">coordenadas</span> x<span style="color: #990000">,</span> y <span style="color: #008080">e</span> z<span style="color: #990000">,</span> necessárias ao traçado <span style="color: #008080">das</span> superfícies<span style="color: #990000">.</span>
<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>  glEnable(GL_AUTO_NORMAL);
  glEnable(GL_NORMALIZE);
----      Aqui, a geração automática de vetores normais à superfície é habilitado via &lt;parameter&gt;GL_AUTO_NORMAL`. Após gerados, os vetores normais são escalados de modo a ficarem com módulo igual a 1, melhorando a exibição da superfície.
    &lt;/sect1&gt;
    &lt;sect1 xml:id="superficies-espaco-exercicios"&gt;
      &lt;title&gt;Exercícios&lt;/title&gt;
      &lt;orderedlist&gt;
        -Utilizando as técnicas de seleção de objetos apresentadas no &lt;xref linkend="superficies-espaco"/&gt;, implemente um programa &lt;filename&gt;splineinter.c&lt;/filename&gt; que proporcione um processo de modelagem interativa para este exemplo. Utilizando o botão esquerdo do mouse, o usuário deverá poder movimentar os pontos da malha de controle, podendo assim controlar livremente a forma da superfície.
          Um método de seleção envolve lançar um raio através da localização do mouse e testar a proximidade com os objetos da cena. O raio pode ser gerado chamando duas vezes a função `gluUnProject()`, uma vez para o plano mais próximo do usuário (winz=0) e outra para o plano mais distante (winz=1). Subtraindo o resultado obtido para o plano mais distante do resultado obtido para o plano mais próximo será possível obter a direção do raio. A origem do raio ficará na posição do observador, no plano mais próximo.
          A posição do ponto em uma reta que se encontra mais próxima de um dado ponto no espaço pode obtida pela seguinte equação:
          &lt;screen&gt;
                   P_o + (R - P_o) dot V
                         ---------------  V
                             V dot V
&lt;/screen&gt;
          Nesta equação, P_o é obtida da equação que define a reta, P(t) = P_o + V t. V é o vetor que dá a direção da reta, e 'dot' representa a operação de produto interno.
      &lt;/orderedlist&gt;
    &lt;/sect1&gt;
  &lt;/chapter&gt;</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>&lt;!-- modelagem de sólidos --&gt;</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>&lt;chapter xml:id="modelagem-solidos"&gt;
  &lt;title&gt;Modelagem de Sólidos&lt;/title&gt;
  O propósito desta lição é introduzir o uso de listas de apresentação ('display lists'), mapeamento de texturas e o uso de teclas especiais.
  As listas de apresentação permitem que vários comandos sejam executados de uma vez só apenas com uma chamada da lista. Cada lista de apresentação precisa ser armazenada apenas uma vez, de modo que quando uma chamada é realizada, todos os comandos declarados nesta lista já estarão presentes máquina interna do OpenGL, tornando o processo de desenho mais fácil e com performance melhorada.
  O mapeamento de texturas nos objetos torna a cena mais realística, principalmente quando texturas de objetos reais são utilizadas. A maioria das texturas existentes não podem ser geradas de forma artificial. Quando isto é possível, os algoritmos utilizados são complexos e computacionamente custosos. Assim, geramente as texturas são lidas de arquivos de imagens digitais capturadas com dispositivos de arquisição de dados.
  Diversos formatos podem ser usados para armazenar uma imagem digital: bmp, jpeg, gif, tif, tga etc. Neste curso usaremos o formato IRIS RGB, criado pela Silicon Graphics. As funções que permitem a leitura de arquivos RGB e seus respectivos protótipos estão implementados nos arquivos link:exemplos/image.c"&gt;&lt;filename&gt;image.c&lt;/filename&gt;&lt;/link&gt; e link:exemplos/image.h"&gt;&lt;filename&gt;image.h&lt;/filename&gt;&lt;/link&gt;.
  O objeto utilizado nesta lição será um modelo simples de uma avião a jato com fuselagem texturizada, imóvel sobre um plano com textura montanhosa, como mostra a &lt;xref linkend="fig-modelagem-jato-3d"/&gt;. As vistas laterais, superior e frontal estão esquematizadas na &lt;xref linkend="fig-modelagem-jato"/&gt;.
  &lt;figure xml:id="fig-modelagem-jato-3d"&gt;
    &lt;title&gt;Avião a jato tridimensional&lt;/title&gt;
    &lt;mediaobject&gt;
      &lt;imageobject&gt;
        &lt;imagedata fileref="figs/modelagem-jato-3d.jpg" format="JPG"/&gt;
      &lt;/imageobject&gt;
    &lt;/mediaobject&gt;
  &lt;/figure&gt;
  &lt;figure xml:id="fig-modelagem-jato"&gt;
    &lt;title&gt;Vistas laterais, superior e frontal do avião a jato&lt;/title&gt;
    &lt;mediaobject&gt;
      &lt;imageobject&gt;
        &lt;imagedata fileref="figs/modelagem-jato.jpg" format="JPG"/&gt;
      &lt;/imageobject&gt;
    &lt;/mediaobject&gt;
  &lt;/figure&gt;
   Neste exemplo, o olhar do observador é fixo aproximadamente no centro do avião, de modo que apenas a posição do observador é alterada para o usuário poder visualizar diversas tomadas da cena.
   O programa usado para modelar o avião é mostrado no &lt;xref linkend="example-modelagem-solidos"/&gt;. As teclas &lt;keycap&gt;LEFT&lt;/keycap&gt; e &lt;keycap&gt;RIGHT&lt;/keycap&gt; servem para rotacionar a posição do observador em torno do eixo y contra e a favor do sentido dos ponteiros do relógio, respectivamente. A distância entre o observador e o centro de rotação (raio de observação) é alterado pelas teclas &lt;keycap&gt;r&lt;/keycap&gt; e &lt;keycap&gt;R&lt;/keycap&gt;, que aumentam o diminuem o seu valor, respectivamente. As teclas &lt;keycap&gt;UP&lt;/keycap&gt; e &lt;keycap&gt;DOWN&lt;/keycap&gt;, controlam a altitude do observador (no eixo y). A tecla &lt;keycap&gt;t&lt;/keycap&gt; habilita ou desabilita o uso de texturas. Para finalizar o programa, basta digitar &lt;keycap&gt;ESC&lt;/keycap&gt;. As teclas e suas respectivas ações estão definidas nas funções `keyboard()` e `special()`.
  &lt;example xml:id="example-modelagem-solidos"&gt;
    &lt;title&gt;programa link:exemplos/jato.c"&gt;&lt;filename&gt;jato.c&lt;/filename&gt;&lt;/link&gt;&lt;/title&gt;
    &lt;programlisting&gt;
      &lt;textobject&gt; &lt;textdata fileref="&amp;caminho;/exemplos/jato.c" format="linespecific"/&gt;&lt;/textobject&gt;
    &lt;/programlisting&gt;
  &lt;/example&gt;</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>    Para compilar e executar o programa link:exemplos/jato.c"&gt;&lt;filename&gt;jato.c&lt;/filename&gt;&lt;/link&gt;, salve-o juntamente com os arquivo link:exemplos/Makefile.modelagem"&gt;Makefile.modelagem&lt;/link&gt;, link:exemplos/image.c"&gt;image.c&lt;/link&gt;, link:exemplos/image.h"&gt;image.h&lt;/link&gt;, link:exemplos/montanhas.rgb"&gt;montanhas.rgb&lt;/link&gt; e link:exemplos/camuflagem.rgb"&gt;camuflagem.rgb&lt;/link&gt; em um diretório e execute a seguinte seqüência de comandos:
    &lt;screen&gt;
&lt;prompt&gt;$&lt;/prompt&gt; &lt;command&gt;make&lt;/command&gt; &lt;option&gt;-f&lt;/option&gt; &lt;option&gt;Makefile.modelagem&lt;/option&gt; &lt;option&gt;jato&lt;/option&gt;
&lt;prompt&gt;$&lt;/prompt&gt; &lt;command&gt;jato&lt;/command&gt;
&lt;/screen&gt;
    &lt;sect1 xml:id="modelagem-descricao"&gt;
      &lt;title&gt;Descrição do programa &lt;filename&gt;jato.c&lt;/filename&gt;&lt;/title&gt;</pre>
</div></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="font-weight: bold"><span style="color: #000080">#define</span></span> COORD_TEXTURA_PLANO <span style="color: #993399">1.0</span>
<span style="font-weight: bold"><span style="color: #000080">#define</span></span> COORD_TEXTURA_AVIAO <span style="color: #993399">1.0</span>
<span style="font-weight: bold"><span style="color: #000080">#define</span></span> COR_DO_PLANO <span style="color: #993399">0.52</span><span style="color: #990000">,</span><span style="color: #993399">0.52</span><span style="color: #990000">,</span><span style="color: #993399">0.78</span><span style="color: #990000">,</span><span style="color: #993399">1.0</span>
<span style="font-weight: bold"><span style="color: #000080">#define</span></span> COR_DO_AVIAO <span style="color: #993399">0.3</span><span style="color: #990000">,</span><span style="color: #993399">0.52</span><span style="color: #990000">,</span><span style="color: #993399">0.18</span><span style="color: #990000">,</span><span style="color: #993399">1.0</span>
<span style="font-weight: bold"><span style="color: #000080">#define</span></span> TEXTURA_DO_PLANO <span style="color: #FF0000">"montanhas.rgb"</span>
<span style="font-weight: bold"><span style="color: #000080">#define</span></span> TEXTURA_DO_AVIAO <span style="color: #FF0000">"camuflagem.rgb"</span>
<span style="color: #990000">----</span>      Define as cores e coordenadas das texturas <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> plano e <span style="color: #008080">do</span> avião<span style="color: #990000">,</span> além dos nomes dos arquivos que contém as imagens <span style="color: #008080">das</span> texturas<span style="color: #990000">.</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="paragraph"><p>GLint WIDTH =320;
GLint HEIGHT=240;
----      Especifica a largura (<em>WIDTH</em>) e a altura (<em>HEIGHT</em>) iniciais da janela de desenho.</p></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="color: #008080">GLfloat</span> obs<span style="color: #990000">[</span><span style="color: #993399">3</span><span style="color: #990000">]=</span><span style="color: #FF0000">{</span><span style="color: #993399">0.0</span><span style="color: #990000">,</span><span style="color: #993399">7.0</span><span style="color: #990000">,</span><span style="color: #993399">0.0</span><span style="color: #FF0000">}</span><span style="color: #990000">;</span>
<span style="color: #008080">GLfloat</span> look<span style="color: #990000">[</span><span style="color: #993399">3</span><span style="color: #990000">]=</span><span style="color: #FF0000">{</span><span style="color: #993399">0.0</span><span style="color: #990000">,</span><span style="color: #993399">3.0</span><span style="color: #990000">,</span><span style="color: #993399">0.0</span><span style="color: #FF0000">}</span><span style="color: #990000">;</span>
<span style="color: #990000">----</span>      As coordenadas da posição <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> observador é armazenada <span style="color: #008080">no</span> vetor <span style="color: #990000">&lt;</span>varname<span style="color: #990000">&gt;</span>obs<span style="color: #990000">[]&lt;/</span>varname<span style="color: #990000">&gt;</span> e as <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> ponto para onde o observador olha é armazenado <span style="color: #008080">no</span> vetor <span style="color: #990000">&lt;</span>varname<span style="color: #990000">&gt;</span>look<span style="color: #990000">[]&lt;/</span>varname<span style="color: #990000">&gt;.</span> De acordo com <span style="color: #008080">estes</span> vetores<span style="color: #990000">,</span> o <span style="color: #008080">observador</span> encontra<span style="color: #990000">-</span>se <span style="color: #008080">no</span> <span style="font-weight: bold"><span style="color: #000000">ponto</span></span> <span style="color: #990000">(</span>x<span style="color: #990000">,</span>y<span style="color: #990000">,</span>z<span style="color: #990000">)=(</span><span style="color: #993399">0</span><span style="color: #990000">,</span><span style="color: #993399">7</span><span style="color: #990000">,</span><span style="color: #993399">0</span><span style="color: #990000">)</span> e está olhando para <span style="color: #008080">o</span> <span style="font-weight: bold"><span style="color: #000000">ponto</span></span> <span style="color: #990000">(</span>x<span style="color: #990000">,</span>y<span style="color: #990000">,</span>z<span style="color: #990000">)=(</span><span style="color: #993399">0</span><span style="color: #990000">,</span><span style="color: #993399">3</span><span style="color: #990000">,</span><span style="color: #993399">0</span><span style="color: #990000">).</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="paragraph"><p>GLuint  textura_plano;
GLuint  textura_aviao;
----      As variáveis &lt;varname&gt;textura_plano&lt;/varname&gt; e &lt;varname&gt;textura_aviao&lt;/varname&gt; armazenam os identificadores das texturas do plano e do avião.</p></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="color: #008080">GLshort</span> texturas<span style="color: #990000">=</span><span style="color: #993399">1</span><span style="color: #990000">;</span>
<span style="color: #008080">GLfloat</span> tetaxz<span style="color: #990000">=</span><span style="color: #993399">0</span><span style="color: #990000">;</span>
<span style="color: #008080">GLfloat</span> raioxz<span style="color: #990000">=</span><span style="color: #993399">6</span><span style="color: #990000">;</span>
<span style="color: #008080">GLuint</span>  jato<span style="color: #990000">;</span>
<span style="color: #990000">----</span>      <span style="color: #008080">A</span> variável <span style="color: #990000">&lt;</span>varname<span style="color: #990000">&gt;</span><span style="color: #008080">texturas&lt;/varname&gt; é usada para habilitar/desabilitar o uso de texturas nos objetos. As variáveis &lt;varname&gt;tetaxz&lt;/varname&gt;</span> e <span style="color: #990000">&lt;</span>varname<span style="color: #990000">&gt;</span>raioxz<span style="color: #990000">&lt;/</span>varname<span style="color: #990000">&gt;</span> armazenam o ângulo de rotação <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> ponto de observação e a distância entre o observador e <span style="color: #008080">a</span> origem<span style="color: #990000">,</span> respectivamente<span style="color: #990000">.</span> <span style="color: #008080">A</span> variável <span style="color: #990000">&lt;</span>varname<span style="color: #990000">&gt;</span>jato<span style="color: #990000">&lt;/</span>varname<span style="color: #990000">&gt;</span> amazena o identificador para a lista de apresentação <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> avião <span style="color: #008080">a</span> jato<span style="color: #990000">.</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="paragraph"><p>GLfloat ctp[4][2]={
  {-COORD_TEXTURA_PLANO,-COORD_TEXTURA_PLANO},
  {+COORD_TEXTURA_PLANO,-COORD_TEXTURA_PLANO},
  {+COORD_TEXTURA_PLANO,+COORD_TEXTURA_PLANO},
  {-COORD_TEXTURA_PLANO,+COORD_TEXTURA_PLANO}
};</p></div>
<div class="paragraph"><p>GLfloat cta[4][2]={
  {-COORD_TEXTURA_AVIAO,-COORD_TEXTURA_AVIAO},
  {+COORD_TEXTURA_AVIAO,-COORD_TEXTURA_AVIAO},
  {+COORD_TEXTURA_AVIAO,+COORD_TEXTURA_AVIAO},
  {-COORD_TEXTURA_AVIAO,+COORD_TEXTURA_AVIAO}
};
----      Quando uma textura é carregada, o OpenGL guarda em uma matriz e assume coordenadas (0,0), (1,0), (1,1) e (0,1) para os quatro cantos da textura. Neste exemplo, é assumido a repetição das texturas, de modo a poder cobrir todo o objeto. As coordenadas especificadas neste trecho de código indicam que o objeto será carimbado com sua respectiva textura e que as coordenadas das texturas que serão usadas para criar os carimbos do plano e do avião serão &lt;varname&gt;ctp[]&lt;/varname&gt; e &lt;varname&gt;cta[]&lt;/varname&gt;, respectivamente.</p></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>  <span style="color: #008080">GLUquadricObj</span> <span style="color: #990000">*</span>quadric<span style="color: #990000">;</span>
<span style="color: #990000">----</span>      Quádricas são superfícies definidas pela seguinte <span style="color: #008080">equação</span> a<span style="color: #990000">&lt;</span>subscript<span style="color: #990000">&gt;</span><span style="color: #993399">1</span><span style="color: #990000">&lt;/</span>subscript<span style="color: #990000">&gt;</span>x<span style="color: #990000">&lt;</span>superscript<span style="color: #990000">&gt;</span><span style="color: #993399">2</span><span style="color: #990000">&lt;/</span>superscript<span style="color: #990000">&gt;</span> <span style="color: #990000">+</span> a<span style="color: #990000">&lt;</span>subscript<span style="color: #990000">&gt;</span><span style="color: #993399">2</span><span style="color: #990000">&lt;/</span>subscript<span style="color: #990000">&gt;</span>y<span style="color: #990000">&lt;</span>superscript<span style="color: #990000">&gt;</span><span style="color: #993399">2</span><span style="color: #990000">&lt;/</span>superscript<span style="color: #990000">&gt;</span> <span style="color: #990000">+</span>a<span style="color: #990000">&lt;</span>subscript<span style="color: #990000">&gt;</span><span style="color: #993399">3</span><span style="color: #990000">&lt;/</span>subscript<span style="color: #990000">&gt;</span>z<span style="color: #990000">&lt;</span>superscript<span style="color: #990000">&gt;</span><span style="color: #993399">2</span><span style="color: #990000">&lt;/</span>superscript<span style="color: #990000">&gt;</span> <span style="color: #990000">+</span> a<span style="color: #990000">&lt;</span>subscript<span style="color: #990000">&gt;</span><span style="color: #993399">4</span><span style="color: #990000">&lt;/</span>subscript<span style="color: #990000">&gt;</span>xy <span style="color: #990000">+</span> a<span style="color: #990000">&lt;</span>subscript<span style="color: #990000">&gt;</span><span style="color: #993399">5</span><span style="color: #990000">&lt;/</span>subscript<span style="color: #990000">&gt;</span>yz <span style="color: #990000">+</span> a<span style="color: #990000">&lt;</span>subscript<span style="color: #990000">&gt;</span><span style="color: #993399">6</span><span style="color: #990000">&lt;/</span>subscript<span style="color: #990000">&gt;</span>xz <span style="color: #990000">+</span> a<span style="color: #990000">&lt;</span>subscript<span style="color: #990000">&gt;</span><span style="color: #993399">7</span><span style="color: #990000">&lt;/</span>subscript<span style="color: #990000">&gt;</span>x <span style="color: #990000">+</span> a<span style="color: #990000">&lt;</span>subscript<span style="color: #990000">&gt;</span><span style="color: #993399">8</span><span style="color: #990000">&lt;/</span>subscript<span style="color: #990000">&gt;</span>y <span style="color: #990000">+</span>a<span style="color: #990000">&lt;</span>subscript<span style="color: #990000">&gt;</span><span style="color: #993399">9</span><span style="color: #990000">&lt;/</span>subscript<span style="color: #990000">&gt;</span>z <span style="color: #990000">+</span>  a<span style="color: #990000">&lt;</span>subscript<span style="color: #990000">&gt;</span><span style="color: #993399">10</span><span style="color: #990000">&lt;/</span>subscript<span style="color: #990000">&gt;.</span> Os tipos de quádricas mais conhecidos são <span style="color: #008080">os</span> cones<span style="color: #990000">,</span> <span style="color: #008080">os</span> cilindros<span style="color: #990000">,</span> as esferas e <span style="color: #008080">os</span> discos<span style="color: #990000">,</span> modelados pelo ajuste adequado dos <span style="color: #008080">parâmetros</span> a<span style="color: #990000">&lt;</span>subscript<span style="color: #990000">&gt;</span>i<span style="color: #990000">&lt;/</span>subscript<span style="color: #990000">&gt;.</span> Estes objetos são guardados em uma estrutura de dados <span style="color: #008080">do</span> tipo <span style="color: #990000">&lt;</span>type<span style="color: #990000">&gt;</span>GLUquadricObj<span style="color: #990000">&lt;/</span>type<span style="color: #990000">&gt;.</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>GLfloat asa[][3]={
  {-4.0,0.0,0.0},
  {+4.0,0.0,0.0},
  {0.0,0.0,3.0}
};</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>  GLfloat cauda[][3]={
    {0.0,0.0,0.0},
    {0.0,2.0,-1.0},
    {0.0,2.0,0.0},
    {0.0,0.0,2.0}
  };
----      As variáveis &lt;varname&gt;asa[][]&lt;/varname&gt; e &lt;varname&gt;cauda[][]&lt;/varname&gt; armazenam as coordenadas dos polígonos que compõem a asa e a cauda do avião, respectivamente.</pre>
</div></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>  jato <span style="color: #990000">=</span> <span style="font-weight: bold"><span style="color: #000000">glGenLists</span></span><span style="color: #990000">(</span><span style="color: #993399">1</span><span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glNewList</span></span><span style="color: #990000">(</span>jato<span style="color: #990000">,</span> GL_COMPILE<span style="color: #990000">);</span>
<span style="color: #990000">----</span>      <span style="color: #008080">A</span> função `<span style="font-weight: bold"><span style="color: #000000">glGenLists</span></span><span style="color: #990000">()</span>` aloca um conjunto contínuo de listas de apresentação vazias e retorna o identificador utilizado para a <span style="color: #008080">lista</span> alocada<span style="color: #990000">.</span> <span style="color: #008080">Neste</span> exemplo<span style="color: #990000">,</span> o conjunto contém apenas uma lista <span style="color: #008080">de</span> apresentação<span style="color: #990000">.</span> Mais listas poderão ser alocadas com subseqüentes chamadas à <span style="color: #008080">mesma</span> função<span style="color: #990000">.</span>
      <span style="color: #008080">A</span> função `<span style="font-weight: bold"><span style="color: #000000">glNewList</span></span><span style="color: #990000">()</span>` especifica o início de uma lista <span style="color: #008080">de</span> apresentação<span style="color: #990000">.</span> Todos os comandos executados até a <span style="color: #008080">chamada</span> de `<span style="font-weight: bold"><span style="color: #000000">glEndList</span></span><span style="color: #990000">()</span>` ficarão armazenados <span style="color: #008080">nesta</span> lista<span style="color: #990000">.</span> <span style="color: #008080">A</span> função `<span style="font-weight: bold"><span style="color: #000000">glNewList</span></span><span style="color: #990000">()</span>` possui o <span style="color: #008080">seguinte</span> protótipo<span style="color: #990000">:</span>
      <span style="color: #990000">&lt;</span>funcsynopsis<span style="color: #990000">&gt;</span>
        <span style="color: #990000">&lt;</span>funcprototype<span style="color: #990000">&gt;</span>
          <span style="color: #990000">&lt;</span>funcdef<span style="color: #990000">&gt;</span><span style="color: #009900">void</span> `glNewList`<span style="color: #990000">&lt;/</span>funcdef<span style="color: #990000">&gt;</span>
          <span style="color: #990000">&lt;</span>paramdef<span style="color: #990000">&gt;</span>GLUint <span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;</span>list`<span style="color: #990000">&lt;/</span>paramdef<span style="color: #990000">&gt;</span>
          <span style="color: #990000">&lt;</span>paramdef<span style="color: #990000">&gt;</span>GLenum <span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;</span>mode`<span style="color: #990000">&lt;/</span>paramdef<span style="color: #990000">&gt;</span>
        <span style="color: #990000">&lt;/</span>funcprototype<span style="color: #990000">&gt;</span>
      <span style="color: #990000">&lt;/</span>funcsynopsis<span style="color: #990000">&gt;</span>
      <span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;</span>list` é um número inteiro maior que zero que identifica de forma única a lista <span style="color: #008080">de</span> apresentação<span style="color: #990000">.</span> <span style="color: #008080">O</span> parâmetro `mode` pode assumir <span style="color: #008080">os</span> valores <span style="color: #990000">&lt;</span><span style="color: #008080">parameter</span> class<span style="color: #990000">=</span><span style="color: #FF0000">"option"</span><span style="color: #990000">&gt;</span>GL_COMPILE` e <span style="color: #990000">&lt;</span><span style="color: #008080">parameter</span> class<span style="color: #990000">=</span><span style="color: #FF0000">"option"</span><span style="color: #990000">&gt;</span>GL_COMPILE_AND_EXECUTE`<span style="color: #990000">.</span> O primeiro apenas armazena os comandos <span style="color: #008080">na</span> lista<span style="color: #990000">;</span> o segundo executa os comandos enquanto são armazenados <span style="color: #008080">na</span> lista<span style="color: #990000">.</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>  quadric = gluNewQuadric();
  gluQuadricTexture(quadric, GL_TRUE);
  gluCylinder(quadric, 0.5, 0.5, 4, 12, 3);
----      Inicia, usando a função `gluNewQuadric()`, a primeira das quádricas do exemplo: o corpo do avião. Para esta quádrica, o mapeamento de textura está habilitado. A função `gluCylinder()` possui o seguinte protótipo:
      &lt;funcsynopsis&gt;
        &lt;funcprototype&gt;
          &lt;funcdef&gt;void `gluCylinder`&lt;/funcdef&gt;
          &lt;paramdef&gt;GLUquadric* &lt;parameter&gt;quad`&lt;/paramdef&gt;
          &lt;paramdef&gt;GLdouble &lt;parameter&gt; base`&lt;/paramdef&gt;
          &lt;paramdef&gt;GLdouble &lt;parameter&gt;top`&lt;/paramdef&gt;
          &lt;paramdef&gt;GLdouble &lt;parameter&gt;height`&lt;/paramdef&gt;
          &lt;paramdef&gt;GLint &lt;parameter&gt;slices`&lt;/paramdef&gt;
          &lt;paramdef&gt;GLint &lt;parameter&gt;stacks`&lt;/paramdef&gt;
        &lt;/funcprototype&gt;
      &lt;/funcsynopsis&gt;
      O parâmetro &lt;parameter&gt;quad` é o objeto de quádrica; &lt;parameter&gt;base`, &lt;parameter&gt;top` e &lt;parameter&gt;height` especificam o raio da base, o raio do topo e a altura do cilindro, respectivamente; &lt;parameter&gt;slices` &lt;parameter&gt;stacks` especificam o número de subdivisões ao redor do eixo z e ao longo do mesmo.</pre>
</div></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>  obs<span style="color: #990000">[</span><span style="color: #993399">0</span><span style="color: #990000">]=</span>raioxz<span style="color: #990000">*</span><span style="font-weight: bold"><span style="color: #000000">cos</span></span><span style="color: #990000">(</span><span style="color: #993399">2</span><span style="color: #990000">*</span>PI<span style="color: #990000">*</span>tetaxz<span style="color: #990000">/</span><span style="color: #993399">360</span><span style="color: #990000">);</span>
  obs<span style="color: #990000">[</span><span style="color: #993399">2</span><span style="color: #990000">]=</span>raioxz<span style="color: #990000">*</span><span style="font-weight: bold"><span style="color: #000000">sin</span></span><span style="color: #990000">(</span><span style="color: #993399">2</span><span style="color: #990000">*</span>PI<span style="color: #990000">*</span>tetaxz<span style="color: #990000">/</span><span style="color: #993399">360</span><span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">gluLookAt</span></span><span style="color: #990000">(</span>obs<span style="color: #990000">[</span><span style="color: #993399">0</span><span style="color: #990000">],</span>obs<span style="color: #990000">[</span><span style="color: #993399">1</span><span style="color: #990000">],</span>obs<span style="color: #990000">[</span><span style="color: #993399">2</span><span style="color: #990000">],</span>look<span style="color: #990000">[</span><span style="color: #993399">0</span><span style="color: #990000">],</span>look<span style="color: #990000">[</span><span style="color: #993399">1</span><span style="color: #990000">],</span>look<span style="color: #990000">[</span><span style="color: #993399">2</span><span style="color: #990000">],</span><span style="color: #993399">0.0</span><span style="color: #990000">,</span><span style="color: #993399">1.0</span><span style="color: #990000">,</span><span style="color: #993399">0.0</span><span style="color: #990000">);</span>
<span style="color: #990000">----</span>      <span style="color: #008080">Na</span> função `<span style="font-weight: bold"><span style="color: #000000">display</span></span><span style="color: #990000">()</span>` as coordenadas x e z da posição <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> observador são calculadas e <span style="color: #008080">a</span> função `<span style="font-weight: bold"><span style="color: #000000">gluLookAt</span></span><span style="color: #990000">()</span>` é chamada para mudar a posição <span style="color: #008080">do</span> observador<span style="color: #990000">.</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>  if(texturas){
    glEnable(GL_TEXTURE_2D);
  }
  else{
    glDisable(GL_TEXTURE_2D);
  }
----      Aqui o mapeamento de texturas é habilitado ou desabilitado, de acordo com o estado da variável &lt;varname&gt;texturas&lt;/varname&gt;. Quando o mapeamento de texturas é desabilitado, o objeto é desenhado utilizando as cores especificadas pela função `glColor*()`.</pre>
</div></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>  <span style="font-weight: bold"><span style="color: #000000">glTexEnvf</span></span><span style="color: #990000">(</span>GL_TEXTURE_ENV<span style="color: #990000">,</span>GL_TEXTURE_ENV_MODE<span style="color: #990000">,</span>GL_DECAL<span style="color: #990000">);</span>
<span style="color: #990000">----</span>      <span style="color: #008080">A</span> função `<span style="font-weight: bold"><span style="color: #000000">glTexEnvf</span></span><span style="color: #990000">()</span>` define os parâmetros <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> ambiente <span style="color: #008080">de</span> textura<span style="color: #990000">.</span> O primeiro parâmetro é sempre <span style="color: #990000">&lt;</span><span style="color: #008080">parameter</span> class<span style="color: #990000">=</span><span style="color: #FF0000">"option"</span><span style="color: #990000">&gt;</span>GL_TEXTURE_ENV`<span style="color: #990000">;</span> o segundo parâmetro é sempre <span style="color: #990000">&lt;</span><span style="color: #008080">parameter</span> class<span style="color: #990000">=</span><span style="color: #FF0000">"option"</span><span style="color: #990000">&gt;</span>GL_TEXTURE_ENV_MODE` e o terceiro especifica como a textura será combinada com a cor para formar a superfície <span style="color: #008080">do</span> objeto<span style="color: #990000">,</span> neste caso substituindo completamente a cor <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> objeto pela <span style="color: #008080">textura</span> corrente<span style="color: #990000">.</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>glBindTexture(GL_TEXTURE_2D,textura_plano);</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>  glBegin(GL_QUADS);
  glTexCoord2fv(ctp[0]);  glVertex3f(-10,0,10);
  glTexCoord2fv(ctp[1]);  glVertex3f(10,0,10);
  glTexCoord2fv(ctp[2]);  glVertex3f(10,0,-10);
  glTexCoord2fv(ctp[3]);  glVertex3f(-10,0,-10);
  glEnd();
----      `glBindTexture()` carrega a textura bidimensional associada com a variável &lt;varname&gt;textura_plano&lt;/varname&gt;. Em seguida, um plano é desenhado usando &lt;parameter class="option"&gt;GL_QUADS`. Observe que, antes de desenhar cada vértice, a função `glTexCoord2fv()` é chamada para definir as coordenadas de textura correntes.</pre>
</div></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="color: #009900">void</span> <span style="font-weight: bold"><span style="color: #000000">carregar_texturas</span></span><span style="color: #990000">(</span><span style="color: #009900">void</span><span style="color: #990000">)</span><span style="color: #FF0000">{</span>
  <span style="color: #008080">IMAGE</span> <span style="color: #990000">*</span>img<span style="color: #990000">;</span>
  <span style="color: #008080">GLenum</span> gluerr<span style="color: #990000">;</span>

  <span style="font-style: italic"><span style="color: #9A1900">/* textura do plano */</span></span>
  <span style="font-weight: bold"><span style="color: #000000">glGenTextures</span></span><span style="color: #990000">(</span><span style="color: #993399">1</span><span style="color: #990000">,</span> <span style="color: #990000">&amp;</span>textura_plano<span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glBindTexture</span></span><span style="color: #990000">(</span>GL_TEXTURE_2D<span style="color: #990000">,</span> textura_plano<span style="color: #990000">);</span>

  <span style="font-weight: bold"><span style="color: #0000FF">if</span></span><span style="color: #990000">(!(</span>img<span style="color: #990000">=</span><span style="font-weight: bold"><span style="color: #000000">ImageLoad</span></span><span style="color: #990000">(</span>TEXTURA_DO_PLANO<span style="color: #990000">)))</span> <span style="color: #FF0000">{</span>
    <span style="font-weight: bold"><span style="color: #000000">fprintf</span></span><span style="color: #990000">(</span>stderr<span style="color: #990000">,</span><span style="color: #FF0000">"Error reading a texture.</span><span style="color: #CC33CC">\n</span><span style="color: #FF0000">"</span><span style="color: #990000">);</span>
    <span style="font-weight: bold"><span style="color: #000000">exit</span></span><span style="color: #990000">(-</span><span style="color: #993399">1</span><span style="color: #990000">);</span>
  <span style="color: #FF0000">}</span>
<span style="color: #990000">----</span>      A carga das texturas é feita com uso <span style="color: #008080">da</span> função `<span style="font-weight: bold"><span style="color: #000000">ImageLoad</span></span><span style="color: #990000">()</span>`<span style="color: #990000">,</span> implementada <span style="color: #008080">em</span> link<span style="color: #990000">:</span>exemplos<span style="color: #990000">/</span>image<span style="color: #990000">.</span>c<span style="color: #FF0000">"&gt;&lt;filename&gt;image.c&lt;/filename&gt;&lt;/link&gt; e definida em link:exemplos/image.h"</span><span style="color: #990000">&gt;&lt;</span>filename<span style="color: #990000">&gt;</span>image<span style="color: #990000">.</span>h<span style="color: #990000">&lt;/</span>filename<span style="color: #990000">&gt;&lt;/</span>link<span style="color: #990000">&gt;.</span> Esta função recebe como parâmetro o nome <span style="font-weight: bold"><span style="color: #0000FF">do</span></span> arquivo com a imagem da textura e retorna um ponteiro para uma estrutura de dados <span style="color: #008080">do</span> tipo <span style="color: #990000">&lt;</span>type<span style="color: #990000">&gt;</span>IMAGE<span style="color: #990000">&lt;/</span>type<span style="color: #990000">&gt;.</span>
      <span style="color: #008080">A</span> função `<span style="font-weight: bold"><span style="color: #000000">glGenTextures</span></span><span style="color: #990000">()</span>` gera <span style="color: #993399">1</span> nome de <span style="color: #008080">textura</span> em <span style="color: #990000">&lt;</span>varname<span style="color: #990000">&gt;</span>textura_plano<span style="color: #990000">&lt;/</span>varname<span style="color: #990000">&gt;.</span> Um nome de textura é qualquer inteiro diferente de zero que identifique de forma única <span style="color: #008080">a</span> textura<span style="color: #990000">.</span> Assim<span style="color: #990000">,</span> texturas diferentes possuem <span style="color: #008080">nomes</span> diferentes<span style="color: #990000">.</span> Caso o segundo parâmetro desta função seja um vetor <span style="color: #008080">de</span> elementos <span style="color: #990000">&lt;</span>type<span style="color: #990000">&gt;</span>GLuint<span style="color: #990000">&lt;/</span>type<span style="color: #990000">&gt;,</span> mais nomes de textura podem <span style="color: #008080">ser</span> gerados<span style="color: #990000">,</span> um para cada elemento <span style="color: #008080">deste</span> vetor<span style="color: #990000">.</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>  gluerr=gluBuild2DMipmaps(GL_TEXTURE_2D, 3,
                           img-&gt;sizeX, img-&gt;sizeY,
                           GL_RGB, GL_UNSIGNED_BYTE,
                           (GLvoid *)(img-&gt;data));
----      Mipmaps são séries de versões em baixa resolução de um mapa de textura. Geralmente é utilizado para texturizar um objeto cuja resolução na tela difere da resolução no mapa de textura. Por exemplo, um objeto próximo da tela pode ser desenhado utilizando uma resolução de textura maior que um objeto distante da tela. O uso de mipmaps evita o efeito de serrilhamento ('aliasing') e outros distúrbios de exibição quando um objeto é aproximado ou afastado da tela.
      Mipmaps bidimensionais são construídos com a função `gluBuild2dMipmaps()`, que possuiu seguinte protótipo:
      &lt;funcsynopsis&gt;
        &lt;funcprototype&gt;
          &lt;funcdef&gt;void `gluBuild2dMipmaps`&lt;/funcdef&gt;
          &lt;paramdef&gt;GLenum &lt;parameter&gt;target`&lt;/paramdef&gt;
          &lt;paramdef&gt;GLint &lt;parameter&gt;internalFormat`&lt;/paramdef&gt;
          &lt;paramdef&gt;GLsizei &lt;parameter&gt;width`&lt;/paramdef&gt;
          &lt;paramdef&gt;GLsizei &lt;parameter&gt;height`&lt;/paramdef&gt;
          &lt;paramdef&gt;GLenum &lt;parameter&gt;format`&lt;/paramdef&gt;
          &lt;paramdef&gt;GLenum &lt;parameter&gt;type`&lt;/paramdef&gt;
          &lt;paramdef&gt;const void &lt;parameter&gt;*data`&lt;/paramdef&gt;
        &lt;/funcprototype&gt;
      &lt;/funcsynopsis&gt;
      &lt;parameter&gt;target` indica o tipo de mipmaps que se deseja construir - neste caso uma textura bidimensional. &lt;parameter&gt;internalFormat` indica o tipo de armazenagem interna do arquivo de textura. Neste exemplo, as texturas são imagens RGB, incluindo 3 (três) componentes de cor. Os parâmetros &lt;parameter&gt;width` e &lt;parameter&gt;height` especificam a largura e a altura do dado. Ambas estas dimensões devem ser potências de 2. &lt;parameter&gt;format` especifica o formato dos pixels do dado (RGB). &lt;parameter&gt;type` especifica o tipo de dado representado no vetor de dados. &lt;parameter&gt;data` especifica o ponteiro para a posição de memória onde os dados de textura residem.</pre>
</div></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>  <span style="font-weight: bold"><span style="color: #000000">glTexParameterf</span></span><span style="color: #990000">(</span>GL_TEXTURE_2D<span style="color: #990000">,</span>GL_TEXTURE_WRAP_S<span style="color: #990000">,</span>GL_REPEAT<span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glTexParameterf</span></span><span style="color: #990000">(</span>GL_TEXTURE_2D<span style="color: #990000">,</span>GL_TEXTURE_WRAP_T<span style="color: #990000">,</span>GL_REPEAT<span style="color: #990000">);</span>
<span style="color: #990000">----</span>      <span style="color: #008080">A</span> função `<span style="font-weight: bold"><span style="color: #000000">glTexParameterf</span></span><span style="color: #990000">()</span>` define uma série de parâmetros que controlam como uma textura é tratada e aplicada a um fragmento de um <span style="color: #008080">dado</span> objeto<span style="color: #990000">.</span> Aqui<span style="color: #990000">,</span> através <span style="color: #008080">dos</span> parâmetros <span style="color: #990000">&lt;</span><span style="color: #008080">parameter</span> class<span style="color: #990000">=</span><span style="color: #FF0000">"option"</span><span style="color: #990000">&gt;</span>GL_TEXTURE_WRAP_S` e <span style="color: #990000">&lt;</span><span style="color: #008080">parameter</span> class<span style="color: #990000">=</span><span style="color: #FF0000">"option"</span><span style="color: #990000">&gt;</span>GL_TEXTURE_WRAP_T`<span style="color: #990000">,</span> a função define que nas direções s <span style="color: #008080">e</span> <span style="font-weight: bold"><span style="color: #000000">t</span></span> <span style="color: #990000">(</span>coordenadas<span style="color: #990000">)</span> a textura deverá será repetida <span style="color: #008080">no</span> objeto<span style="color: #990000">.</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>  glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR);
  glTexParameterf(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
----      Neste trecho do código, as funções `glTexParameterf()` define os tipos de filtro usados quando a textura for minimizada ou maximizada. Pelo parâmetro &lt;parameter&gt;GL_LINEAR_MIPMAP_LINEAR`, o OpenGL escolhe dois mipmaps que mais aproximam o tamanho do pixel a ser texturizado calcula a média dos quatro elementos de textura mais próximos do centro do pixel. O valor da textura para o pixel será a média desses dois valores. O parâmetro &lt;parameter&gt;GL_LINEAR`, por sua vez não utiliza mipmaps: associa ao pixel a ser texturizado a média dos quatro elementos de textura mais próximos do centro do pixel.
    &lt;/sect1&gt;
    &lt;sect1 xml:id="modelagem-exercicios"&gt;
      &lt;title&gt;Exercícios&lt;/title&gt;
      &lt;orderedlist&gt;
        -Utilizando o programa link:exemplos/jato.c"&gt;&lt;filename&gt;jato.c&lt;/filename&gt;&lt;/link&gt; como referência, implemente um programa &lt;filename&gt;superjato.c&lt;/filename&gt;. Caso você ainda não tenha notado, o avião a jato deste exemplo não possui uma turbina. Faça-o mais feliz, projetando essa turbina e acoplando-a à parte traseira do jato no seu novo programa. O modelo da turbina fica a seu gosto. Acrescente também dois mísseis sob as asas.</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>  -Crie um logotipo utilizando um programa de manipulação de imagens de sua preferência. Salve-o no formato Iris RGB e mapeie-o na parte superior da asa, como mostra a &lt;xref linkend="fig-modelagem-logotipo"/&gt;
    &lt;figure xml:id="fig-modelagem-logotipo"&gt;
      &lt;title&gt;Exemplo de logotipo para o superjato&lt;/title&gt;
&lt;mediaobject&gt;
  &lt;imageobject&gt;
    &lt;imagedata fileref="figs/modelagem-logotipo.jpg" format="JPG"/&gt;
  &lt;/imageobject&gt;
&lt;/mediaobject&gt;
    &lt;/figure&gt;</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>&lt;/orderedlist&gt;</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>  &lt;/sect1&gt;
&lt;/chapter&gt;</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>&lt;!-- modelos de iluminação --&gt;</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>  &lt;chapter xml:id="modelos-iluminacao"&gt;
    &lt;title&gt;Modelos de iluminação e sombreamento&lt;/title&gt;
    O propósito desta lição é ilustrar para o usuário os principais conceitos envolvidos na iluminação de uma cena e na definição das propriedades luminosas de um material, geralmente representadas pelos coeficientes de reflexão difusa e especular.
    Será mostrado com definir características básicas de uma fonte de luz, tais como a intensidade da luz gerada, para as componentes de luz ambiente, difusa e especular (no OpenGL, é possível separar as contribuições). Além disso, será mostrado também o uso do canal alfa para geração de transparências e a construção de 'spots' de luz.
    A cena gerada pelo programa utilizado nesta lição é mostrado na &lt;xref linkend="fig-modelos-iluminacao-cena"/&gt;. Consiste de duas esferas (nomeadas A e B) sob um plano. A esfera "A" é sólida, e os valores das suas constantes de reflexão difusa e especular pode ser modificados através de seleção de opções em um menu. A esfera "B" é translúcida, e sua translucidez pode ser ajustada através do canal alfa.
     Até o momento, o canal alfa tem sido ignorado (alfa é o A em RGBA). Os valores do canal alfa variam de 0 a 1, e são especificados com as funções `glColor*()`. Quando os efeitos de composição ('blending') são utilizados, o valor de alfa é utilizado para combinar a cor do fragmento que está sendo processado com a cor já presente no 'framebuffer'. De modo geral, a composição de imagens utilando o canal alfa é dada pela seguinte expressão:
    &lt;screen&gt;
         IT = IP * alfa + (1-alfa)* IFB
&lt;/screen&gt;
    onde: IT é a imagem total resultante, IP é a imagem que está sendo processada, e IFB é a imagem anteriormente presente no 'framebuffer'.</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>&lt;figure xml:id="fig-modelos-iluminacao-cena"&gt;
  &lt;title&gt;Esferas sob um plano.&lt;/title&gt;
  &lt;mediaobject&gt;
    &lt;imageobject&gt;
      &lt;imagedata fileref="figs/modelos-iluminacao-cena.jpg" format="JPG"/&gt;
    &lt;/imageobject&gt;
  &lt;/mediaobject&gt;
&lt;/figure&gt;
 O programa usado para modelar esta cena é mostrado no &lt;xref linkend="example-modelos-iluminacao"/&gt;. As teclas &lt;keycap&gt;LEFT&lt;/keycap&gt; e &lt;keycap&gt;RIGHT&lt;/keycap&gt; servem para rotacionar a posição do observador em torno do eixo y contra e a favor do sentido dos ponteiros do relógio, respectivamente. A distância entre o observador e o centro de rotação (raio de observação) é alterado pelas teclas &lt;keycap&gt;r&lt;/keycap&gt; e &lt;keycap&gt;R&lt;/keycap&gt;, que aumentam o diminuem o seu valor, respectivamente. As teclas &lt;keycap&gt;UP&lt;/keycap&gt; e &lt;keycap&gt;DOWN&lt;/keycap&gt;, controlam a altitude do observador (no eixo y). É possível modificar os graus de reflexão difusa e especular da esfera maciça através do menu 'popup' disponível pelo pressionamento do botão direito do mouse. A tecla &lt;keycap&gt;t&lt;/keycap&gt; habilita ou desabilita o uso de texturas. Para finalizar o programa, basta digitar &lt;keycap&gt;ESC&lt;/keycap&gt;.</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>&lt;example xml:id="example-modelos-iluminacao"&gt;
  &lt;title&gt;programa link:exemplos/iluminacao.c"&gt;&lt;filename&gt;iluminacao.c&lt;/filename&gt;&lt;/link&gt;&lt;/title&gt;
  &lt;programlisting&gt;
    &lt;textobject&gt; &lt;textdata fileref="&amp;caminho;/exemplos/iluminacao.c" format="linespecific"/&gt;&lt;/textobject&gt;
  &lt;/programlisting&gt;
&lt;/example&gt;</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>    Para compilar e executar o programa link:exemplos/iluminacao.c"&gt;&lt;filename&gt;iluminacao.c&lt;/filename&gt;&lt;/link&gt;, salve-o juntamente com o arquivo link:exemplos/Makefile"&gt;Makefile&lt;/link&gt; em um diretório e execute a seguinte seqüência de comandos:
    &lt;screen&gt;
&lt;prompt&gt;$&lt;/prompt&gt; &lt;command&gt;make&lt;/command&gt; &lt;option&gt;iluminacao&lt;/option&gt;
&lt;prompt&gt;$&lt;/prompt&gt; &lt;command&gt;iluminacao&lt;/command&gt;
&lt;/screen&gt;</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>&lt;sect1 xml:id="modelos-iluminacao-descricao"&gt;
  &lt;title&gt;Descrição do programa &lt;filename&gt;iluminacao.c&lt;/filename&gt;&lt;/title&gt;</pre>
</div></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="color: #008080">GLint</span> fatias<span style="color: #990000">=</span><span style="color: #993399">30</span><span style="color: #990000">;</span>
<span style="color: #008080">GLint</span> pilhas<span style="color: #990000">=</span><span style="color: #993399">30</span><span style="color: #990000">;</span>
<span style="color: #008080">GLint</span> raioEsfera<span style="color: #990000">=</span><span style="color: #993399">1.5</span><span style="color: #990000">;</span>
<span style="color: #990000">----</span>      Define o número <span style="color: #008080">de</span> <span style="font-weight: bold"><span style="color: #000000">fatias</span></span> <span style="color: #990000">(</span>longitude<span style="color: #990000">),</span> o número <span style="color: #008080">de</span> <span style="font-weight: bold"><span style="color: #000000">pilhas</span></span> <span style="color: #990000">(</span>latitude<span style="color: #990000">)</span> e o raio das esferas <span style="color: #008080">da</span> cena<span style="color: #990000">.</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="paragraph"><p>GLfloat plano_difusa[]    = { 0.5, 0.5, 0.0, 1.0 };
GLfloat plano_especular[] = { 1.0, 1.0, 1.0, 1.0 };
GLfloat plano_brilho[]    = { 50.0 };</p></div>
<div class="paragraph"><p>GLfloat mat_a_difusa[]    = { 1.0, 1.0, 1.0, 1.0 };
GLfloat mat_a_especular[] = { 1.0, 1.0, 1.0, 1.0 };
GLfloat mat_a_brilho[]    = { 50.0 };</p></div>
<div class="paragraph"><p>GLfloat mat_b_difusa[]    = { 0.7, 0.7, 0.7, 0.5 };
GLfloat mat_b_especular[] = { 1.0, 1.0, 1.0, 0.5 };
GLfloat mat_b_brilho[]    = { 50.0 };
----      Define os coeficientes de reflexão difusa (&lt;varname&gt;*_difusa&lt;/varname&gt;) e especular (&lt;varname&gt;*_especular&lt;/varname&gt;) para os três objetos da cena. As componentes destes vetores são do tipo R,G,B e A(lfa) e serão utilizados para as compor cores do plano, da esfera A e da esfera B. Observe que a esfera B possui valor de alfa igual a 0.5, proporcionando assim a sua aparência translúcida.
      O brilho do material, que pode assumir valores entre 1 e 128, é um expoente que modela a função de distribuição espacial da componente de luz refletida especularmente. À medida em que o valor do brilho aumenta, diminui o espalhamento da luz refletida.</p></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="color: #008080">GLfloat</span> posicao_luz0<span style="color: #990000">[]</span>    <span style="color: #990000">=</span> <span style="color: #FF0000">{</span> <span style="color: #993399">0.0</span><span style="color: #990000">,</span> <span style="color: #993399">10.0</span><span style="color: #990000">,</span> <span style="color: #993399">0.0</span><span style="color: #990000">,</span> <span style="color: #993399">1.0</span><span style="color: #FF0000">}</span><span style="color: #990000">;</span>
<span style="color: #008080">GLfloat</span> cor_luz0<span style="color: #990000">[]</span>        <span style="color: #990000">=</span> <span style="color: #FF0000">{</span> <span style="color: #993399">1.0</span><span style="color: #990000">,</span> <span style="color: #993399">1.0</span><span style="color: #990000">,</span> <span style="color: #993399">1.0</span><span style="color: #990000">,</span> <span style="color: #993399">1.0</span><span style="color: #FF0000">}</span><span style="color: #990000">;</span>
<span style="color: #008080">GLfloat</span> cor_luz0_amb<span style="color: #990000">[]</span>    <span style="color: #990000">=</span> <span style="color: #FF0000">{</span> <span style="color: #993399">0.3</span><span style="color: #990000">,</span> <span style="color: #993399">0.3</span><span style="color: #990000">,</span> <span style="color: #993399">0.3</span><span style="color: #990000">,</span> <span style="color: #993399">1.0</span><span style="color: #FF0000">}</span><span style="color: #990000">;</span>
<span style="color: #990000">----</span>      Indica <span style="color: #008080">a</span> posiçã<span style="font-weight: bold"><span style="color: #000000">o</span></span> <span style="color: #990000">(</span>posicao_luz0<span style="color: #990000">)</span> e as componentes de luz para reflexão difusa <span style="color: #008080">e</span> <span style="font-weight: bold"><span style="color: #000000">especular</span></span> <span style="color: #990000">(&lt;</span>varname<span style="color: #990000">&gt;</span>cor_luz0<span style="color: #990000">&lt;/</span>varname<span style="color: #990000">&gt;),</span> e a componente de luz para <span style="color: #008080">reflexão</span> <span style="font-weight: bold"><span style="color: #000000">ambiente</span></span> <span style="color: #990000">(</span>cor_luz0_amb<span style="color: #990000">).</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="paragraph"><p>GLfloat posicao_luz1[]    = { 0.0, 10.0, 5.0, 1.0};
GLfloat cor_luz1[]        = { 0.0, 0.0, 1.0, 1.0};
GLfloat direcao_luz1[]    = { 0.0, -10.0, -5.0, 1.0};
GLint   spot_luz1         = 30;
----      É apresentado aqui o exemplo de uma luz tipo spot. É necessário que seja definidos, além da cor da luz e da posição do spot, a sua orientação e o seu ângulo de corte, mostrado na &lt;xref linkend="modelos-iluminacao-spot"/&gt;. Para este exemplo, o ângulo de corte é igual a 30 graus.
      &lt;figure xml:id="modelos-iluminacao-spot"&gt;
        &lt;title&gt;Spot de luz&lt;/title&gt;
      &lt;mediaobject&gt;
        &lt;imageobject&gt;
          &lt;imagedata fileref="figs/modelos-iluminacao-spot.jpg" format="JPG"/&gt;
        &lt;/imageobject&gt;
      &lt;/mediaobject&gt;
      &lt;/figure&gt;</p></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>  <span style="font-weight: bold"><span style="color: #0000FF">if</span></span><span style="color: #990000">(</span>gouraud<span style="color: #990000">)</span><span style="color: #FF0000">{</span>
    <span style="font-weight: bold"><span style="color: #000000">glShadeModel</span></span><span style="color: #990000">(</span>GL_SMOOTH<span style="color: #990000">);</span>
  <span style="color: #FF0000">}</span>
  <span style="font-weight: bold"><span style="color: #0000FF">else</span></span><span style="color: #FF0000">{</span>
    <span style="font-weight: bold"><span style="color: #000000">glShadeModel</span></span><span style="color: #990000">(</span>GL_FLAT<span style="color: #990000">);</span>
  <span style="color: #FF0000">}</span>
<span style="color: #990000">----</span>      Através <span style="color: #008080">da</span> variável <span style="color: #990000">&lt;</span>varname<span style="color: #990000">&gt;</span>gouraud<span style="color: #990000">&lt;/</span>varname<span style="color: #990000">&gt;</span> <span style="color: #008080">a</span> função `display` decide se o modelo <span style="color: #008080">de</span> <span style="font-weight: bold"><span style="color: #000000">sombreamento</span></span> <span style="color: #990000">(</span><span style="color: #FF0000">'shading'</span><span style="color: #990000">)</span> para os objetos será o <span style="color: #008080">de</span> <span style="font-weight: bold"><span style="color: #000000">Gouraud</span></span> <span style="color: #990000">(</span>GL_SMOOTH<span style="color: #990000">)</span> ou <span style="color: #FF0000">'flat shading'</span><span style="color: #990000">,</span> tornando os objetos com <span style="color: #008080">aparência</span> faceteada<span style="color: #990000">.</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>/* propriedades do material do plano */
glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, plano_difusa);
glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, plano_especular);
glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, plano_brilho);</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>  /* desenha o plano */
  glNormal3f(0,1,0);
  glBegin(GL_QUADS);
  glVertex3f(-10,0,10);
  glVertex3f(10,0,10);
  glVertex3f(10,0,-10);
  glVertex3f(-10,0,-10);
  glEnd();
----      A função `glMaterialfv()` define as propriedades de reflexão difusa e especular, e brilho do material que será utilizado para compor o objeto imediatamente desenhado, neste caso um plano, via GL_QUADS. Observer a chamada à função `glNormal3f()` antes de o plano ser desenhado. Isto é necessário porque, por 'default', o vetor normal encontra-se na direção (x,y,z)=(0,0,1) e para que a normal à superfície encontra-se orientada com eixo y, ou seja, na direção (x,y,z)=(0,1,0).
      Um procedimento semelhante a esse é utilizado para definir as características do material das esferas presentes na cena.</pre>
</div></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>  <span style="font-weight: bold"><span style="color: #000000">glPushMatrix</span></span><span style="color: #990000">();</span>
  <span style="font-weight: bold"><span style="color: #000000">glTranslatef</span></span><span style="color: #990000">(</span>posicao_luz0<span style="color: #990000">[</span><span style="color: #993399">0</span><span style="color: #990000">],</span>posicao_luz0<span style="color: #990000">[</span><span style="color: #993399">1</span><span style="color: #990000">],</span>posicao_luz0<span style="color: #990000">[</span><span style="color: #993399">2</span><span style="color: #990000">]);</span>
  <span style="font-weight: bold"><span style="color: #000000">glColor3f</span></span><span style="color: #990000">(</span><span style="color: #993399">1</span><span style="color: #990000">,</span><span style="color: #993399">0</span><span style="color: #990000">,</span><span style="color: #993399">0</span><span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glMaterialfv</span></span><span style="color: #990000">(</span>GL_FRONT<span style="color: #990000">,</span> GL_EMISSION<span style="color: #990000">,</span> cor_luz0<span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glutSolidSphere</span></span><span style="color: #990000">(</span><span style="color: #993399">0.3</span><span style="color: #990000">,</span><span style="color: #993399">5</span><span style="color: #990000">,</span><span style="color: #993399">5</span><span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glPopMatrix</span></span><span style="color: #990000">();</span>
<span style="color: #990000">----</span>      Para facilitar a identificação das fontes <span style="color: #008080">de</span> luz<span style="color: #990000">,</span> são desenhadas duas esferas nas posições <span style="color: #008080">destas</span> fontes<span style="color: #990000">.</span> Na chamada à função `<span style="font-weight: bold"><span style="color: #000000">glMaterialfv</span></span><span style="color: #990000">()</span>`<span style="color: #990000">,</span> <span style="color: #008080">o</span> parâmetro <span style="color: #990000">&lt;</span>parameter<span style="color: #990000">&gt;</span>GL_EMISSION` define a intensidade luminosa emitida pelo material como sendo a própria cor da fonte <span style="color: #008080">de</span> luz<span style="color: #990000">,</span> dando a aparência de que a <span style="color: #008080">esfera</span> brilha<span style="color: #990000">,</span> assim como brilharia <span style="color: #008080">uma</span> lâmpada<span style="color: #990000">.</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
----      Habilita a composição ('blending') de imagens dos valores RGBA correntes com aqueles presentes no 'framebuffer'. A função `glBlendFunc()` define os pesos para a imagem que está sendo processada (IP) e a presente no 'framebuffer'. Neste caso, os pesos são o próprio valor do canal alfa (&lt;parameter&gt;GL_SRC_ALPHA`) e 1-alfa (&lt;parameter&gt;GL_ONE_MINUS_SRC_ALPHA`).</pre>
</div></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt>  <span style="font-weight: bold"><span style="color: #000000">glLightfv</span></span><span style="color: #990000">(</span>GL_LIGHT0<span style="color: #990000">,</span> GL_DIFFUSE<span style="color: #990000">,</span> cor_luz0<span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glLightfv</span></span><span style="color: #990000">(</span>GL_LIGHT0<span style="color: #990000">,</span> GL_SPECULAR<span style="color: #990000">,</span> cor_luz0<span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glLightfv</span></span><span style="color: #990000">(</span>GL_LIGHT0<span style="color: #990000">,</span> GL_AMBIENT<span style="color: #990000">,</span> cor_luz0_amb<span style="color: #990000">);</span>
  <span style="font-weight: bold"><span style="color: #000000">glLightfv</span></span><span style="color: #990000">(</span>GL_LIGHT0<span style="color: #990000">,</span> GL_POSITION<span style="color: #990000">,</span> posicao_luz0<span style="color: #990000">);</span>
<span style="color: #990000">----</span>      Define a posição e as componentes de cor da fonte de <span style="color: #008080">luz</span> GL_LIGHT0<span style="color: #990000">.</span>

<span style="color: #990000">[</span>source<span style="color: #990000">,</span>c<span style="color: #990000">]</span></tt></pre></div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>  glLightfv(GL_LIGHT1, GL_DIFFUSE, cor_luz1);
  glLightfv(GL_LIGHT1, GL_SPECULAR, cor_luz1);
  glLightf (GL_LIGHT1, GL_SPOT_CUTOFF, spot_luz1);
  glLightfv(GL_LIGHT1, GL_POSITION, posicao_luz1);
  glLightfv(GL_LIGHT1, GL_SPOT_DIRECTION, direcao_luz1);
----      Define a posição, orientação, ângulo de corte e as componentes de cor para a fonte de luz GL_LIGHT1.</pre>
</div></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="color: #009900">void</span> <span style="font-weight: bold"><span style="color: #000000">menu</span></span><span style="color: #990000">(</span><span style="color: #009900">int</span> value<span style="color: #990000">)</span><span style="color: #FF0000">{</span>
  <span style="font-weight: bold"><span style="color: #0000FF">switch</span></span> <span style="color: #990000">(</span>value<span style="color: #990000">)</span> <span style="color: #FF0000">{</span>
  <span style="font-weight: bold"><span style="color: #0000FF">case</span></span> <span style="color: #993399">0</span><span style="color: #990000">:</span>
    mat_a_especular<span style="color: #990000">[</span><span style="color: #993399">0</span><span style="color: #990000">]=</span>mat_a_especular<span style="color: #990000">[</span><span style="color: #993399">1</span><span style="color: #990000">]=</span>mat_a_especular<span style="color: #990000">[</span><span style="color: #993399">2</span><span style="color: #990000">]=</span><span style="color: #993399">0.0</span><span style="color: #990000">;</span>
    <span style="font-weight: bold"><span style="color: #0000FF">break</span></span><span style="color: #990000">;</span>
  <span style="font-weight: bold"><span style="color: #0000FF">case</span></span> <span style="color: #993399">1</span><span style="color: #990000">:</span>
    mat_a_especular<span style="color: #990000">[</span><span style="color: #993399">0</span><span style="color: #990000">]=</span>mat_a_especular<span style="color: #990000">[</span><span style="color: #993399">1</span><span style="color: #990000">]=</span>mat_a_especular<span style="color: #990000">[</span><span style="color: #993399">2</span><span style="color: #990000">]=</span><span style="color: #993399">0.5</span><span style="color: #990000">;</span>
    <span style="font-weight: bold"><span style="color: #0000FF">break</span></span><span style="color: #990000">;</span>
  <span style="font-weight: bold"><span style="color: #0000FF">case</span></span> <span style="color: #993399">2</span><span style="color: #990000">:</span>
    mat_a_especular<span style="color: #990000">[</span><span style="color: #993399">0</span><span style="color: #990000">]=</span>mat_a_especular<span style="color: #990000">[</span><span style="color: #993399">1</span><span style="color: #990000">]=</span>mat_a_especular<span style="color: #990000">[</span><span style="color: #993399">2</span><span style="color: #990000">]=</span><span style="color: #993399">1.0</span><span style="color: #990000">;</span>
    <span style="font-weight: bold"><span style="color: #0000FF">break</span></span><span style="color: #990000">;</span>
  <span style="font-weight: bold"><span style="color: #0000FF">case</span></span> <span style="color: #993399">3</span><span style="color: #990000">:</span>
    mat_a_difusa<span style="color: #990000">[</span><span style="color: #993399">0</span><span style="color: #990000">]=</span>mat_a_difusa<span style="color: #990000">[</span><span style="color: #993399">1</span><span style="color: #990000">]=</span>mat_a_difusa<span style="color: #990000">[</span><span style="color: #993399">2</span><span style="color: #990000">]=</span><span style="color: #993399">0.0</span><span style="color: #990000">;</span>
    <span style="font-weight: bold"><span style="color: #0000FF">break</span></span><span style="color: #990000">;</span>
  <span style="font-weight: bold"><span style="color: #0000FF">case</span></span> <span style="color: #993399">4</span><span style="color: #990000">:</span>
    mat_a_difusa<span style="color: #990000">[</span><span style="color: #993399">0</span><span style="color: #990000">]=</span>mat_a_difusa<span style="color: #990000">[</span><span style="color: #993399">1</span><span style="color: #990000">]=</span>mat_a_difusa<span style="color: #990000">[</span><span style="color: #993399">2</span><span style="color: #990000">]=</span><span style="color: #993399">0.5</span><span style="color: #990000">;</span>
    <span style="font-weight: bold"><span style="color: #0000FF">break</span></span><span style="color: #990000">;</span>
  <span style="font-weight: bold"><span style="color: #0000FF">case</span></span> <span style="color: #993399">5</span><span style="color: #990000">:</span>
    mat_a_difusa<span style="color: #990000">[</span><span style="color: #993399">0</span><span style="color: #990000">]=</span>mat_a_difusa<span style="color: #990000">[</span><span style="color: #993399">1</span><span style="color: #990000">]=</span>mat_a_difusa<span style="color: #990000">[</span><span style="color: #993399">2</span><span style="color: #990000">]=</span><span style="color: #993399">1.0</span><span style="color: #990000">;</span>
    <span style="font-weight: bold"><span style="color: #0000FF">break</span></span><span style="color: #990000">;</span>
  <span style="color: #FF0000">}</span>
  <span style="font-weight: bold"><span style="color: #000000">glutPostRedisplay</span></span><span style="color: #990000">();</span>
<span style="color: #FF0000">}</span></tt></pre></div></div>
<div class="paragraph"><p>A função menu é ativada quando o botão direito do mouse é pressionado. De acordo com o valor da variável &lt;varname&gt;value&lt;/varname&gt;, determinadas propriedades do material que compõe a esfera A são modificadas.</p></div>
<div class="listingblock">
<div class="content"><!-- Generator: GNU source-highlight
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="font-weight: bold"><span style="color: #000000">glutCreateMenu</span></span><span style="color: #990000">(</span>menu<span style="color: #990000">);</span>
<span style="font-weight: bold"><span style="color: #000000">glutAddMenuEntry</span></span><span style="color: #990000">(</span><span style="color: #FF0000">"-sem spec"</span><span style="color: #990000">,</span> <span style="color: #993399">0</span><span style="color: #990000">);</span>
<span style="font-weight: bold"><span style="color: #000000">glutAddMenuEntry</span></span><span style="color: #990000">(</span><span style="color: #FF0000">"-spec média"</span><span style="color: #990000">,</span> <span style="color: #993399">1</span><span style="color: #990000">);</span>
<span style="font-weight: bold"><span style="color: #000000">glutAddMenuEntry</span></span><span style="color: #990000">(</span><span style="color: #FF0000">"-spec alta"</span><span style="color: #990000">,</span> <span style="color: #993399">2</span><span style="color: #990000">);</span>
<span style="font-weight: bold"><span style="color: #000000">glutAddMenuEntry</span></span><span style="color: #990000">(</span><span style="color: #FF0000">"-sem difusa"</span><span style="color: #990000">,</span> <span style="color: #993399">3</span><span style="color: #990000">);</span>
<span style="font-weight: bold"><span style="color: #000000">glutAddMenuEntry</span></span><span style="color: #990000">(</span><span style="color: #FF0000">"-difusa média"</span><span style="color: #990000">,</span> <span style="color: #993399">4</span><span style="color: #990000">);</span>
<span style="font-weight: bold"><span style="color: #000000">glutAddMenuEntry</span></span><span style="color: #990000">(</span><span style="color: #FF0000">"-difusa alta"</span><span style="color: #990000">,</span> <span style="color: #993399">5</span><span style="color: #990000">);</span>
<span style="font-weight: bold"><span style="color: #000000">glutAttachMenu</span></span><span style="color: #990000">(</span>GLUT_RIGHT_BUTTON<span style="color: #990000">);</span></tt></pre></div></div>
<div class="paragraph"><p>Aqui, a função <span class="monospaced">glutCreateMenu()</span>, em conjunto com a função <span class="monospaced">glutAddMenuEntry()</span>, habilita um menu <em>popup</em> com seis opções que permitirão ativar entradas presentes na função <span class="monospaced">menu</span>, de acordo com os valores passados nos segundos argumentos das funções <span class="monospaced">glutAddMenuEntry()</span>. Finalmente, a função <span class="monospaced">glutAttachMenu()</span> associa o aparecimento deste menu ao pressionamento do botão direito do mouse.
    &lt;/sect1&gt;</p></div>
<div class="literalblock">
<div class="content monospaced">
<pre>&lt;sect1 xml:id="modelos-iluminacao-exercicios"&gt;
  &lt;title&gt;Exercícios&lt;/title&gt;
  &lt;orderedlist&gt;
    -Utilizando o programa link:exemplos/iluminacao.c"&gt;&lt;filename&gt;iluminacao.c&lt;/filename&gt;&lt;/link&gt; como referência, implemente um programa &lt;filename&gt;iluminacao2.c&lt;/filename&gt;. Utilizando este novo programa, possibilite que a transparência do objeto B seja modificada através dos movimentos horizontal ou vertical do mouse quando nenhuma tecla for pressionada. Caso a tecla &lt;keycap&gt;SHIFT&lt;/keycap&gt; esteja pressionada, os movimentos do mouse deverão diminuir ou aumentar os níveis de iluminação ambiente.
  &lt;/orderedlist&gt;
&lt;/sect1&gt;</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>&lt;/chapter&gt;</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>&lt;!-- como submeter exercícios --&gt;</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>&lt;chapter xml:id="submissao-exercicios"&gt;
  &lt;title&gt;Instruções para submissão dos exercícios&lt;/title&gt;
   A submissão dos exercícios será feita diretamente via WWW. Cada aluno deverá criar uma 'homepage' apresentando suas soluções para os exercícios propostos. A URL gerada será incluída na homepage do professor.
   A 'homepage' de apresentação das soluções deverá conter links para os programas criados, bem como as instruções de instalação e compilação destes.
   Os programas dos exercícios serão compilados e testados no Laboratório de graduação em Engenharia da Computação. Assegure-se de que o seu programa funciona no referido laboratório.
   Você poderá encontrar link:submissao.html"&gt;aqui&lt;/link&gt; um modelo de 'homepage' para submissão de exercícios.
  &lt;sect1&gt;
    &lt;title&gt;Exemplo de Homepage&lt;/title&gt;
    &lt;subtitle&gt;Solução para os exercícios propostos&lt;/subtitle&gt;
    Agostinho Brito - 905632</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>      &lt;orderedlist&gt;
        -&lt;emphasis&gt;Desenhando linhas e pontos&lt;/emphasis&gt;
          &lt;orderedlist&gt;
            -    Implementação do programa quadrado.
               Utilize os seguintes arquivos:
              &lt;itemizedlist&gt;
                &lt;listitem&gt;
                  link:Makefile"&gt;Makefile&lt;/link&gt;
                        &lt;listitem&gt;
                  link:quadrado.c"&gt;quadrado.c&lt;/link&gt;
                      &lt;/itemizedlist&gt;
              Como compilar e executar:
              &lt;screen&gt;
&lt;prompt&gt;$&lt;/prompt&gt; &lt;command&gt;make&lt;/command&gt; &lt;option&gt;quadrado&lt;/option&gt;
&lt;prompt&gt;$&lt;/prompt&gt; &lt;command&gt;quadrado&lt;/command&gt;
&lt;/screen&gt;
            &lt;/listitem&gt;
            -    Algoritmo de Bresenham para traçado de retas
               Utilize os seguintes arquivos:
              &lt;itemizedlist&gt;
                &lt;listitem&gt;
                  link:Makefile"&gt;Makefile&lt;/link&gt;
                        &lt;listitem&gt;
                  link:bresenham-retas.c"&gt;bresenham-retas.c&lt;/link&gt;
                      &lt;/itemizedlist&gt;
              Como compilar e executar:
              &lt;screen&gt;
&lt;prompt&gt;$&lt;/prompt&gt; &lt;command&gt;make&lt;/command&gt; &lt;option&gt;bresenham-retas&lt;/option&gt;
&lt;prompt&gt;$&lt;/prompt&gt; &lt;command&gt;bresenham-retas&lt;/command&gt;
&lt;/screen&gt;
            &lt;/listitem&gt;
            -    Algoritmo de Bresenham para traçado de circunferências
               Utilize os seguintes arquivos:
              &lt;itemizedlist&gt;
                &lt;listitem&gt;
                  link:Makefile"&gt;Makefile&lt;/link&gt;
                        &lt;listitem&gt;
                  link:bresenham-circunferencias.c"&gt;bresenham-circunferencias.c&lt;/link&gt;
                      &lt;/itemizedlist&gt;
              Como compilar e executar:
              &lt;screen&gt;
&lt;prompt&gt;$&lt;/prompt&gt; &lt;command&gt;make&lt;/command&gt; &lt;option&gt;bresenham-circunferencias&lt;/option&gt;
&lt;prompt&gt;$&lt;/prompt&gt; &lt;command&gt;bresenham-circunferencias&lt;/command&gt;
&lt;/screen&gt;
            &lt;/listitem&gt;
          &lt;/orderedlist&gt;
        -&lt;emphasis&gt;Preenchimento de regiões&lt;/emphasis&gt;
          &lt;orderedlist&gt;
            -    Seleção de cores
               Utilize os seguintes arquivos:
              &lt;itemizedlist&gt;
                &lt;listitem&gt;
                  link:Makefile"&gt;Makefile&lt;/link&gt;
                        &lt;listitem&gt;
                  link:selecao.c"&gt;selecao.c&lt;/link&gt;
                      &lt;/itemizedlist&gt;
              Como compilar e executar:
              &lt;screen&gt;
&lt;prompt&gt;$&lt;/prompt&gt; &lt;command&gt;make&lt;/command&gt; &lt;option&gt;selecao&lt;/option&gt;
&lt;prompt&gt;$&lt;/prompt&gt; &lt;command&gt;selecao&lt;/command&gt;
&lt;/screen&gt;
            &lt;/listitem&gt;
          &lt;/orderedlist&gt;
      &lt;/orderedlist&gt;</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>  &lt;/sect1&gt;
&lt;/chapter&gt;</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>&lt;!-- bibliografia --&gt;</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>  &lt;bibliography xml:id="bibliografia"&gt;
    &lt;biblioentry&gt;
      &lt;abbrev&gt;Neider2000&lt;/abbrev&gt;
      &lt;author&gt;
        &lt;personname&gt;
        &lt;firstname&gt;Jackie&lt;/firstname&gt;
        &lt;surname&gt;Neider&lt;/surname&gt;
        &lt;/personname&gt;
      &lt;/author&gt;
      &lt;biblioset&gt;
        &lt;title&gt;OpenGL programming Guide&lt;/title&gt;
      &lt;/biblioset&gt;
    &lt;/biblioentry&gt;
    &lt;biblioentry&gt;
      &lt;abbrev&gt;OpenGL ARB&lt;/abbrev&gt;
      &lt;biblioset&gt;
        &lt;title&gt;link:http://www.opengl.org"&gt;www.opengl.org&lt;/link&gt;&lt;/title&gt;
      &lt;/biblioset&gt;
    &lt;/biblioentry&gt;
  &lt;/bibliography&gt;
  &lt;appendix xml:id="contribuicoes"&gt;
    &lt;title&gt;Contribuições&lt;/title&gt;
    Envie suas contribuições para link:mailto:ambj@leca.ufrn.br"&gt;ambj@leca.ufrn.br&lt;/link&gt;. Elas serão muito bem acolhidas.
    Muito obrigado àqueles que contribuíram para melhorar ou corrigir erros.
    Agostinho Brito
    &lt;variablelist&gt;
      &lt;varlistentry&gt;
        &lt;term&gt;&lt;emphasis&gt;Correção de link:mailto:leonardo@engcomp.ufrn.br"&gt;Leonardo Campos&lt;/link&gt;, em 16/11/2000&lt;/emphasis&gt;&lt;/term&gt;
        -
    &lt;screen&gt;
A pagina do capitulo 6 de opengl, na parte de quadricas, ha um erro.
Ao inves de a_1x^2+a_2x^2+a_3x^2 deveria ser a_1x^2+a_2y^2+a_3z^2.</pre>
</div></div>
<div class="paragraph"><p>Ate mais,</p></div>
<div class="paragraph"><p>Leonardo Campos
&lt;/screen&gt;</p></div>
<div class="literalblock">
<div class="content monospaced">
<pre>      &lt;/varlistentry&gt;
      &lt;varlistentry&gt;
        &lt;term&gt;&lt;emphasis&gt;Correções de link:mailto:adler@engcomp.ufrn.br"&gt;Adler Cardoso&lt;/link&gt;, em 20/11/2000&lt;/emphasis&gt;&lt;/term&gt;
        -
    &lt;screen&gt;
Agostinho,</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>ai estão alguns erros que encontrei na especificação do cap. 6:
1 - no arquivo jato.c tem:
      GLint WIDTH =320;
      GLint HEIGHT=240;
e na explicação do arquivo tem:
      int WIDTH =320;
      int HEIGHT=240;
2 - na explicação da tetaxz tem escrito tetaxy (em vermelho);
3 - na explicação de coordenadas ctp e cta tem matrix ao invés de
matriz;
4 - na equação de objetos quádricos tem a_1x^2+a_2x^2+a_3x^3+...;
5 - na explicação de glTexEnvf aparece glBindTexture, que é explicada
logo após também;
6 - na explicação de ImageLoad, tem ImageLoad(();
7 - GL_TEXTURE_WRAP_S é repetido na explicação;
8 - na última, explicação, tem GL_LINEAR_.</pre>
</div></div>
<div class="literalblock">
<div class="content monospaced">
<pre>Espero que isto ajude.</pre>
</div></div>
<div class="paragraph"><p>[]'s
Adler.
&lt;/screen&gt;</p></div>
<div class="literalblock">
<div class="content monospaced">
<pre>      &lt;/varlistentry&gt;
    &lt;/variablelist&gt;
  &lt;/appendix&gt;
&lt;/book&gt;</pre>
</div></div>
</div>
</div>
</div>
<div id="footnotes"><hr></div>
<div id="footer">
<div id="footer-text">
Version 0.9<br />
Last updated 2015-09-30 22:59:18 BRT
</div>
</div>
</body>
</html>
