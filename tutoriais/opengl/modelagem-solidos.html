<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Cap&iacute;tulo 6. Modelagem de S&oacute;lidos</title><link rel="stylesheet" type="text/css" href="estilo.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Introdu&ccedil;&atilde;o &agrave; computa&ccedil;&atilde;o gr&aacute;fica com OpenGL"><link rel="up" href="index.html" title="Introdu&ccedil;&atilde;o &agrave; computa&ccedil;&atilde;o gr&aacute;fica com OpenGL"><link rel="prev" href="projecoes-geometricas.html" title="Cap&iacute;tulo 5. Proje&ccedil;&otilde;es geom&eacute;tricas"><link rel="next" href="curvas-plano.html" title="Cap&iacute;tulo 7. Curvas no plano"><meta xmlns:fo="http://www.w3.org/1999/XSL/Format" http-equiv="Content-Type" content="text/html; charset=utf-8"><script xmlns:fo="http://www.w3.org/1999/XSL/Format" type="text/x-mathjax-config">
    MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
    tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]}
    });
  </script><script xmlns:fo="http://www.w3.org/1999/XSL/Format" type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" class="navheader" href="projecoes-geometricas.html">&laquo;</a></td><th colspan="3" align="center" class="navheader">Cap&iacute;tulo 6. Modelagem de S&oacute;lidos</th><td width="20%" align="right">&nbsp;<a accesskey="n" class="navheader" href="curvas-plano.html">&raquo;</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="modelagem-solidos"></a>Cap&iacute;tulo 6. Modelagem de S&oacute;lidos</h1></div></div></div><div class="toc"><p><b>&Iacute;ndice</b></p><dl class="toc"><dt><span class="sect1"><a href="modelagem-solidos.html#modelagem-descricao">6.1. Descri&ccedil;&atilde;o do programa <code class="filename">jato.c</code></a></span></dt><dt><span class="sect1"><a href="modelagem-solidos.html#modelagem-exercicios">6.2. Exerc&iacute;cios</a></span></dt></dl></div>
    
    <p>O prop&oacute;sito desta li&ccedil;&atilde;o &eacute; introduzir o uso de listas de apresenta&ccedil;&atilde;o (<span class="foreignphrase"><em class="foreignphrase">display lists</em></span>), mapeamento de texturas e o uso de teclas especiais.</p>
    <p>As listas de apresenta&ccedil;&atilde;o permitem que v&aacute;rios comandos sejam executados de uma vez s&oacute; apenas com uma chamada da lista. Cada lista de apresenta&ccedil;&atilde;o precisa ser armazenada apenas uma vez, de modo que quando uma chamada &eacute; realizada, todos os comandos declarados nesta lista j&aacute; estar&atilde;o presentes m&aacute;quina interna do OpenGL, tornando o processo de desenho mais f&aacute;cil e com performance melhorada. </p>
    <p>O mapeamento de texturas nos objetos torna a cena mais real&iacute;stica, principalmente quando texturas de objetos reais s&atilde;o utilizadas. A maioria das texturas existentes n&atilde;o podem ser geradas de forma artificial. Quando isto &eacute; poss&iacute;vel, os algoritmos utilizados s&atilde;o complexos e computacionamente custosos. Assim, geramente as texturas s&atilde;o lidas de arquivos de imagens digitais capturadas com dispositivos de arquisi&ccedil;&atilde;o de dados.</p>
    <p>Diversos formatos podem ser usados para armazenar uma imagem digital: bmp, jpeg, gif, tif, tga etc. Neste curso usaremos o formato IRIS RGB, criado pela Silicon Graphics. As fun&ccedil;&otilde;es que permitem a leitura de arquivos RGB e seus respectivos prot&oacute;tipos est&atilde;o implementados nos arquivos <a class="ulink" href="exemplos/image.c" target="_top"><code class="filename">image.c</code></a> e <a class="ulink" href="exemplos/image.h" target="_top"><code class="filename">image.h</code></a>.</p>
    <p>O objeto utilizado nesta li&ccedil;&atilde;o ser&aacute; um modelo simples de uma avi&atilde;o a jato com fuselagem texturizada, im&oacute;vel sobre um plano com textura montanhosa, como mostra a <a class="xref" href="modelagem-solidos.html#fig-modelagem-jato-3d" title="Figura 6.1. Avi&atilde;o a jato tridimensional">Figura&nbsp;6.1</a>. As vistas laterais, superior e frontal est&atilde;o esquematizadas na <a class="xref" href="modelagem-solidos.html#fig-modelagem-jato" title="Figura 6.2. Vistas laterais, superior e frontal do avi&atilde;o a jato">Figura&nbsp;6.2</a>.</p>
    <div class="figure"><a name="fig-modelagem-jato-3d"></a><p class="title"><b>Figura 6.1. Avi&atilde;o a jato tridimensional</b></p><div class="figure-contents">
      
	<div class="mediaobject"><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="graphic"><img alt="figs/modelagem-jato-3d.jpg" src="figs/modelagem-jato-3d.jpg"></div></div>

    </div></div><br class="figure-break">
    <div class="figure"><a name="fig-modelagem-jato"></a><p class="title"><b>Figura 6.2. Vistas laterais, superior e frontal do avi&atilde;o a jato</b></p><div class="figure-contents">
      
	<div class="mediaobject"><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="graphic"><img alt="figs/modelagem-jato.jpg" src="figs/modelagem-jato.jpg"></div></div>
    </div></div><br class="figure-break">
    <p> Neste exemplo, o olhar do observador &eacute; fixado aproximadamente no centro do avi&atilde;o, de modo que apenas a posi&ccedil;&atilde;o deste observador &eacute; alterada para o usu&aacute;rio poder visualizar diversas tomadas da cena.</p>
    <p> O programa usado para modelar o avi&atilde;o &eacute; mostrado no <a class="xref" href="modelagem-solidos.html#example-modelagem-solidos" title="Exemplo 6.1. programa jato.c">Exemplo&nbsp;6.1</a>. As teclas <span class="keycap"><strong>LEFT</strong></span> e <span class="keycap"><strong>RIGHT</strong></span> servem para rotacionar a posi&ccedil;&atilde;o do observador em torno do eixo y contra e a favor do sentido dos ponteiros do rel&oacute;gio, respectivamente. A dist&acirc;ncia entre o observador e o centro de rota&ccedil;&atilde;o (raio de observa&ccedil;&atilde;o) &eacute; alterado pelas teclas <span class="keycap"><strong>r</strong></span> e <span class="keycap"><strong>R</strong></span>, que aumentam o diminuem o seu valor, respectivamente. As teclas <span class="keycap"><strong>UP</strong></span> e <span class="keycap"><strong>DOWN</strong></span>, controlam a altitude do observador (no eixo y). A tecla <span class="keycap"><strong>t</strong></span> habilita ou desabilita o uso de texturas. Para finalizar o programa, basta digitar <span class="keycap"><strong>ESC</strong></span>. As teclas e suas respectivas a&ccedil;&otilde;es est&atilde;o definidas nas fun&ccedil;&otilde;es <code class="function">keyboard()</code> e <code class="function">special()</code>.</p>
    <div class="example"><a name="example-modelagem-solidos"></a><p class="title"><b>Exemplo 6.1. programa <a class="ulink" href="exemplos/jato.c" target="_top"><code class="filename">jato.c</code></a></b></p><div class="example-contents">
      
      <pre class="programlisting">#include &lt;stdio.h&gt;
<span class="hl-directive" style="color: maroon">#include &lt;stdlib.h&gt;</span>
<span class="hl-directive" style="color: maroon">#include &lt;math.h&gt;</span>
<span class="hl-directive" style="color: maroon">#include &lt;GL/glut.h&gt;</span>
<span class="hl-directive" style="color: maroon">#include "image.h"</span>

<span class="hl-directive" style="color: maroon">#define PI 3.1415</span>

<span class="hl-directive" style="color: maroon">#define COORD_TEXTURA_PLANO 1.0</span>
<span class="hl-directive" style="color: maroon">#define COORD_TEXTURA_AVIAO 1.0</span>
<span class="hl-directive" style="color: maroon">#define COR_DO_PLANO 0.52,0.52,0.78,1.0</span>
<span class="hl-directive" style="color: maroon">#define COR_DO_AVIAO 0.3,0.52,0.18,1.0</span>
<span class="hl-directive" style="color: maroon">#define TEXTURA_DO_PLANO "montanhas.rgb"</span>
<span class="hl-directive" style="color: maroon">#define TEXTURA_DO_AVIAO "camuflagem.rgb"</span>

GLint WIDTH =<span class="hl-number">800</span>;
GLint HEIGHT=<span class="hl-number">600</span>;

GLfloat obs[<span class="hl-number">3</span>]={<span class="hl-number">0.0</span>,<span class="hl-number">7.0</span>,<span class="hl-number">0.0</span>};
GLfloat look[<span class="hl-number">3</span>]={<span class="hl-number">0.0</span>,<span class="hl-number">3.0</span>,<span class="hl-number">0.0</span>};
GLuint  textura_plano;
GLuint  textura_aviao;

GLshort texturas=<span class="hl-number">1</span>;
GLfloat tetaxz=<span class="hl-number">0</span>;
GLfloat raioxz=<span class="hl-number">6</span>;
GLuint  jato;

GLfloat ctp[<span class="hl-number">4</span>][<span class="hl-number">2</span>]={
  {-COORD_TEXTURA_PLANO,-COORD_TEXTURA_PLANO},
  {+COORD_TEXTURA_PLANO,-COORD_TEXTURA_PLANO},
  {+COORD_TEXTURA_PLANO,+COORD_TEXTURA_PLANO},
  {-COORD_TEXTURA_PLANO,+COORD_TEXTURA_PLANO}
};

GLfloat cta[<span class="hl-number">4</span>][<span class="hl-number">2</span>]={
  {-COORD_TEXTURA_AVIAO,-COORD_TEXTURA_AVIAO},
  {+COORD_TEXTURA_AVIAO,-COORD_TEXTURA_AVIAO},
  {+COORD_TEXTURA_AVIAO,+COORD_TEXTURA_AVIAO},
  {-COORD_TEXTURA_AVIAO,+COORD_TEXTURA_AVIAO}
};


<strong class="hl-keyword">void</strong> reshape(<strong class="hl-keyword">int</strong> width, <strong class="hl-keyword">int</strong> height){
  WIDTH=width;
  HEIGHT=height;
  glViewport(<span class="hl-number">0</span>,<span class="hl-number">0</span>,(GLint)width,(GLint)height);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  gluPerspective(<span class="hl-number">70.0</span>,width/(<strong class="hl-keyword">float</strong>)height,<span class="hl-number">0.1</span>,<span class="hl-number">30.0</span>);
  glMatrixMode(GL_MODELVIEW);
}

<strong class="hl-keyword">void</strong> compoe_jato(<strong class="hl-keyword">void</strong>){
  GLUquadricObj *quadric;

  GLfloat asa[][<span class="hl-number">3</span>]={
    {-<span class="hl-number">4.0</span>,<span class="hl-number">0.0</span>,<span class="hl-number">0.0</span>},
    {+<span class="hl-number">4.0</span>,<span class="hl-number">0.0</span>,<span class="hl-number">0.0</span>},
    {<span class="hl-number">0.0</span>,<span class="hl-number">0.0</span>,<span class="hl-number">3.0</span>}
  };

  GLfloat cauda[][<span class="hl-number">3</span>]={
    {<span class="hl-number">0.0</span>,<span class="hl-number">0.0</span>,<span class="hl-number">0.0</span>},
    {<span class="hl-number">0.0</span>,<span class="hl-number">2.0</span>,-<span class="hl-number">1.0</span>},
    {<span class="hl-number">0.0</span>,<span class="hl-number">2.0</span>,<span class="hl-number">0.0</span>},
    {<span class="hl-number">0.0</span>,<span class="hl-number">0.0</span>,<span class="hl-number">2.0</span>}
  };
  <em class="hl-comment" style="color: silver">/* inicia a composicao do jato */</em>
  jato = glGenLists(<span class="hl-number">1</span>);
  glNewList(jato, GL_COMPILE);

  <em class="hl-comment" style="color: silver">/* asas */</em>
  glBegin(GL_TRIANGLES); 
  glTexCoord2fv(cta[<span class="hl-number">0</span>]); glVertex3fv(asa[<span class="hl-number">0</span>]);
  glTexCoord2fv(cta[<span class="hl-number">1</span>]); glVertex3fv(asa[<span class="hl-number">1</span>]);
  glTexCoord2fv(cta[<span class="hl-number">3</span>]); glVertex3fv(asa[<span class="hl-number">2</span>]);
  glEnd();
  
  <em class="hl-comment" style="color: silver">/* corpo */</em>
  quadric = gluNewQuadric();
  gluQuadricTexture(quadric, GL_TRUE);
  gluCylinder(quadric, <span class="hl-number">0.5</span>, <span class="hl-number">0.5</span>, <span class="hl-number">4</span>, <span class="hl-number">12</span>, <span class="hl-number">3</span>);
  
  <em class="hl-comment" style="color: silver">/* nariz */</em>
  quadric = gluNewQuadric();
  gluQuadricTexture(quadric, GL_TRUE);
  glPushMatrix();
  glTranslatef(<span class="hl-number">0</span>,<span class="hl-number">0</span>,<span class="hl-number">4</span>);
  gluCylinder(quadric, <span class="hl-number">0.5</span>, <span class="hl-number">0.0</span>, <span class="hl-number">1.5</span>, <span class="hl-number">12</span>, <span class="hl-number">3</span>);
  glPopMatrix();

  <em class="hl-comment" style="color: silver">/* cauda */</em>
  glBegin(GL_POLYGON); 
  glTexCoord2fv(cta[<span class="hl-number">0</span>]); glVertex3fv(cauda[<span class="hl-number">0</span>]);
  glTexCoord2fv(cta[<span class="hl-number">1</span>]); glVertex3fv(cauda[<span class="hl-number">1</span>]);
  glTexCoord2fv(cta[<span class="hl-number">2</span>]); glVertex3fv(cauda[<span class="hl-number">2</span>]);
  glTexCoord2fv(cta[<span class="hl-number">3</span>]); glVertex3fv(cauda[<span class="hl-number">3</span>]);
  glEnd();

  <em class="hl-comment" style="color: silver">/* cabine do piloto */</em>
  glTranslatef(<span class="hl-number">0</span>,<span class="hl-number">0.3</span>,<span class="hl-number">3.5</span>);
  glPushMatrix();
  glScalef(<span class="hl-number">0.7</span>,<span class="hl-number">0.7</span>,<span class="hl-number">2.0</span>);
  quadric=gluNewQuadric();
  glColor3f(<span class="hl-number">0.3</span>,<span class="hl-number">0.5</span>,<span class="hl-number">1</span>);
  glDisable(GL_TEXTURE_<span class="hl-number">2</span>D);
  gluSphere(quadric,<span class="hl-number">0.5</span>,<span class="hl-number">12</span>,<span class="hl-number">12</span>);
  glPopMatrix();

  <em class="hl-comment" style="color: silver">/* termina a composicao do jato*/</em>
  glEndList();
}

<strong class="hl-keyword">void</strong> display(<strong class="hl-keyword">void</strong>){
  glEnable(GL_DEPTH_TEST);
  
  glDepthMask(GL_TRUE);
  glClearColor(<span class="hl-number">1.0</span>,<span class="hl-number">1.0</span>,<span class="hl-number">1.0</span>,<span class="hl-number">1.0</span>);
  glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
  
  glPushMatrix();

  <em class="hl-comment" style="color: silver">/* calcula a posicao do observador */</em>
  obs[<span class="hl-number">0</span>]=raioxz*cos(<span class="hl-number">2</span>*PI*tetaxz/<span class="hl-number">360</span>);
  obs[<span class="hl-number">2</span>]=raioxz*sin(<span class="hl-number">2</span>*PI*tetaxz/<span class="hl-number">360</span>);
  gluLookAt(obs[<span class="hl-number">0</span>],obs[<span class="hl-number">1</span>],obs[<span class="hl-number">2</span>],look[<span class="hl-number">0</span>],look[<span class="hl-number">1</span>],look[<span class="hl-number">2</span>],<span class="hl-number">0.0</span>,<span class="hl-number">1.0</span>,<span class="hl-number">0.0</span>);

  <em class="hl-comment" style="color: silver">/* habilita/desabilita uso de texturas*/</em>
  <strong class="hl-keyword">if</strong>(texturas){
    glEnable(GL_TEXTURE_<span class="hl-number">2</span>D);  
  }
  <strong class="hl-keyword">else</strong>{
    glDisable(GL_TEXTURE_<span class="hl-number">2</span>D);
  }

  glColor4f(COR_DO_PLANO);
  glTexEnvf(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_DECAL);
  glBindTexture(GL_TEXTURE_<span class="hl-number">2</span>D,textura_plano);
   
  glBegin(GL_QUADS);
  glTexCoord2fv(ctp[<span class="hl-number">0</span>]);  glVertex3f(-<span class="hl-number">10</span>,<span class="hl-number">0</span>,<span class="hl-number">10</span>);
  glTexCoord2fv(ctp[<span class="hl-number">1</span>]);  glVertex3f(<span class="hl-number">10</span>,<span class="hl-number">0</span>,<span class="hl-number">10</span>);
  glTexCoord2fv(ctp[<span class="hl-number">2</span>]);  glVertex3f(<span class="hl-number">10</span>,<span class="hl-number">0</span>,-<span class="hl-number">10</span>);
  glTexCoord2fv(ctp[<span class="hl-number">3</span>]);  glVertex3f(-<span class="hl-number">10</span>,<span class="hl-number">0</span>,-<span class="hl-number">10</span>);
  glEnd();
  glTranslatef(<span class="hl-number">0.0</span>,<span class="hl-number">2.0</span>,-<span class="hl-number">3.0</span>);

  glColor4f(COR_DO_AVIAO);
  glBindTexture(GL_TEXTURE_<span class="hl-number">2</span>D,textura_aviao);
  glCallList(jato);

  glPopMatrix();
  glutSwapBuffers();
}


<strong class="hl-keyword">void</strong> special(<strong class="hl-keyword">int</strong> key, <strong class="hl-keyword">int</strong> x, <strong class="hl-keyword">int</strong> y){
  <strong class="hl-keyword">switch</strong> (key) {
  <strong class="hl-keyword">case</strong> GLUT_KEY_UP:
    obs[<span class="hl-number">1</span>]=obs[<span class="hl-number">1</span>]+<span class="hl-number">1</span>;
    glutPostRedisplay();
    <strong class="hl-keyword">break</strong>;
  <strong class="hl-keyword">case</strong> GLUT_KEY_DOWN:
    obs[<span class="hl-number">1</span>] =obs[<span class="hl-number">1</span>]-<span class="hl-number">1</span>;
    glutPostRedisplay();
    <strong class="hl-keyword">break</strong>;
  <strong class="hl-keyword">case</strong> GLUT_KEY_LEFT:
    tetaxz=tetaxz+<span class="hl-number">2</span>;
    glutPostRedisplay();
    <strong class="hl-keyword">break</strong>;
  <strong class="hl-keyword">case</strong> GLUT_KEY_RIGHT:
    tetaxz=tetaxz-<span class="hl-number">2</span>;
    glutPostRedisplay();
    <strong class="hl-keyword">break</strong>;
  }
}

<strong class="hl-keyword">void</strong> keyboard(<strong class="hl-keyword">unsigned</strong> <strong class="hl-keyword">char</strong> key, <strong class="hl-keyword">int</strong> x, <strong class="hl-keyword">int</strong> y){
  <strong class="hl-keyword">switch</strong> (key) {
  <strong class="hl-keyword">case</strong> <span class="hl-number">27</span>:
    exit(<span class="hl-number">0</span>);
    <strong class="hl-keyword">break</strong>;
  <strong class="hl-keyword">case</strong> <strong class="hl-string"><em style="color:red">'t'</em></strong>:
    texturas = !texturas;
    glutPostRedisplay();
    <strong class="hl-keyword">break</strong>;
  <strong class="hl-keyword">case</strong> <strong class="hl-string"><em style="color:red">'r'</em></strong>:
    raioxz=raioxz+<span class="hl-number">1</span>;
    glutPostRedisplay();
    <strong class="hl-keyword">break</strong>;
  <strong class="hl-keyword">case</strong> <strong class="hl-string"><em style="color:red">'R'</em></strong>:
    raioxz=raioxz-<span class="hl-number">1</span>;
    <strong class="hl-keyword">if</strong>(raioxz==<span class="hl-number">0</span>){
      raioxz=<span class="hl-number">1</span>;
    }
    glutPostRedisplay();
    <strong class="hl-keyword">break</strong>;
  }
}

<strong class="hl-keyword">void</strong> carregar_texturas(<strong class="hl-keyword">void</strong>){
  IMAGE *img;
  GLenum gluerr;

  <em class="hl-comment" style="color: silver">/* textura do plano */</em>
  glGenTextures(<span class="hl-number">1</span>, &amp;textura_plano);
  glBindTexture(GL_TEXTURE_<span class="hl-number">2</span>D, textura_plano);
  
  <strong class="hl-keyword">if</strong>(!(img=ImageLoad(TEXTURA_DO_PLANO))) {
    fprintf(stderr,<strong class="hl-string"><em style="color:red">"Error reading a texture.\n"</em></strong>);
    exit(-<span class="hl-number">1</span>);
  }

  gluerr=gluBuild2DMipmaps(GL_TEXTURE_<span class="hl-number">2</span>D, <span class="hl-number">3</span>, 
			   img-&gt;sizeX, img-&gt;sizeY, 
			   GL_RGB, GL_UNSIGNED_BYTE, 
			   (GLvoid *)(img-&gt;data));
  <strong class="hl-keyword">if</strong>(gluerr){
    fprintf(stderr,<strong class="hl-string"><em style="color:red">"GLULib%s\n"</em></strong>,gluErrorString(gluerr));
    exit(-<span class="hl-number">1</span>);
  }

  glTexParameterf(GL_TEXTURE_<span class="hl-number">2</span>D,GL_TEXTURE_WRAP_S,GL_REPEAT);
  glTexParameterf(GL_TEXTURE_<span class="hl-number">2</span>D,GL_TEXTURE_WRAP_T,GL_REPEAT);
  glTexParameterf(GL_TEXTURE_<span class="hl-number">2</span>D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR);
  glTexParameterf(GL_TEXTURE_<span class="hl-number">2</span>D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
  glTexEnvf(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_DECAL);

  <em class="hl-comment" style="color: silver">/* textura do aviao */</em>
  glGenTextures(<span class="hl-number">1</span>, &amp;textura_aviao);
  glBindTexture(GL_TEXTURE_<span class="hl-number">2</span>D, textura_aviao);

  
  <strong class="hl-keyword">if</strong>(!(img=ImageLoad(TEXTURA_DO_AVIAO))) {
    fprintf(stderr,<strong class="hl-string"><em style="color:red">"Error reading a texture.\n"</em></strong>);
    exit(-<span class="hl-number">1</span>);
  }

  gluerr=gluBuild2DMipmaps(GL_TEXTURE_<span class="hl-number">2</span>D, <span class="hl-number">3</span>, 
			   img-&gt;sizeX, img-&gt;sizeY, 
			   GL_RGB, GL_UNSIGNED_BYTE, 
			   (GLvoid *)(img-&gt;data));
  <strong class="hl-keyword">if</strong>(gluerr){
    fprintf(stderr,<strong class="hl-string"><em style="color:red">"GLULib%s\n"</em></strong>,gluErrorString(gluerr));
    exit(-<span class="hl-number">1</span>);
  }

  glTexParameterf(GL_TEXTURE_<span class="hl-number">2</span>D,GL_TEXTURE_WRAP_S,GL_REPEAT);
  glTexParameterf(GL_TEXTURE_<span class="hl-number">2</span>D,GL_TEXTURE_WRAP_T,GL_REPEAT);
  glTexParameterf(GL_TEXTURE_<span class="hl-number">2</span>D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR);
  glTexParameterf(GL_TEXTURE_<span class="hl-number">2</span>D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
  glTexEnvf(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_DECAL);
  
}

<strong class="hl-keyword">void</strong> init(){
  carregar_texturas();
  compoe_jato();
  glShadeModel(GL_FLAT);
  glEnable(GL_DEPTH_TEST);
  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
  glEnable(GL_TEXTURE_<span class="hl-number">2</span>D);
}

<strong class="hl-keyword">int</strong> main(<strong class="hl-keyword">int</strong> argc,<strong class="hl-keyword">char</strong> **argv){
  glutInitWindowPosition(<span class="hl-number">0</span>,<span class="hl-number">0</span>);
  glutInitWindowSize(WIDTH,HEIGHT);
  glutInit(&amp;argc,argv);
  glutInitDisplayMode(GLUT_RGB|GLUT_DEPTH|GLUT_DOUBLE);

  <strong class="hl-keyword">if</strong>(!glutCreateWindow(<strong class="hl-string"><em style="color:red">"Avi&#65533;o a jato"</em></strong>)) {
    fprintf(stderr,<strong class="hl-string"><em style="color:red">"Error opening a window.\n"</em></strong>);
    exit(-<span class="hl-number">1</span>);
  }

  init();
  
  glutKeyboardFunc(keyboard);
  glutSpecialFunc(special);
  glutDisplayFunc(display);
  glutReshapeFunc(reshape);
  glutMainLoop();

  <strong class="hl-keyword">return</strong>(<span class="hl-number">0</span>);
}

</pre>

    </div></div><br class="example-break">

    <p>Para compilar e executar o programa <a class="ulink" href="exemplos/jato.c" target="_top"><code class="filename">jato.c</code></a>, salve-o juntamente com os arquivo <a class="ulink" href="exemplos/Makefile.modelagem" target="_top">Makefile.modelagem</a>, <a class="ulink" href="exemplos/image.c" target="_top">image.c</a>, <a class="ulink" href="exemplos/image.h" target="_top">image.h</a>, <a class="ulink" href="exemplos/montanhas.rgb" target="_top">montanhas.rgb</a> e <a class="ulink" href="exemplos/camuflagem.rgb" target="_top">camuflagem.rgb</a> em um diret&oacute;rio e execute a seguinte seq&uuml;&ecirc;ncia de comandos:</p>
    <pre class="screen">
<code class="prompt">$</code> <span class="command"><strong>make</strong></span> <code class="option">-f</code> <code class="option">Makefile.modelagem</code> <code class="option">jato</code>
<code class="prompt">$</code> <span class="command"><strong>jato</strong></span>
</pre>	
    <div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="modelagem-descricao"></a>6.1. Descri&ccedil;&atilde;o do programa <code class="filename">jato.c</code></h2></div></div></div>
      
      
      <div class="informalexample">
	<pre class="programlisting">#define COORD_TEXTURA_PLANO <span class="hl-number">1.0</span>
<span class="hl-directive" style="color: maroon">#define COORD_TEXTURA_AVIAO 1.0</span>
<span class="hl-directive" style="color: maroon">#define COR_DO_PLANO 0.52,0.52,0.78,1.0</span>
<span class="hl-directive" style="color: maroon">#define COR_DO_AVIAO 0.3,0.52,0.18,1.0</span>
<span class="hl-directive" style="color: maroon">#define TEXTURA_DO_PLANO "montanhas.rgb"</span>
<span class="hl-directive" style="color: maroon">#define TEXTURA_DO_AVIAO "camuflagem.rgb"</span></pre>

      </div>
      <p>Define as cores e coordenadas das texturas do plano e do avi&atilde;o, al&eacute;m dos nomes dos arquivos que cont&eacute;m as imagens das texturas.</p>

      <div class="informalexample">
	<pre class="programlisting">GLint WIDTH =<span class="hl-number">320</span>;
GLint HEIGHT=<span class="hl-number">240</span>;</pre>

      </div>
      <p>Especifica a largura (<span class="foreignphrase"><em class="foreignphrase">WIDTH</em></span>) e a altura (<span class="foreignphrase"><em class="foreignphrase">HEIGHT</em></span>) iniciais da janela de desenho.</p>

      <div class="informalexample">
	<pre class="programlisting">GLfloat obs[<span class="hl-number">3</span>]={<span class="hl-number">0.0</span>,<span class="hl-number">7.0</span>,<span class="hl-number">0.0</span>};
GLfloat look[<span class="hl-number">3</span>]={<span class="hl-number">0.0</span>,<span class="hl-number">3.0</span>,<span class="hl-number">0.0</span>};</pre>

      </div>
      <p>As coordenadas da posi&ccedil;&atilde;o do observador &eacute; armazenada no vetor <code class="varname">obs[]</code> e as do ponto para onde o observador olha &eacute; armazenado no vetor <code class="varname">look[]</code>. De acordo com estes vetores, o observador encontra-se no ponto (x,y,z)=(0,7,0) e est&aacute; olhando para o ponto (x,y,z)=(0,3,0).</p>
      
      <div class="informalexample">
	<pre class="programlisting">GLuint  textura_plano;
GLuint  textura_aviao;</pre>

      </div>
      <p>As vari&aacute;veis <code class="varname">textura_plano</code> e <code class="varname">textura_aviao</code> armazenam os identificadores das texturas do plano e do avi&atilde;o.</p>

      <div class="informalexample">
	<pre class="programlisting">GLshort texturas=<span class="hl-number">1</span>;
GLfloat tetaxz=<span class="hl-number">0</span>;
GLfloat raioxz=<span class="hl-number">6</span>;
GLuint  jato;</pre>

      </div>
      <p>A vari&aacute;vel <code class="varname">texturas</code> &eacute; usada para habilitar/desabilitar o uso de texturas nos objetos. As vari&aacute;veis <code class="varname">tetaxz</code> e <code class="varname">raioxz</code> armazenam o &acirc;ngulo de rota&ccedil;&atilde;o do ponto de observa&ccedil;&atilde;o e a dist&acirc;ncia entre o observador e a origem, respectivamente. A vari&aacute;vel <code class="varname">jato</code> amazena o identificador para a lista de apresenta&ccedil;&atilde;o do avi&atilde;o a jato.</p>

      <div class="informalexample">
	<pre class="programlisting">GLfloat ctp[<span class="hl-number">4</span>][<span class="hl-number">2</span>]={
  {-COORD_TEXTURA_PLANO,-COORD_TEXTURA_PLANO},
  {+COORD_TEXTURA_PLANO,-COORD_TEXTURA_PLANO},
  {+COORD_TEXTURA_PLANO,+COORD_TEXTURA_PLANO},
  {-COORD_TEXTURA_PLANO,+COORD_TEXTURA_PLANO}
};

GLfloat cta[<span class="hl-number">4</span>][<span class="hl-number">2</span>]={
  {-COORD_TEXTURA_AVIAO,-COORD_TEXTURA_AVIAO},
  {+COORD_TEXTURA_AVIAO,-COORD_TEXTURA_AVIAO},
  {+COORD_TEXTURA_AVIAO,+COORD_TEXTURA_AVIAO},
  {-COORD_TEXTURA_AVIAO,+COORD_TEXTURA_AVIAO}
};</pre>

      </div>
      <p>Quando uma textura &eacute; carregada, o OpenGL guarda em uma matriz e assume coordenadas (0,0), (1,0), (1,1) e (0,1) para os quatro cantos da textura. Neste exemplo, &eacute; assumido a repeti&ccedil;&atilde;o das texturas, de modo a poder cobrir todo o objeto. As coordenadas especificadas neste trecho de c&oacute;digo indicam que o objeto ser&aacute; carimbado com sua respectiva textura e que as coordenadas das texturas que ser&atilde;o usadas para criar os carimbos do plano e do avi&atilde;o ser&atilde;o <code class="varname">ctp[]</code> e <code class="varname">cta[]</code>, respectivamente. </p>

      <div class="informalexample">
	<pre class="programlisting">GLUquadricObj *quadric;</pre>

      </div>
      <p>Qu&aacute;dricas s&atilde;o superf&iacute;cies definidas pela seguinte equa&ccedil;&atilde;o a<sub>1</sub>x<sup>2</sup> + a<sub>2</sub>y<sup>2</sup> +a<sub>3</sub>z<sup>2</sup> + a<sub>4</sub>xy + a<sub>5</sub>yz + a<sub>6</sub>xz + a<sub>7</sub>x + a<sub>8</sub>y +a<sub>9</sub>z +  a<sub>10</sub>. Os tipos de qu&aacute;dricas mais conhecidos s&atilde;o os cones, os cilindros, as esferas e os discos, modelados pelo ajuste adequado dos par&acirc;metros a<sub>i</sub>. Estes objetos s&atilde;o guardados em uma estrutura de dados do tipo <span class="type">GLUquadricObj</span>.</p> 

      <div class="informalexample">
	<pre class="programlisting">GLfloat asa[][<span class="hl-number">3</span>]={
    {-<span class="hl-number">4.0</span>,<span class="hl-number">0.0</span>,<span class="hl-number">0.0</span>},
    {+<span class="hl-number">4.0</span>,<span class="hl-number">0.0</span>,<span class="hl-number">0.0</span>},
    {<span class="hl-number">0.0</span>,<span class="hl-number">0.0</span>,<span class="hl-number">3.0</span>}
  };

  GLfloat cauda[][<span class="hl-number">3</span>]={
    {<span class="hl-number">0.0</span>,<span class="hl-number">0.0</span>,<span class="hl-number">0.0</span>},
    {<span class="hl-number">0.0</span>,<span class="hl-number">2.0</span>,-<span class="hl-number">1.0</span>},
    {<span class="hl-number">0.0</span>,<span class="hl-number">2.0</span>,<span class="hl-number">0.0</span>},
    {<span class="hl-number">0.0</span>,<span class="hl-number">0.0</span>,<span class="hl-number">2.0</span>}
  };</pre>

      </div>
      <p>As vari&aacute;veis <code class="varname">asa[][]</code> e <code class="varname">cauda[][]</code> armazenam as coordenadas dos pol&iacute;gonos que comp&otilde;em a asa e a cauda do avi&atilde;o, respectivamente.</p> 

      <div class="informalexample">
	<pre class="programlisting">jato = glGenLists(<span class="hl-number">1</span>);
  glNewList(jato, GL_COMPILE);</pre>

      </div>
      <p>A fun&ccedil;&atilde;o <code class="function">glGenLists()</code> aloca um conjunto cont&iacute;nuo de listas de apresenta&ccedil;&atilde;o vazias e retorna o identificador utilizado para a lista alocada. Neste exemplo, o conjunto cont&eacute;m apenas uma lista de apresenta&ccedil;&atilde;o. Mais listas poder&atilde;o ser alocadas com subseq&uuml;entes chamadas &agrave; mesma fun&ccedil;&atilde;o. </p> 
      <p>A fun&ccedil;&atilde;o <code class="function">glNewList()</code> especifica o in&iacute;cio de uma lista de apresenta&ccedil;&atilde;o. Todos os comandos executados at&eacute; a chamada de <code class="function">glEndList()</code> ficar&atilde;o armazenados nesta lista. A fun&ccedil;&atilde;o <code class="function">glNewList()</code> possui o seguinte prot&oacute;tipo:</p>
      <div class="funcsynopsis">
	<table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">glNewList</b>(</code></td><td><var class="pdparam">list</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">mode</var><code>)</code>;</td><td>&nbsp;</td></tr></table><div class="paramdef-list"><code>GLUint <var class="pdparam">list</var></code>;<br><code>GLenum <var class="pdparam">mode</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div>
      </div>
      <p><em class="parameter"><code>list</code></em> &eacute; um n&uacute;mero inteiro maior que zero que identifica de forma &uacute;nica a lista de apresenta&ccedil;&atilde;o. O par&acirc;metro <em class="parameter"><code>mode</code></em> pode assumir os valores <em class="parameter"><code>GL_COMPILE</code></em> e <em class="parameter"><code>GL_COMPILE_AND_EXECUTE</code></em>. O primeiro apenas armazena os comandos na lista; o segundo executa os comandos enquanto s&atilde;o armazenados na lista.</p>

      <div class="informalexample">
	<pre class="programlisting">quadric = gluNewQuadric();
  gluQuadricTexture(quadric, GL_TRUE);
  gluCylinder(quadric, <span class="hl-number">0.5</span>, <span class="hl-number">0.5</span>, <span class="hl-number">4</span>, <span class="hl-number">12</span>, <span class="hl-number">3</span>);</pre>

      </div>
      <p>Inicia, usando a fun&ccedil;&atilde;o <code class="function">gluNewQuadric()</code>, a primeira das qu&aacute;dricas do exemplo: o corpo do avi&atilde;o. Para esta qu&aacute;drica, o mapeamento de textura est&aacute; habilitado. A fun&ccedil;&atilde;o <code class="function">gluCylinder()</code> possui o seguinte prot&oacute;tipo:</p>
      <div class="funcsynopsis">
	<table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">gluCylinder</b>(</code></td><td><var class="pdparam">quad</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam"> base</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">top</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">height</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">slices</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">stacks</var><code>)</code>;</td><td>&nbsp;</td></tr></table><div class="paramdef-list"><code>GLUquadric* <var class="pdparam">quad</var></code>;<br><code>GLdouble <var class="pdparam"> base</var></code>;<br><code>GLdouble <var class="pdparam">top</var></code>;<br><code>GLdouble <var class="pdparam">height</var></code>;<br><code>GLint <var class="pdparam">slices</var></code>;<br><code>GLint <var class="pdparam">stacks</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div>
      </div>
      <p>O par&acirc;metro <em class="parameter"><code>quad</code></em> &eacute; o objeto de qu&aacute;drica; <em class="parameter"><code>base</code></em>, <em class="parameter"><code>top</code></em> e <em class="parameter"><code>height</code></em> especificam o raio da base, o raio do topo e a altura do cilindro, respectivamente; <em class="parameter"><code>slices</code></em> <em class="parameter"><code>stacks</code></em> especificam o n&uacute;mero de subdivis&otilde;es ao redor do eixo z e ao longo do mesmo.</p> 

      <div class="informalexample">
	<pre class="programlisting">obs[<span class="hl-number">0</span>]=raioxz*cos(<span class="hl-number">2</span>*PI*tetaxz/<span class="hl-number">360</span>);
  obs[<span class="hl-number">2</span>]=raioxz*sin(<span class="hl-number">2</span>*PI*tetaxz/<span class="hl-number">360</span>);
  gluLookAt(obs[<span class="hl-number">0</span>],obs[<span class="hl-number">1</span>],obs[<span class="hl-number">2</span>],look[<span class="hl-number">0</span>],look[<span class="hl-number">1</span>],look[<span class="hl-number">2</span>],<span class="hl-number">0.0</span>,<span class="hl-number">1.0</span>,<span class="hl-number">0.0</span>);</pre>

      </div>
      <p>Na fun&ccedil;&atilde;o <code class="function">display()</code> as coordenadas x e z da posi&ccedil;&atilde;o do observador s&atilde;o calculadas e a fun&ccedil;&atilde;o <code class="function">gluLookAt()</code> &eacute; chamada para mudar a posi&ccedil;&atilde;o do observador.</p> 

      <div class="informalexample">
	<pre class="programlisting"><strong class="hl-keyword">if</strong>(texturas){
    glEnable(GL_TEXTURE_<span class="hl-number">2</span>D);  
  }
  <strong class="hl-keyword">else</strong>{
    glDisable(GL_TEXTURE_<span class="hl-number">2</span>D);
  }</pre>

      </div>
      <p>Aqui o mapeamento de texturas &eacute; habilitado ou desabilitado, de acordo com o estado da vari&aacute;vel <code class="varname">texturas</code>. Quando o mapeamento de texturas &eacute; desabilitado, o objeto &eacute; desenhado utilizando as cores especificadas pela fun&ccedil;&atilde;o <code class="function">glColor*()</code>.</p> 

      <div class="informalexample">
	<pre class="programlisting">glTexEnvf(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_DECAL);</pre>

      </div>
      <p>A fun&ccedil;&atilde;o <code class="function">glTexEnvf()</code> define os par&acirc;metros do ambiente de textura. O primeiro par&acirc;metro &eacute; sempre <em class="parameter"><code>GL_TEXTURE_ENV</code></em>; o segundo par&acirc;metro &eacute; sempre <em class="parameter"><code>GL_TEXTURE_ENV_MODE</code></em> e o terceiro especifica como a textura ser&aacute; combinada com a cor para formar a superf&iacute;cie do objeto, neste caso substituindo completamente a cor do objeto pela textura corrente.</p> 

      <div class="informalexample">
	<pre class="programlisting">glBindTexture(GL_TEXTURE_<span class="hl-number">2</span>D,textura_plano);
   
  glBegin(GL_QUADS);
  glTexCoord2fv(ctp[<span class="hl-number">0</span>]);  glVertex3f(-<span class="hl-number">10</span>,<span class="hl-number">0</span>,<span class="hl-number">10</span>);
  glTexCoord2fv(ctp[<span class="hl-number">1</span>]);  glVertex3f(<span class="hl-number">10</span>,<span class="hl-number">0</span>,<span class="hl-number">10</span>);
  glTexCoord2fv(ctp[<span class="hl-number">2</span>]);  glVertex3f(<span class="hl-number">10</span>,<span class="hl-number">0</span>,-<span class="hl-number">10</span>);
  glTexCoord2fv(ctp[<span class="hl-number">3</span>]);  glVertex3f(-<span class="hl-number">10</span>,<span class="hl-number">0</span>,-<span class="hl-number">10</span>);
  glEnd();</pre>

      </div>
      <p><code class="function">glBindTexture()</code> carrega a textura bidimensional associada com a vari&aacute;vel <code class="varname">textura_plano</code>. Em seguida, um plano &eacute; desenhado usando <em class="parameter"><code>GL_QUADS</code></em>. Observe que, antes de desenhar cada v&eacute;rtice, a fun&ccedil;&atilde;o <code class="function">glTexCoord2fv()</code> &eacute; chamada para definir as coordenadas de textura correntes.</p> 

      <div class="informalexample">
	<pre class="programlisting"><strong class="hl-keyword">void</strong> carregar_texturas(<strong class="hl-keyword">void</strong>){
  IMAGE *img;
  GLenum gluerr;

  <em class="hl-comment" style="color: silver">/* textura do plano */</em>
  glGenTextures(<span class="hl-number">1</span>, &amp;textura_plano);
  glBindTexture(GL_TEXTURE_<span class="hl-number">2</span>D, textura_plano);
  
  <strong class="hl-keyword">if</strong>(!(img=ImageLoad(TEXTURA_DO_PLANO))) {
    fprintf(stderr,<strong class="hl-string"><em style="color:red">"Error reading a texture.\n"</em></strong>);
    exit(-<span class="hl-number">1</span>);
  }</pre>

      </div>
      <p>A carga das texturas &eacute; feita com uso da fun&ccedil;&atilde;o <code class="function">ImageLoad()</code>, implementada em <a class="ulink" href="exemplos/image.c" target="_top"><code class="filename">image.c</code></a> e definida em <a class="ulink" href="exemplos/image.h" target="_top"><code class="filename">image.h</code></a>. Esta fun&ccedil;&atilde;o recebe como par&acirc;metro o nome do arquivo com a imagem da textura e retorna um ponteiro para uma estrutura de dados do tipo <span class="type">IMAGE</span>.</p> 
      <p>A fun&ccedil;&atilde;o <code class="function">glGenTextures()</code> gera 1 nome de textura em <code class="varname">textura_plano</code>. Um nome de textura &eacute; qualquer inteiro diferente de zero que identifique de forma &uacute;nica a textura. Assim, texturas diferentes possuem nomes diferentes. Caso o segundo par&acirc;metro desta fun&ccedil;&atilde;o seja um vetor de elementos <span class="type">GLuint</span>, mais nomes de textura podem ser gerados, um para cada elemento deste vetor.</p>

      <div class="informalexample">
	<pre class="programlisting">gluerr=gluBuild2DMipmaps(GL_TEXTURE_<span class="hl-number">2</span>D, <span class="hl-number">3</span>, 
			   img-&gt;sizeX, img-&gt;sizeY, 
			   GL_RGB, GL_UNSIGNED_BYTE, 
			   (GLvoid *)(img-&gt;data));</pre>

      </div>
      <p>Mipmaps s&atilde;o s&eacute;ries de vers&otilde;es em baixa resolu&ccedil;&atilde;o de um mapa de textura. Geralmente &eacute; utilizado para texturizar um objeto cuja resolu&ccedil;&atilde;o na tela difere da resolu&ccedil;&atilde;o no mapa de textura. Por exemplo, um objeto pr&oacute;ximo da tela pode ser desenhado utilizando uma resolu&ccedil;&atilde;o de textura maior que um objeto distante da tela. O uso de mipmaps evita o efeito de serrilhamento (<span class="foreignphrase"><em class="foreignphrase">aliasing</em></span>) e outros dist&uacute;rbios de exibi&ccedil;&atilde;o quando um objeto &eacute; aproximado ou afastado da tela.</p> 
      <p>Mipmaps bidimensionais s&atilde;o constru&iacute;dos com a fun&ccedil;&atilde;o <code class="function">gluBuild2dMipmaps()</code>, que possuiu seguinte prot&oacute;tipo:</p>
      <div class="funcsynopsis">
	<table border="0" class="funcprototype-table" summary="Function synopsis" style="cellspacing: 0; cellpadding: 0;"><tr><td><code class="funcdef">void <b class="fsfunc">gluBuild2dMipmaps</b>(</code></td><td><var class="pdparam">target</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">internalFormat</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">width</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">height</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">format</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">type</var>, </td><td>&nbsp;</td></tr><tr><td>&nbsp;</td><td><var class="pdparam">*data</var><code>)</code>;</td><td>&nbsp;</td></tr></table><div class="paramdef-list"><code>GLenum <var class="pdparam">target</var></code>;<br><code>GLint <var class="pdparam">internalFormat</var></code>;<br><code>GLsizei <var class="pdparam">width</var></code>;<br><code>GLsizei <var class="pdparam">height</var></code>;<br><code>GLenum <var class="pdparam">format</var></code>;<br><code>GLenum <var class="pdparam">type</var></code>;<br><code>const void <var class="pdparam">*data</var></code>;</div><div class="funcprototype-spacer">&nbsp;</div>
      </div>
      <p><em class="parameter"><code>target</code></em> indica o tipo de mipmaps que se deseja construir - neste caso uma textura bidimensional. <em class="parameter"><code>internalFormat</code></em> indica o tipo de armazenagem interna do arquivo de textura. Neste exemplo, as texturas s&atilde;o imagens RGB, incluindo 3 (tr&ecirc;s) componentes de cor. Os par&acirc;metros <em class="parameter"><code>width</code></em> e <em class="parameter"><code>height</code></em> especificam a largura e a altura do dado. Ambas estas dimens&otilde;es devem ser pot&ecirc;ncias de 2. <em class="parameter"><code>format</code></em> especifica o formato dos pixels do dado (RGB). <em class="parameter"><code>type</code></em> especifica o tipo de dado representado no vetor de dados. <em class="parameter"><code>data</code></em> especifica o ponteiro para a posi&ccedil;&atilde;o de mem&oacute;ria onde os dados de textura residem. </p>

      <div class="informalexample">
	<pre class="programlisting">glTexParameterf(GL_TEXTURE_<span class="hl-number">2</span>D,GL_TEXTURE_WRAP_S,GL_REPEAT);
  glTexParameterf(GL_TEXTURE_<span class="hl-number">2</span>D,GL_TEXTURE_WRAP_T,GL_REPEAT);</pre>

      </div>
      <p>A fun&ccedil;&atilde;o <code class="function">glTexParameterf()</code> define uma s&eacute;rie de par&acirc;metros que controlam como uma textura &eacute; tratada e aplicada a um fragmento de um dado objeto. Aqui, atrav&eacute;s dos par&acirc;metros <em class="parameter"><code>GL_TEXTURE_WRAP_S</code></em> e <em class="parameter"><code>GL_TEXTURE_WRAP_T</code></em>, a fun&ccedil;&atilde;o define que nas dire&ccedil;&otilde;es s e t (coordenadas) a textura dever&aacute; ser&aacute; repetida no objeto.</p> 

      <div class="informalexample">
	<pre class="programlisting">glTexParameterf(GL_TEXTURE_<span class="hl-number">2</span>D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR);
  glTexParameterf(GL_TEXTURE_<span class="hl-number">2</span>D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);</pre>

      </div>
      <p>Neste trecho do c&oacute;digo, as fun&ccedil;&otilde;es <code class="function">glTexParameterf()</code> define os tipos de filtro usados quando a textura for minimizada ou maximizada. Pelo par&acirc;metro <em class="parameter"><code>GL_LINEAR_MIPMAP_LINEAR</code></em>, o OpenGL escolhe dois mipmaps que mais aproximam o tamanho do pixel a ser texturizado calcula a m&eacute;dia dos quatro elementos de textura mais pr&oacute;ximos do centro do pixel. O valor da textura para o pixel ser&aacute; a m&eacute;dia desses dois valores. O par&acirc;metro <em class="parameter"><code>GL_LINEAR</code></em>, por sua vez n&atilde;o utiliza mipmaps: associa ao pixel a ser texturizado a m&eacute;dia dos quatro elementos de textura mais pr&oacute;ximos do centro do pixel.</p> 
    </div>
    <div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="modelagem-exercicios"></a>6.2. Exerc&iacute;cios</h2></div></div></div>
      
      <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
	  <p>Utilizando o programa <a class="ulink" href="exemplos/jato.c" target="_top"><code class="filename">jato.c</code></a> como refer&ecirc;ncia, implemente um programa <code class="filename">superjato.c</code>. Caso voc&ecirc; ainda n&atilde;o tenha notado, o avi&atilde;o a jato deste exemplo n&atilde;o possui uma turbina. Fa&ccedil;a-o mais feliz, projetando essa turbina e acoplando-a &agrave; parte traseira do jato no seu novo programa. O modelo da turbina fica a seu gosto. Acrescente tamb&eacute;m dois m&iacute;sseis sob as asas.
</p>
	</li><li class="listitem">
	  <p>Crie um logotipo utilizando um programa de manipula&ccedil;&atilde;o de imagens de sua prefer&ecirc;ncia. Salve-o no formato Iris RGB e mapeie-o na parte superior da asa, como mostra a <a class="xref" href="modelagem-solidos.html#fig-modelagem-logotipo" title="Figura 6.3. Exemplo de logotipo para o superjato">Figura&nbsp;6.3</a></p>
	  <div class="figure"><a name="fig-modelagem-logotipo"></a><p class="title"><b>Figura 6.3. Exemplo de logotipo para o superjato</b></p><div class="figure-contents">
	    
	<div class="mediaobject"><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="graphic"><img alt="figs/modelagem-logotipo.jpg" src="figs/modelagem-logotipo.jpg"></div></div>
	  </div></div><br class="figure-break">
	  
	</li></ol></div>

    </div>
  </div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="navfooter"><hr><table width="100%" class="navfoot" summary="Navigation footer"><tr><th width="40%" align="left"><a accesskey="p" class="navfoot" href="projecoes-geometricas.html">&laquo;&nbsp;Cap&iacute;tulo 5. Proje&ccedil;&otilde;es geom&eacute;tricas</a>&nbsp;</th><th width="20%" align="center"><a accesskey="h" class="navfoot" href="index.html">&#8657;Principal&#8657;</a></th><th width="40%" align="right">&nbsp;<a accesskey="n" class="navfoot" href="curvas-plano.html">Cap&iacute;tulo 7. Curvas no plano&nbsp;&raquo;</a></th></tr></table></div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="navheader"><hr><table class="navfoot" width="100%"><tr><td align="center"><p class="copyright">Copyright &copy; 2013 Agostinho Brito</p></td></tr></table></div></body></html>