<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Cap&iacute;tulo 8. Gabaritos</title><link rel="stylesheet" type="text/css" href="estilo.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Programa&ccedil;&atilde;o Orientada a Objetos em C++"><link rel="up" href="index.html" title="Programa&ccedil;&atilde;o Orientada a Objetos em C++"><link rel="prev" href="cha.ponteiros.objetos.html" title="Cap&iacute;tulo 7. Ponteiros e aloca&ccedil;&atilde;o din&acirc;mica de mem&oacute;ria"><link rel="next" href="cha.polimorfismo.html" title="Cap&iacute;tulo 9. Polimorfismo"><meta xmlns:fo="http://www.w3.org/1999/XSL/Format" http-equiv="Content-Type" content="text/html; charset=utf-8"><script xmlns:fo="http://www.w3.org/1999/XSL/Format" type="text/x-mathjax-config">
    MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/SVG"],
    tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]}
    });
  </script><script xmlns:fo="http://www.w3.org/1999/XSL/Format" type="text/javascript" src="/mathjax/MathJax.js"></script><script xmlns:fo="http://www.w3.org/1999/XSL/Format">
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      
      ga('create', 'UA-41839650-1', 'area8.dca.ufrn.br');
      ga('send', 'pageview');
      
    </script></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" class="navheader" href="cha.ponteiros.objetos.html">&laquo;</a></td><th colspan="3" align="center" class="navheader">Cap&iacute;tulo 8. Gabaritos</th><td width="20%" align="right">&nbsp;<a accesskey="n" class="navheader" href="cha.polimorfismo.html">&raquo;</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="cha.gabaritos"></a>Cap&iacute;tulo 8. Gabaritos</h1></div></div></div><div class="toc"><p><b>&Iacute;ndice</b></p><dl class="toc"><dt><span class="section"><a href="cha.gabaritos.html#sec.gabaritos.funcoes">8.1. Gabaritos de fun&ccedil;&otilde;es</a></span></dt><dt><span class="section"><a href="cha.gabaritos.html#sec.gabaritos.classes">8.2. Gabaritos de classes</a></span></dt></dl></div>
    
    <p>Considere novamente a classe <code class="classname">Vetor2d</code> descrita na se&ccedil;&atilde;o <a class="xref" href="cha.classes.objetos.html#sec.classes.objetos.vetor2d.descricao" title="3.2.1. Descri&ccedil;ao do programa vetor2d.cpp">Se&ccedil;&atilde;o&nbsp;3.2.1</a>, convenientemente reapresentada no <a class="xref" href="cha.gabaritos.html#exe.gabaritos.classevetor" title="Exemplo 8.1. Classe Vetor2d">Exemplo&nbsp;8.1</a>.</p>
    <div class="example"><a name="exe.gabaritos.classevetor"></a><p class="title"><b>Exemplo 8.1. Classe Vetor2d</b></p><div class="example-contents">
      
      <pre class="programlisting">#include &lt;iostream&gt;

<strong class="hl-keyword">using</strong> <strong class="hl-keyword">namespace</strong> std;

<strong class="hl-keyword">class</strong> Vetor2d{
<strong class="hl-keyword">private</strong>:
  <strong class="hl-keyword">float</strong> x, y;
<strong class="hl-keyword">public</strong>:
  <strong class="hl-keyword">void</strong> setX(<strong class="hl-keyword">float</strong> _x){
	x = _x;
  }
  <strong class="hl-keyword">float</strong> getX(<strong class="hl-keyword">void</strong>){
	<strong class="hl-keyword">return</strong> x;
  }
  <strong class="hl-keyword">void</strong> setY(<strong class="hl-keyword">float</strong> _y){
	y = _y;
  }
  <strong class="hl-keyword">float</strong> getY(<strong class="hl-keyword">void</strong>){
	<strong class="hl-keyword">return</strong> y;
  }
};

<strong class="hl-keyword">int</strong> main(<strong class="hl-keyword">void</strong>){
  Vetor2d v1;
  v1.setX(<span class="hl-number">4.5</span>);
  v1.setY(-<span class="hl-number">1.3</span>);
  cout &lt;&lt; v1.getX() &lt;&lt; <strong class="hl-string"><em style="color:red">" "</em></strong> &lt;&lt; v1.getY() &lt;&lt; <strong class="hl-string"><em style="color:red">"\n"</em></strong>;
}
</pre>
    </div></div><br class="example-break">
    <p>Repare que o tipo de dado <span class="token">float</span> foi escolhido para representar as coordenadas espaciais <span class="inlinemediaobject"><span class="phrase">$(x, y)$</span></span> para os objetos da classe.</p>
    <p>Imagine agora que fosse necess&aacute;rio realizar uma implementa&ccedil;&atilde;o similar, desta vez usando o tipo de dado <span class="token">double</span>, para atender a uma necessidade adicional. A solu&ccedil;&atilde;o &oacute;bvia seria implementar uma nova classe, substituindo as ocorr&ecirc;ncias do tipo <span class="token">float</span> por <span class="token">double</span>, como mostra o exemplo <a class="xref" href="cha.gabaritos.html#exe.gabaritos.classevetor.double" title="Exemplo 8.2. Classe Vetor2dDouble">Exemplo&nbsp;8.2</a>.</p>
    <div class="example"><a name="exe.gabaritos.classevetor.double"></a><p class="title"><b>Exemplo 8.2. Classe Vetor2dDouble</b></p><div class="example-contents">
      
      <pre class="programlisting">#include &lt;iostream&gt;

<strong class="hl-keyword">using</strong> <strong class="hl-keyword">namespace</strong> std;

<strong class="hl-keyword">class</strong> Vetor2dDouble{
<strong class="hl-keyword">private</strong>:
  <strong class="hl-keyword">double</strong> x, y;
<strong class="hl-keyword">public</strong>:
  <strong class="hl-keyword">void</strong> setX(<strong class="hl-keyword">double</strong> _x){
	x = _x;
  }
  <strong class="hl-keyword">double</strong> getX(<strong class="hl-keyword">void</strong>){
	<strong class="hl-keyword">return</strong> x;
  }
  <strong class="hl-keyword">void</strong> setY(<strong class="hl-keyword">double</strong> _y){
	y = _y;
  }
  <strong class="hl-keyword">double</strong> getY(<strong class="hl-keyword">void</strong>){
	<strong class="hl-keyword">return</strong> y;
  }
};

<strong class="hl-keyword">int</strong> main(<strong class="hl-keyword">void</strong>){
  Vetor2d v1;
  v1.setX(<span class="hl-number">4.5</span>);
  v1.setY(-<span class="hl-number">1.3</span>);
  cout &lt;&lt; v1.getX() &lt;&lt; <strong class="hl-string"><em style="color:red">" "</em></strong> &lt;&lt; v1.getY() &lt;&lt; <strong class="hl-string"><em style="color:red">"\n"</em></strong>;
}
</pre>
    </div></div><br class="example-break">
    <p>Comparando o <a class="xref" href="cha.gabaritos.html#exe.gabaritos.classevetor" title="Exemplo 8.1. Classe Vetor2d">Exemplo&nbsp;8.1</a> com o  <a class="xref" href="cha.gabaritos.html#exe.gabaritos.classevetor.double" title="Exemplo 8.2. Classe Vetor2dDouble">Exemplo&nbsp;8.2</a> d&aacute; para se constatar facilmente o desperd&iacute;cio de c&oacute;digo que reescrito na nova classe. Ainda, restar&aacute; para o programador a necessidade de fazer a distin&ccedil;&atilde;o correta dos nomes de duas classes que fazem praticamente a mesma coisa. O problema se agrava ainda mais quando se faz necess&aacute;rio dispor de diversas implementa&ccedil;&otilde;es semelhantes &agrave; classe <code class="classname">Vetor2d</code> para outros tipos de dados, como <span class="token">int</span>, <span class="token">long double</span>, <span class="token">char</span>, etc.. Esta solu&ccedil;&atilde;o &eacute;, de fato, impratic&aacute;vel e formas alternativas de solucionar este problema encontram-se dispon&iacute;veis.</p>
    <p>Em C++, a solu&ccedil;&atilde;o &eacute; feita usando programa&ccedil;&atilde;o gen&eacute;rica com gabaritos (ou <span class="foreignphrase"><em class="foreignphrase">templates</em></span>).</p>
    <p>Um gabarito &eacute; um tipo especial de defini&ccedil;&atilde;o que permite ao usu&aacute;rio criar fun&ccedil;&otilde;es e classes adaptadas para um ou mais tipos sem a necessidade de reescrever todo o c&oacute;digo para cada tipo. Para isso, a programa&ccedil;&atilde;o com gabaritos permite que o usu&aacute;rio passe como par&acirc;metro para a cria&ccedil;&atilde;o de determinadas estruturas os tipos de dados a serem usados, ao inv&eacute;s dos valores como &eacute; tradicionalmente realizado em C.</p>
    <p>Dois tipos de gabaritos s&atilde;o previstos em C++: gabaritos de fun&ccedil;&atilde;o e gabaritos de classe, destinados &agrave; programa&ccedil;&atilde;o gen&eacute;rica de classes e fun&ccedil;&otilde;es, respectivamente.</p>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.gabaritos.funcoes"></a>8.1. Gabaritos de fun&ccedil;&otilde;es</h2></div></div></div>
      
      <p>Um gabarito de fun&ccedil;&atilde;o pode ser declarado usando a palavra reservada <span class="token">template</span>, seguido da identifica&ccedil;&atilde;o dos tipos que se deseja utilizar e da declara&ccedil;&atilde;o da fun&ccedil;&atilde;o que sofrer&aacute; a a&ccedil;&atilde;o do gabarito, por uma das seguintes formas:</p>
      <pre class="programlisting"><strong class="hl-keyword">template</strong> &lt;<strong class="hl-keyword">class</strong> identificador_do_tipo&gt; declaracao_da_funcao;
<strong class="hl-keyword">template</strong> &lt;<strong class="hl-keyword">typename</strong> identificador_do_tipo&gt; declaracao_da_funcao;</pre>
      <p>O identificador do tipo &eacute; um s&iacute;mbolo que poder&aacute; aparecer na fun&ccedil;&atilde;o que se segue. Todas as ocorr&ecirc;ncias deste identificador ser&atilde;o substitu&iacute;das pelo tipo de dado fornecido pelo usu&aacute;rio na chamada da fun&ccedil;&atilde;o. Na pr&aacute;tica, n&atilde;o h&aacute; diferen&ccedil;a entre esses tipo de declara&ccedil;&atilde;o al&eacute;m das palavras reservadas <span class="token">class</span> e <span class="token">typename</span> que aparecem. O efeito resultante do uso de uma ou outra forma &eacute; exatamente igual. </p>
      <p>Cada declara&ccedil;&atilde;o de gabarito influencia apenas o bloco funcional que lhe &eacute; imediatamente posterior, n&atilde;o surtindo efeito para os demais blocos funcionais que se seguem no programa.</p>
      <p>A chamada de uma fun&ccedil;&atilde;o criada com gabaritos, por sua vez, &eacute; feita incluindo na declara&ccedil;&atilde;o o tipo que se deseja utilizar na fun&ccedil;&atilde;o implementada e dever&aacute; seguir o seguinte molde:</p>
      <pre class="programlisting">funcao &lt;tipo&gt; (argumentos);</pre>
      <p>Para ilustrar o uso do gabarito, considere uma fun&ccedil;&atilde;o que calcula a m&eacute;dia entre dois n&uacute;meros dados. Uma poss&iacute;vel implementa&ccedil;&atilde;o para esta fun&ccedil;&atilde;o &eacute; mostrada no <a class="xref" href="cha.gabaritos.html#exe.gabaritos.media" title="Exemplo 8.3. Gabarito de fun&ccedil;&atilde;o para c&aacute;lculo de m&eacute;dia aritm&eacute;tica">Exemplo&nbsp;8.3</a>.</p>
      <div class="example"><a name="exe.gabaritos.media"></a><p class="title"><b>Exemplo 8.3. Gabarito de fun&ccedil;&atilde;o para c&aacute;lculo de m&eacute;dia aritm&eacute;tica</b></p><div class="example-contents">
	
	<pre class="programlisting">#include &lt;iostream&gt;

<strong class="hl-keyword">using</strong> <strong class="hl-keyword">namespace</strong> std;

<strong class="hl-keyword">template</strong> &lt;<strong class="hl-keyword">class</strong> Tipo&gt;
Tipo media(Tipo a, Tipo b){
  Tipo resultado;
  resultado = (a+b)/<span class="hl-number">2</span>;
  <strong class="hl-keyword">return</strong> (resultado);
}

<strong class="hl-keyword">int</strong> main(<strong class="hl-keyword">void</strong>){
  <strong class="hl-keyword">int</strong> ix, iy;
  <strong class="hl-keyword">float</strong> fx, fy;
  <strong class="hl-keyword">double</strong> dx, dy;
  ix = <span class="hl-number">3</span>; iy = <span class="hl-number">4</span>;
  fx = <span class="hl-number">3</span>; fy = <span class="hl-number">4</span>;
  dx = <span class="hl-number">3</span>; dy = <span class="hl-number">4</span>;
  cout &lt;&lt; media&lt;<strong class="hl-keyword">int</strong>&gt;(ix,iy) &lt;&lt; <strong class="hl-string"><em style="color:red">"\n"</em></strong>;
  cout &lt;&lt; media&lt;<strong class="hl-keyword">float</strong>&gt;(fx,fy) &lt;&lt; <strong class="hl-string"><em style="color:red">"\n"</em></strong>;
  cout &lt;&lt; media&lt;<strong class="hl-keyword">double</strong>&gt;(dx,dy) &lt;&lt; <strong class="hl-string"><em style="color:red">"\n"</em></strong>;
}
</pre>    
      </div></div><br class="example-break">
      <p>A primeira linha que precede a declara&ccedil;&atilde;o da fun&ccedil;&atilde;o <code class="function">media()</code> caracteriza o in&iacute;cio da defini&ccedil;&atilde;o do <span class="foreignphrase"><em class="foreignphrase">template</em></span>.</p>
      <pre class="programlisting"><strong class="hl-keyword">template</strong> &lt;<strong class="hl-keyword">class</strong> Tipo&gt;</pre>
      <p>Este template dever&aacute; influenciar apenas o bloco funcional que lhe &eacute; imediatamente posterior. Neste caso, a implementa&ccedil;&atilde;o da fun&ccedil;&atilde;o <code class="function">media()</code>. O identificador <code class="varname">Tipo</code> que aparece dentro da defini&ccedil;&atilde;o do gabarito ser&aacute; substituido na fun&ccedil;&atilde;o que se segue pelo tipo de dado fornecido pelo usu&aacute;rio quando chamar a fun&ccedil;&atilde;o criada, como feito no exemplo:</p>
      <pre class="programlisting">media&lt;<strong class="hl-keyword">int</strong>&gt;(ix,iy)</pre>
      <p>Neste exemplo, quando o tipo <span class="token">int</span> &eacute; passado como par&acirc;metro na chamada da fun&ccedil;&atilde;o m&eacute;dia, todas as ocorr&ecirc;ncias do identificador <code class="varname">Tipo</code> ser&atilde;o substitu&iacute;das pelo tipo inteiro fornecido. Quando o compilador encontra uma chamada para o template, ele automaticamente gera c&oacute;digo para a fun&ccedil;&atilde;o com a substitui&ccedil;&atilde;o mencionada e ent&atilde;o chama esta fun&ccedil;&atilde;o criada de modo totalmente invis&iacute;vel para o programador. Na pr&aacute;tica, a fun&ccedil;&atilde;o m&eacute;dia &eacute; usada neste momento como se houvesse sido declarada da seguinte forma:</p>
      <pre class="programlisting"><strong class="hl-keyword">int</strong> media(<strong class="hl-keyword">int</strong> a, <strong class="hl-keyword">int</strong> b){
  <strong class="hl-keyword">int</strong> resultado;
  resultado = (a+b)/<span class="hl-number">2</span>;
  <strong class="hl-keyword">return</strong> (resultado);
}</pre>
      <p>Esta solu&ccedil;&atilde;o simples gera uma economia razo&aacute;vel de esfor&ccedil;os de programa&ccedil;&atilde;o quando ocorre a necessidade de implementar fun&ccedil;&otilde;es que lidam com argumentos de tipos variados mas realizam exatamente as mesmas opera&ccedil;&otilde;es.</p>
    </div>
    <div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec.gabaritos.classes"></a>8.2. Gabaritos de classes</h2></div></div></div>
      
      <p>Gabaritos de classes operam de forma bem semelhante aos gabaritos de fun&ccedil;&otilde;es, seguindo os mesmos moldes na defini&ccedil;&atilde;o.</p>
      <p>Usando o conceito de gabaritos &eacute; poss&iacute;vel reescrever a classe <code class="classname">Vetor2d</code> apresentada no in&iacute;cio deste cap&iacute;tulo de modo a torn&aacute;-la gen&eacute;rica, adapt&aacute;vel a quaisquer tipos v&aacute;lidos que se deseje utilizar. Quando se menciona a express&atilde;o <span class="emphasis"><em>tipos v&aacute;lidos</em></span> deseja-se chamar a aten&ccedil;&atilde;o ao fato de que os tipos fornecidos para instanciar a classe devem prever todas as opera&ccedil;&otilde;es implementadas dentro dessa classe. Por exemplo, se na implementa&ccedil;&atilde;o da classe, um dos operadores da linguagem &eacute; aplicado ao tipo fornecido, este tipo (seja ele primitivo ou uma classe definida pelo usu&aacute;rio) deve prever como ser&aacute; feita a lide com este operador! A mesma restri&ccedil;&atilde;o vale tamb&eacute;m para os gabaritos de fun&ccedil;&atilde;o. O <a class="xref" href="cha.gabaritos.html#exe.gabaritos.vetor2d.gabarito" title="Exemplo 8.4. Redefini&ccedil;&atilde;o da classe Vetor2d usando templates (arquivo gabarito-vetor.cpp).">Exemplo&nbsp;8.4</a> apresenta a redefini&ccedil;&atilde;o da classe <code class="classname">Vetor2d</code> usando gabaritos.</p>
      <div class="example"><a name="exe.gabaritos.vetor2d.gabarito"></a><p class="title"><b>Exemplo 8.4. Redefini&ccedil;&atilde;o da classe <code class="classname">Vetor2d</code> usando <span class="foreignphrase"><em class="foreignphrase">templates</em></span> (arquivo <a class="ulink" href="exemplos/gabarito-vetor.cpp" target="_top"><code class="filename">gabarito-vetor.cpp</code></a>).</b></p><div class="example-contents">
	
	<pre class="programlisting">#include &lt;iostream&gt;

<strong class="hl-keyword">using</strong> <strong class="hl-keyword">namespace</strong> std;

<strong class="hl-keyword">template</strong> &lt;<strong class="hl-keyword">class</strong> T&gt;
<strong class="hl-keyword">class</strong> Vetor2d{
<strong class="hl-keyword">private</strong>:
  T x, y;
<strong class="hl-keyword">public</strong>:
  <strong class="hl-keyword">void</strong> setX(T _x){
	x = _x;
  }
  T getX(<strong class="hl-keyword">void</strong>){
	<strong class="hl-keyword">return</strong> x;
  }
  <strong class="hl-keyword">void</strong> setY(T _y);
  T getY(<strong class="hl-keyword">void</strong>);
};

<strong class="hl-keyword">template</strong> &lt;<strong class="hl-keyword">class</strong> T&gt;
<strong class="hl-keyword">void</strong> Vetor2d&lt;T&gt;::setY(T _y){
  y = _y;
}

<strong class="hl-keyword">template</strong> &lt;<strong class="hl-keyword">class</strong> T&gt;
T Vetor2d&lt;T&gt;::getY(<strong class="hl-keyword">void</strong>){
  <strong class="hl-keyword">return</strong> y;
}

<strong class="hl-keyword">int</strong> main(<strong class="hl-keyword">void</strong>){
  Vetor2d&lt;<strong class="hl-keyword">float</strong>&gt; v1;
  Vetor2d&lt;<strong class="hl-keyword">int</strong>&gt; v2;
  v1.setX(<span class="hl-number">4.5</span>);  v1.setY(-<span class="hl-number">1.3</span>);
  v2.setX(<span class="hl-number">4.5</span>);  v2.setY(-<span class="hl-number">1.3</span>);
  cout &lt;&lt; v1.getX() &lt;&lt; <strong class="hl-string"><em style="color:red">" "</em></strong> &lt;&lt; v1.getY() &lt;&lt; <strong class="hl-string"><em style="color:red">"\n"</em></strong>;
  cout &lt;&lt; v2.getX() &lt;&lt; <strong class="hl-string"><em style="color:red">" "</em></strong> &lt;&lt; v2.getY() &lt;&lt; <strong class="hl-string"><em style="color:red">"\n"</em></strong>;
}
</pre>
      </div></div><br class="example-break">
      <p>Quando compilado e executado, o <a class="xref" href="cha.gabaritos.html#exe.gabaritos.vetor2d.gabarito" title="Exemplo 8.4. Redefini&ccedil;&atilde;o da classe Vetor2d usando templates (arquivo gabarito-vetor.cpp).">Exemplo&nbsp;8.4</a> produz o seguinte resultado:</p>
      <pre class="screen">
<code class="prompt">$</code> <span class="command"><strong>g++</strong></span> gabarito-vetor.cpp <code class="option">-o</code> gabarito-vetor
<code class="prompt">$</code> <span class="command"><strong>./gabarito-vetor</strong></span><code class="computeroutput">
4.5 -1.3
4 3 </code></pre>

      <p>Neste exemplo, o s&iacute;mbolo <code class="varname">T</code> recebe o tipo fornecido pelo usu&aacute;rio e todas as ocorr&ecirc;ncias deste s&iacute;mbolo na implementa&ccedil;&atilde;o da classe s&atilde;o substitu&iacute;das, durante a compila&ccedil;&atilde;o, por este tipo. Assim como para os gabaritos de fun&ccedil;&otilde;es, o compilador gera automaticamente uma implementa&ccedil;&atilde;o da classe com o s&iacute;mbolo fornecido e ent&atilde;o instancia propriamente o objeto. Na pr&aacute;tica, nenhum c&oacute;digo &eacute; gerado para uma classe ou fun&ccedil;&atilde;o definida com gabaritos at&eacute; que uma delas seja instanciada.</p>
      <p>Na fun&ccedil;&atilde;o principal, duas instancia&ccedil;&otilde;es da classe s&atilde;o feitas: uma para o tipo <span class="token">int</span>, associada ao objeto <code class="varname">v1</code> e outra para o tipo <span class="token">float</span>, associada ao objeto <code class="varname">v2</code>. Observe que os valores do par de par&acirc;metros x e y passados para as fun&ccedil;&otilde;es <code class="function">setX()</code> e <code class="function">setY()</code> para ambos os objetos s&atilde;o exatamente iguais, mas produzem sa&iacute;das diferentes. Ocorre que, como a classe relativa ao objeto <code class="varname">v2</code> &eacute; gabaritada com o tipo inteiro, os valores passados para as fun&ccedil;&otilde;es <span class="emphasis"><em>set</em></span> sofrer&atilde;o convers&atilde;o de tipo antes de ser armazenados, da&iacute; o truncamento da parte fracion&aacute;ria do n&uacute;mero.</p>
      <p>Note que dois dos quatro m&eacute;todos da classe, <code class="function">setY()</code> e <code class="function">getY()</code> foram propositalmente implementados fora da declara&ccedil;&atilde;o dessa classe. Neste caso, deve-se sempre incluir uma nova declara&ccedil;&atilde;o de <span class="foreignphrase"><em class="foreignphrase">template</em></span> antes de proceder com a implementa&ccedil;&atilde;o do m&eacute;todo. Desta forma, linhas de c&oacute;digo semelhantes &agrave;s que se seguem dever&atilde;o se repetir em todas as situa&ccedil;&otilde;es similares.</p>
      <pre class="programlisting"><strong class="hl-keyword">template</strong> &lt;<strong class="hl-keyword">class</strong> T&gt;
T Vetor2d&lt;T&gt;::getY(<strong class="hl-keyword">void</strong>)</pre>
      <p>Neste trecho, o primeiro identificador <code class="varname">T</code> denota o nome da vari&aacute;vel, o segundo identificador representa o tipo de retorno, e o terceiro, inserido entre os sinais <span class="symbol"> &lt; </span> e <span class="symbol"> &gt; </span>, indica que a inst&acirc;ncia da classe criada &eacute; aquela que foi gabaritada com o tipo fornecido.</p>
      <p>Uma ressalva interessante cabe ao uso de gabaritos quando se deseja trabalhar com a programa&ccedil;&atilde;o em m&uacute;ltipos arquivos, ou seja, com a separa&ccedil;&atilde;o do c&oacute;digo em um arquivo de cabe&ccedil;alho (.h) e um arquivo de implementa&ccedil;&atilde;o (.cpp). A cria&ccedil;&atilde;o de classes e fun&ccedil;&otilde;es pelo uso de gabaritos &eacute; feita exclusivamente sob demanda, ou seja, tais estruturas somente passam a existir a partir do momento em que s&atilde;o instanciadas. Dessa forma, n&atilde;o h&aacute; sentido algum em compilar em um arquivo separado uma classe definida atrav&eacute;s de gabaritos. Se assim fosse, por exemplo, na classe <code class="classname">Vetor2d</code> mostrada no exemplo, quantos bytes deveriam ser reservados pelo compilador para o tipo de dado <code class="varname">T</code> que &eacute; previsto na defini&ccedil;&atilde;o?</p>
    </div>
  </div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="navfooter"><hr><table width="100%" class="navfoot" summary="Navigation footer"><tr><th width="40%" align="left"><a accesskey="p" class="navfoot" href="cha.ponteiros.objetos.html">&laquo;&nbsp;Cap&iacute;tulo 7. Ponteiros e aloca&ccedil;&atilde;o din&acirc;mica de mem&oacute;ria</a>&nbsp;</th><th width="20%" align="center"><a accesskey="h" class="navfoot" href="index.html">&#8657;Principal&#8657;</a></th><th width="40%" align="right">&nbsp;<a accesskey="n" class="navfoot" href="cha.polimorfismo.html">Cap&iacute;tulo 9. Polimorfismo&nbsp;&raquo;</a></th></tr></table></div><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="navheader"><hr><table class="navfoot" width="100%"><tr><td align="center"><p class="copyright">Copyright &copy; 2012 Agostinho Brito</p></td></tr></table></div></body></html>